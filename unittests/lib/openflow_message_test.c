/*
 * Unit tests of functions for creating OpenFlow messages.
 *
 * Author: Yasunori Nakazawa
 *
 * Copyright (C) 2008-2012 NEC Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2, as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


#include <arpa/inet.h>
#include <openflow.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <netinet/ip.h>
#include <net/if_arp.h>
#include "byteorder.h"
#include "checks.h"
#include "cmockery_trema.h"
#include "log.h"
#include "openflow_message.h"
#include "wrapper.h"


extern uint16_t get_actions_length( const openflow_actions *actions );
extern uint16_t get_instructions_length( const openflow_instructions *instructions );
extern buffer * create_multipart_request( const uint32_t transaction_id, const uint16_t type,
                                      const uint16_t length, const uint16_t flags );
extern buffer * create_multipart_reply( const uint32_t transaction_id, const uint16_t type,
                                    const uint16_t length, const uint16_t flags );
extern int validate_multipart_request( const buffer *message );
extern int validate_multipart_reply( const buffer *message );

static const uint16_t ARP_OP_MASK = 0x00ff; // 8bits
static const uint32_t BUFFER_ID = 0x12345678;
static const uint16_t NO_FLAGS = 0;
static const uint16_t NO_ERROR = 0;
static const uint16_t PRIORITY = 65535;
static const uint32_t MY_TRANSACTION_ID = 0x04030201;
static const uint16_t ONE_MINUTES_TIMEOUT = 60;
static const uint64_t ISSUED_COOKIE = 0x0102030405060708ULL;
static const uint64_t RECEIVED_PACKETS = 50000;
static const uint64_t RECEIVED_BYTES = 300000;
static const uint64_t TRANSMITTED_PACKETS = 50000;
static const uint64_t TRANSMITTED_BYTES = 300000;
static const uint32_t SUPPORTED_ENTRIES_IN_OFPST_TABLE = 10000;
static const uint32_t ACTIVE_ENTRIES_IN_OFPST_TABLE = 1000;
static const uint64_t PACKETS_LOOK_UP_IN_OFPST_TABLE = 10000;
static const uint64_t PACKETS_HIT_OFPST_TABLE = 100;
static const uint32_t EXPERIMENTER_ID = 0x00004cff;
static const uint32_t EXPERIMENTER_TYPE = 0x12345678;
static const uint16_t EXPERIMENTER_ERROR_TYPE = 0x1234;
static const uint16_t EXPERIMENTER_STATS_FLAG = 0xaabb;
static const uint8_t HW_ADDR[ OFP_ETH_ALEN ] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };
static const uint32_t NW_ADDR = 0x12345678;
static const uint8_t NW_TOS = 0xfc;
static const uint16_t MAX_LENGTH_OF_SEND_PACKET = 128;
static const uint16_t SHORT_DATA_LENGTH = 32;
static const uint16_t LONG_DATA_LENGTH = 64;
static const uint32_t PORT_FEATURES = ( OFPPF_10MB_HD | OFPPF_10MB_FD | OFPPF_100MB_HD |
                                        OFPPF_100MB_FD | OFPPF_1GB_HD | OFPPF_1GB_FD |
                                        OFPPF_10GB_FD | OFPPF_40GB_FD | OFPPF_100GB_FD |
                                        OFPPF_1TB_FD | OFPPF_OTHER | OFPPF_COPPER |
                                        OFPPF_FIBER | OFPPF_AUTONEG | OFPPF_PAUSE |
                                        OFPPF_PAUSE_ASYM );


/********************************************************************************
 * Mock function.
 ********************************************************************************/

#define FAKE_PID 1234;

pid_t
mock_getpid() {
  return FAKE_PID;
}


void
mock_die( char *format, ... ) {
  UNUSED( format );
}


void
mock_debug( char *format, ... ) {
  UNUSED( format );
}


static int
mock_get_logging_level() {
  return LOG_DEBUG;
}


/********************************************************************************
 * Common function.
 ********************************************************************************/

static buffer *
create_dummy_data( uint16_t length ) {
  buffer *data = alloc_buffer_with_length( length );
  void *p = append_back_buffer( data, length );
  memset( p, 0xaf, length );

  return data;
}


static struct ofp_port *port_desc_testdata[2] = { NULL, NULL };
static uint16_t port_desc_testdata_len[2] = { 0, 0 };


static void
delete_port_desc_testdata( void ) {
  if ( port_desc_testdata[0] != NULL ) {
    xfree( port_desc_testdata[0] );
    port_desc_testdata[0] = NULL;
  }
  if ( port_desc_testdata[1] != NULL ) {
    xfree( port_desc_testdata[1] );
    port_desc_testdata[1] = NULL;
  }
  memset( port_desc_testdata_len, 0, sizeof( port_desc_testdata_len ) );
}


static void
create_port_desc_testdata( void ) {
  struct ofp_port *desc;

  delete_port_desc_testdata();

  desc = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );

  desc->port_no = 1;
  memset( desc->pad, '\0', sizeof( desc->pad ) );
  memcpy( desc->hw_addr, HW_ADDR, sizeof( desc->hw_addr ) );
  memset( desc->pad2, '\0', sizeof( desc->pad2 ) );
  memset( desc->name, '\0', OFP_MAX_PORT_NAME_LEN );
  strcpy( desc->name, "Navy" );
  desc->config = OFPPC_PORT_DOWN;
  desc->state = OFPPS_LINK_DOWN;
  desc->curr = ( OFPPF_1GB_FD | OFPPF_COPPER | OFPPF_PAUSE );
  desc->advertised = PORT_FEATURES;
  desc->supported = PORT_FEATURES;
  desc->peer = PORT_FEATURES;
  desc->curr_speed = 0x10203040;
  desc->max_speed = 0x50607080;

  port_desc_testdata[0] = desc;
  port_desc_testdata_len[0] = sizeof( struct ofp_port );


  desc = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );

  desc->port_no = 2;
  memset( desc->pad, '\0', sizeof( desc->pad ) );
  memcpy( desc->hw_addr, HW_ADDR, sizeof( desc->hw_addr ) );
  memset( desc->pad2, '\0', sizeof( desc->pad2 ) );
  memset( desc->name, '\0', OFP_MAX_PORT_NAME_LEN );
  strcpy( desc->name, "Hoge" );
  desc->config = OFPPC_PORT_DOWN;
  desc->state = OFPPS_LINK_DOWN;
  desc->curr = ( OFPPF_1GB_FD | OFPPF_COPPER | OFPPF_PAUSE );
  desc->advertised = PORT_FEATURES;
  desc->supported = PORT_FEATURES;
  desc->peer = PORT_FEATURES;
  desc->curr_speed = 0x11223344;
  desc->max_speed = 0x55667788;

  port_desc_testdata[1] = desc;
  port_desc_testdata_len[1] = sizeof( struct ofp_port );
}


static oxm_match_header *oxm_match_testdata[2] = { NULL, NULL };
static uint16_t oxm_match_testdata_len[2] = { 0, 0 };
struct ofp_match *expected_ofp_match = NULL;
static uint16_t expected_ofp_match_len = 0;


static void
delete_oxm_match_testdata( void ) {
  if ( oxm_match_testdata[0] != NULL ) {
    xfree( oxm_match_testdata[0] );
    oxm_match_testdata[0] = NULL;
  }
  if ( oxm_match_testdata[1] != NULL ) {
    xfree( oxm_match_testdata[1] );
    oxm_match_testdata[1] = NULL;
  }
  if ( expected_ofp_match != NULL ) {
    xfree( expected_ofp_match );
    expected_ofp_match = NULL;
  }
  memset( oxm_match_testdata_len, 0, sizeof( oxm_match_testdata_len ) );
  expected_ofp_match_len = 0;
}


static void
create_oxm_match_testdata( void ) {
  uint16_t offset = sizeof( oxm_match_header );
  uint32_t type;
  uint16_t match_len;
  uint32_t *val32;
  oxm_match_header *match;
  struct ofp_match *ofp_match;
  uint16_t ofp_match_len;
  uint16_t ofp_match_len_with_pad;
  void *v;

  delete_oxm_match_testdata();

  type = OXM_OF_IN_PORT;
  match_len = ( uint16_t ) ( offset + OXM_LENGTH( type ) );
  match = ( oxm_match_header * ) xcalloc( 1, match_len );
  *match = type;
  val32 = ( uint32_t * ) ( ( char * ) match + offset );
  *val32 = 0x01020304;

  oxm_match_testdata[0] = match;
  oxm_match_testdata_len[0] = match_len;


  type = OXM_OF_IN_PHY_PORT;
  match_len = ( uint16_t ) ( offset + OXM_LENGTH( type ) );
  match = ( oxm_match_header * ) xcalloc( 1, match_len );
  *match = type;
  val32 = ( uint32_t * ) ( ( char * ) match + offset );
  *val32 = 0x05060708;

  oxm_match_testdata[1] = match;
  oxm_match_testdata_len[1] = match_len;

  ofp_match_len = ( uint16_t ) ( offsetof( struct ofp_match, oxm_fields )
                                + oxm_match_testdata_len[0]
                                + oxm_match_testdata_len[1] );
  ofp_match_len_with_pad = ( uint16_t ) ( ofp_match_len + PADLEN_TO_64( ofp_match_len ) );
  ofp_match = ( struct ofp_match * ) xcalloc( 1, ofp_match_len_with_pad );
  ofp_match->type = OFPMT_OXM;
  ofp_match->length = ofp_match_len;
  v = ( char * ) ofp_match + offsetof( struct ofp_match, oxm_fields );
  memcpy( v, oxm_match_testdata[0], oxm_match_testdata_len[0] );
  v = ( char * ) v + oxm_match_testdata_len[0];
  memcpy( v, oxm_match_testdata[1], oxm_match_testdata_len[1] );

  expected_ofp_match = ofp_match;
  expected_ofp_match_len = ofp_match_len_with_pad;
}


static struct ofp_action_header *action_testdata[2] = { NULL, NULL };
static uint16_t action_testdata_len[2] = { 0, 0 };


static void
delete_action_testdata( void ) {
  if ( action_testdata[0] != NULL ) {
    xfree( action_testdata[0] );
    action_testdata[0] = NULL;
  }
  if ( action_testdata[1] != NULL ) {
    xfree( action_testdata[1] );
    action_testdata[1] = NULL;
  }
  memset( action_testdata_len, 0, sizeof( action_testdata_len ) );
}


static void
create_action_testdata( void ) {
  uint16_t action_len;
  struct ofp_action_output *action;

  delete_action_testdata();

  action_len = ( uint16_t ) ( sizeof( struct ofp_action_output ) );
  action = ( struct ofp_action_output * ) xcalloc( 1, action_len );
  action->type = OFPAT_OUTPUT;
  action->len = action_len;
  action->port = 0x01020304;
  action->max_len = 0x0506;

  action_testdata[0] = ( struct ofp_action_header * ) action;
  action_testdata_len[0] = action_len;


  action_len = ( uint16_t ) ( sizeof( struct ofp_action_output ) );
  action = ( struct ofp_action_output * ) xcalloc( 1, action_len );
  action->type = OFPAT_OUTPUT;
  action->len = action_len;
  action->port = 0x0708090A;
  action->max_len = 0x0B0C;

  action_testdata[1] = ( struct ofp_action_header * ) action;
  action_testdata_len[1] = action_len;
}


static struct ofp_instruction *instruction_testdata[2] = { NULL, NULL };
static uint16_t instruction_testdata_len[2] = { 0, 0 };
struct ofp_instruction *expected_ofp_instruction = NULL;
static uint16_t expected_ofp_instruction_len = 0;


static void
delete_instruction_testdata( void ) {
  if ( instruction_testdata[0] != NULL ) {
    xfree( instruction_testdata[0] );
    instruction_testdata[0] = NULL;
  }
  if ( instruction_testdata[1] != NULL ) {
    xfree( instruction_testdata[1] );
    instruction_testdata[1] = NULL;
  }
  if ( expected_ofp_instruction != NULL ) {
    xfree( expected_ofp_instruction );
    expected_ofp_instruction = NULL;
  }
  memset( instruction_testdata_len, 0, sizeof( instruction_testdata_len ) );
  expected_ofp_instruction_len = 0;
}


static void
create_instruction_testdata( void ) {
  uint16_t instruction_len;
  uint16_t ofp_instruction_len;
  struct ofp_instruction *inst;
  struct ofp_instruction_meter *instruction;
  void *d;

  delete_instruction_testdata();

  instruction_len = ( uint16_t ) ( sizeof( struct ofp_instruction_meter ) );
  instruction = ( struct ofp_instruction_meter * ) xcalloc( 1, instruction_len );
  instruction->type = OFPIT_METER;
  instruction->len = instruction_len;
  instruction->meter_id = 0x01020304;

  instruction_testdata[0] = ( struct ofp_instruction * ) instruction;
  instruction_testdata_len[0] = instruction_len;


  instruction_len = ( uint16_t ) ( sizeof( struct ofp_instruction_meter ) );
  instruction = ( struct ofp_instruction_meter * ) xcalloc( 1, instruction_len );
  instruction->type = OFPIT_METER;
  instruction->len = instruction_len;
  instruction->meter_id = 0x05060708;

  instruction_testdata[1] = ( struct ofp_instruction * ) instruction;
  instruction_testdata_len[1] = instruction_len;

  ofp_instruction_len = ( uint16_t ) ( instruction_testdata_len[0] + instruction_testdata_len[1] );
  inst = ( struct ofp_instruction * ) xcalloc( 1, ofp_instruction_len );
  memcpy( inst, instruction_testdata[0], instruction_testdata_len[0] );
  d = ( char * ) inst + instruction_testdata_len[0];
  memcpy( d, instruction_testdata[1], instruction_testdata_len[1] );

  expected_ofp_instruction = inst;
  expected_ofp_instruction_len = ofp_instruction_len;
}


static struct ofp_bucket *bucket_testdata[2] = { NULL, NULL };
static uint16_t bucket_testdata_len[2] = { 0, 0 };


static void
delete_bucket_testdata( void ) {
  if ( bucket_testdata[0] != NULL ) {
    xfree( bucket_testdata[0] );
    bucket_testdata[0] = NULL;
  }
  if ( bucket_testdata[1] != NULL ) {
    xfree( bucket_testdata[1] );
    bucket_testdata[1] = NULL;
  }
  memset( bucket_testdata_len, 0, sizeof( bucket_testdata_len ) );
}


static void
create_bucket_testdata( void ) {
  uint16_t action_len;
  uint16_t bucket_len;
  struct ofp_bucket *bucket;
  struct ofp_action_output *act;

  delete_bucket_testdata();

  action_len = sizeof( struct ofp_action_output );
  bucket_len = ( uint16_t ) ( offsetof( struct ofp_bucket, actions ) + action_len );
  bucket = ( struct ofp_bucket * ) xcalloc( 1, bucket_len );
  bucket->len = bucket_len;
  bucket->weight = 0x1234;
  bucket->watch_port = 0x11223344;
  bucket->watch_group = 0x55667788;
  act = ( struct ofp_action_output * ) bucket->actions;
  act->type = OFPAT_OUTPUT;
  act->len = action_len;
  act->port = 0x01020304;
  act->max_len = 0x0506;

  bucket_testdata[0] = ( struct ofp_bucket * ) bucket;
  bucket_testdata_len[0] = bucket_len;


  action_len = sizeof( struct ofp_action_output );
  bucket_len = ( uint16_t ) ( offsetof( struct ofp_bucket, actions ) + action_len );
  bucket = ( struct ofp_bucket * ) xcalloc( 1, bucket_len );
  bucket->len = bucket_len;
  bucket->weight = 0x5678;
  bucket->watch_port = 0x12233445;
  bucket->watch_group = 0x56677889;
  act = ( struct ofp_action_output * ) bucket->actions;
  act->type = OFPAT_OUTPUT;
  act->len = action_len;
  act->port = 0x0708090A;
  act->max_len = 0x0B0C;

  bucket_testdata[1] = ( struct ofp_bucket * ) bucket;
  bucket_testdata_len[1] = bucket_len;
}




/********************************************************************************
 * Setup and teardown functions.
 ********************************************************************************/

static void
init() {
  init_openflow_message();
  get_logging_level = mock_get_logging_level;
}


static void
teardown() {
  init_openflow_message();
}


/********************************************************************************
 * Initialization test.
 ********************************************************************************/

static void
test_init_openflow_message() {
  bool ret;
  uint32_t transaction_id;
  pid_t pid = FAKE_PID;

  transaction_id = ( uint32_t ) ( pid << 16 ) + 1;

  ret = init_openflow_message();

  assert_true( ret );
  assert_int_equal( ( int ) get_transaction_id(), ( int ) transaction_id );
}


/********************************************************************************
 * get_transaction_id() tests.
 ********************************************************************************/

static void
test_get_transaction_id() {
  uint32_t transaction_id;
  pid_t pid = FAKE_PID;

  transaction_id = ( uint32_t ) ( pid << 16 ) + 1;

  assert_int_equal( ( int ) get_transaction_id(), ( int ) transaction_id );
}


static void
test_get_transaction_id_if_id_overflows() {
  int i;
  uint32_t transaction_id;
  pid_t pid = FAKE_PID;

  for ( i = 0; i < 0xffff; i++ ) {
    get_transaction_id();
  }

  transaction_id = ( uint32_t ) ( pid << 16 );

  assert_int_equal( ( int ) get_transaction_id(), ( int ) transaction_id );
}


/********************************************************************************
 * get_get_cookie() tests.
 ********************************************************************************/

static void
test_get_cookie() {
  pid_t pid = FAKE_PID;

  uint64_t expected_cookie = ( ( uint64_t ) pid << 48 ) + 1;
  uint64_t tmp_cookie = get_cookie();
  assert_memory_equal( &tmp_cookie, &expected_cookie, sizeof( uint64_t ) );
}


extern uint64_t cookie;

static void
test_get_cookie_if_cookie_overflows() {
  pid_t pid = FAKE_PID;
  cookie = ( ( uint64_t ) pid << 48 ) | ( UINT64_MAX >> 16 );

  uint64_t expected_cookie = ( ( uint64_t ) pid << 48 );
  uint64_t tmp_cookie = get_cookie();
  assert_memory_equal( &tmp_cookie, &expected_cookie, sizeof( uint64_t ) );
}


/********************************************************************************
 * Tests of functions for OFPT_HELLO.
 ********************************************************************************/

static void
test_create_hello() {
  buffer *buffer = create_hello( MY_TRANSACTION_ID, NULL );
  assert_true( buffer != NULL );

  struct ofp_header *hello = buffer->data;
  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_header ) );
  assert_int_equal( hello->version, OFP_VERSION );
  assert_int_equal( hello->type, OFPT_HELLO );
  assert_int_equal( ntohs( hello->length ), sizeof( struct ofp_header ) );
  assert_int_equal( ( int ) ntohl( hello->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


static void
test_validate_hello() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );
  assert_true( validate_hello( hello ) == SUCCESS );
  free_buffer( hello );
}


static void
test_validate_hello_fails_with_NULL() {
  expect_assert_failure( validate_hello( NULL ) );
}


static void
test_validate_hello_fails_with_non_hello_message() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );
  assert_int_equal( ERROR_INVALID_TYPE, validate_hello( echo_request ) );
  free_buffer( echo_request );
}


/********************************************************************************
 * Tests of a function for OFPT_ERROR.
 ********************************************************************************/

static void
test_create_error() {
  uint16_t type = OFPET_HELLO_FAILED;
  uint16_t code = OFPHFC_INCOMPATIBLE;
  buffer *data;
  buffer *buffer;
  struct ofp_error_msg *error_msg;
  uint16_t length;

  data = create_hello( MY_TRANSACTION_ID, NULL );

  buffer = create_error( MY_TRANSACTION_ID, type, code, data );
  assert_true( buffer != NULL );

  error_msg = ( struct ofp_error_msg * ) buffer->data;
  length = ( uint16_t ) ( sizeof( struct ofp_error_msg ) + data->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( error_msg->header.version, OFP_VERSION );
  assert_int_equal( error_msg->header.type, OFPT_ERROR );
  assert_int_equal( ntohs( error_msg->header.length ), length );
  assert_int_equal( ( int ) ntohl( error_msg->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( error_msg->type ), type );
  assert_int_equal( ntohs( error_msg->code ), code );
  assert_memory_equal( error_msg->data, data->data, data->length );

  free_buffer( data );
  free_buffer( buffer );
}


static void
test_create_error_without_data() {
  uint16_t type = OFPET_HELLO_FAILED;
  uint16_t code = OFPHFC_INCOMPATIBLE;
  buffer *data = NULL;
  buffer *buffer;
  struct ofp_error_msg *error_msg;
  uint16_t length;

  buffer = create_error( MY_TRANSACTION_ID, type, code, data );
  assert_true( buffer != NULL );

  error_msg = ( struct ofp_error_msg * ) buffer->data;
  length = ( uint16_t ) ( sizeof( struct ofp_error_msg ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( error_msg->header.version, OFP_VERSION );
  assert_int_equal( error_msg->header.type, OFPT_ERROR );
  assert_int_equal( ntohs( error_msg->header.length ), length );
  assert_int_equal( ( int ) ntohl( error_msg->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( error_msg->type ), type );
  assert_int_equal( ntohs( error_msg->code ), code );

  free_buffer( buffer );
}


static void
test_create_error_experimenter() {
  uint16_t type = OFPET_EXPERIMENTER;
  uint16_t exp_type = EXPERIMENTER_ERROR_TYPE;
  uint32_t experimenter = EXPERIMENTER_ID;
  buffer *data;
  buffer *buffer;
  struct ofp_error_experimenter_msg *error_msg;
  uint16_t length;

  data = create_hello( MY_TRANSACTION_ID, NULL );

  buffer = create_error_experimenter( MY_TRANSACTION_ID, type, exp_type, experimenter, data );
  assert_true( buffer != NULL );

  error_msg = ( struct ofp_error_experimenter_msg * ) buffer->data;
  length = ( uint16_t ) ( sizeof( struct ofp_error_experimenter_msg ) + data->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( error_msg->header.version, OFP_VERSION );
  assert_int_equal( error_msg->header.type, OFPT_ERROR );
  assert_int_equal( ntohs( error_msg->header.length ), length );
  assert_int_equal( ( int ) ntohl( error_msg->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( error_msg->type ), type );
  assert_int_equal( ntohs( error_msg->exp_type ), exp_type );
  assert_int_equal( ntohl( error_msg->experimenter ), experimenter );
  assert_memory_equal( error_msg->data, data->data, data->length );

  free_buffer( data );
  free_buffer( buffer );
}


static void
test_create_error_experimenter_without_data() {
  uint16_t type = OFPET_EXPERIMENTER;
  uint16_t exp_type = EXPERIMENTER_ERROR_TYPE;
  uint32_t experimenter = EXPERIMENTER_ID;
  buffer *data = NULL;
  buffer *buffer;
  struct ofp_error_experimenter_msg *error_msg;
  uint16_t length;

  buffer = create_error_experimenter( MY_TRANSACTION_ID, type, exp_type, experimenter, data );
  assert_true( buffer != NULL );

  error_msg = ( struct ofp_error_experimenter_msg * ) buffer->data;
  length = ( uint16_t ) ( sizeof( struct ofp_error_experimenter_msg ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( error_msg->header.version, OFP_VERSION );
  assert_int_equal( error_msg->header.type, OFPT_ERROR );
  assert_int_equal( ntohs( error_msg->header.length ), length );
  assert_int_equal( ( int ) ntohl( error_msg->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( error_msg->type ), type );
  assert_int_equal( ntohs( error_msg->exp_type ), exp_type );
  assert_int_equal( ntohl( error_msg->experimenter ), experimenter );

  free_buffer( buffer );
}


/********************************************************************************
 * Tests of functions for OFPT_ECHO_REQUEST.
 ********************************************************************************/

static void
test_create_echo_request() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *buffer = create_echo_request( MY_TRANSACTION_ID, body );
  assert_true( buffer != NULL );

  struct ofp_header *echo_request = buffer->data;
  uint16_t length = ( uint16_t ) ( sizeof( struct ofp_header ) + body->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( echo_request->version, OFP_VERSION );
  assert_int_equal( echo_request->type, OFPT_ECHO_REQUEST );
  assert_int_equal( ntohs( echo_request->length ), length );
  assert_int_equal( ( int ) ntohl( echo_request->xid ), ( int ) MY_TRANSACTION_ID );

  assert_memory_equal( ( char * ) buffer->data + sizeof( struct ofp_header ), body->data, body->length );

  free_buffer( body );
  free_buffer( buffer );
}


static void
test_create_echo_request_without_data() {
  buffer *buffer = create_echo_request( MY_TRANSACTION_ID, NULL );
  assert_true( buffer != NULL );

  struct ofp_header *echo_request = buffer->data;
  uint16_t length = ( uint16_t ) sizeof( struct ofp_header );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( echo_request->version, OFP_VERSION );
  assert_int_equal( echo_request->type, OFPT_ECHO_REQUEST );
  assert_int_equal( ntohs( echo_request->length ), length );
  assert_int_equal( ( int ) ntohl( echo_request->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


static void
test_validate_echo_request() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, body );

  assert_true( validate_echo_request( echo_request ) == SUCCESS );

  free_buffer( body );
  free_buffer( echo_request );
}


static void
test_validate_echo_request_fails_with_NULL() {
  expect_assert_failure( validate_echo_request( NULL ) );
}


static void
test_validate_echo_request_fails_with_non_echo_request_message() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_echo_request( hello ), ERROR_INVALID_TYPE );

  free_buffer( hello );
}


/********************************************************************************
 * Tests of functions for OFPT_ECHO_REPLY.
 ********************************************************************************/

static void
test_create_echo_reply() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *buffer = create_echo_reply( MY_TRANSACTION_ID, body );
  assert_true( buffer != NULL );

  struct ofp_header *echo_reply = ( struct ofp_header * ) buffer->data;
  uint16_t length = ( uint16_t ) ( sizeof( struct ofp_header ) + body->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( echo_reply->version, OFP_VERSION );
  assert_int_equal( echo_reply->type, OFPT_ECHO_REPLY );
  assert_int_equal( ntohs( echo_reply->length ), length );
  assert_int_equal( ( int ) ntohl( echo_reply->xid ), ( int ) MY_TRANSACTION_ID );

  assert_memory_equal( ( char * ) buffer->data + sizeof( struct ofp_header ), body->data, body->length );

  free_buffer( body );
  free_buffer( buffer );
}


static void
test_create_echo_reply_without_data() {
  buffer *buffer = create_echo_reply( MY_TRANSACTION_ID, NULL );
  assert_true( buffer != NULL );

  struct ofp_header *echo_reply = ( struct ofp_header * ) buffer->data;
  uint16_t length = ( uint16_t ) sizeof( struct ofp_header );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( echo_reply->version, OFP_VERSION );
  assert_int_equal( echo_reply->type, OFPT_ECHO_REPLY );
  assert_int_equal( ntohs( echo_reply->length ), length );
  assert_int_equal( ( int ) ntohl( echo_reply->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


static void
test_validate_echo_reply() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *echo_reply = create_echo_reply( MY_TRANSACTION_ID, body );

  assert_true( validate_echo_reply( echo_reply ) == SUCCESS );

  free_buffer( body );
  free_buffer( echo_reply );
}


static void
test_validate_echo_reply_fails_with_NULL() {
  expect_assert_failure( validate_echo_reply( NULL ) );
}


static void
test_validate_echo_reply_fails_with_non_echo_reply_message() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_echo_reply( hello ), ERROR_INVALID_TYPE );

  free_buffer( hello );
}


/********************************************************************************
 * Tests of a function for OFPT_EXPERIMENTER.
 ********************************************************************************/

static void
test_create_experimenter() {
  const uint16_t body_length = 128;

  buffer *body = create_dummy_data( body_length );
  buffer *buffer = create_experimenter( MY_TRANSACTION_ID, EXPERIMENTER_ID, EXPERIMENTER_TYPE, body );
  assert_true( buffer != NULL );

  assert_int_equal( ( int ) buffer->length,
                    ( int ) sizeof( struct ofp_experimenter_header ) + body_length );

  struct ofp_experimenter_header *experimenter = buffer->data;

  assert_int_equal( experimenter->header.version, OFP_VERSION );
  assert_int_equal( experimenter->header.type, OFPT_EXPERIMENTER );
  assert_int_equal( ( int ) ntohs( experimenter->header.length ),
                    ( int ) sizeof( struct ofp_experimenter_header ) + body_length );
  assert_int_equal( ( int ) ntohl( experimenter->header.xid ),
                    ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( experimenter->experimenter ), ( int ) EXPERIMENTER_ID );
  assert_int_equal( ( int ) ntohl( experimenter->exp_type ), ( int ) EXPERIMENTER_TYPE );
  assert_memory_equal( ( char * ) experimenter + sizeof( struct ofp_experimenter_header ),
                       body->data,
                       body_length );

  free_buffer( body );
  free_buffer( buffer );
}


static void
test_create_experimenter_without_data() {
  buffer *buffer = create_experimenter( MY_TRANSACTION_ID, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );
  assert_true( buffer != NULL );

  assert_int_equal( ( int ) buffer->length,
                    sizeof( struct ofp_experimenter_header ) );

  struct ofp_experimenter_header *experimenter = buffer->data;

  assert_int_equal( experimenter->header.version, OFP_VERSION );
  assert_int_equal( experimenter->header.type, OFPT_EXPERIMENTER );
  assert_int_equal( ( int ) ntohs( experimenter->header.length ),
                    sizeof( struct ofp_experimenter_header ) );
  assert_int_equal( ( int ) ntohl( experimenter->header.xid ),
                    ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( experimenter->experimenter ), ( int ) EXPERIMENTER_ID );
  assert_int_equal( ( int ) ntohl( experimenter->exp_type ), ( int ) EXPERIMENTER_TYPE );

  free_buffer( buffer );
}


/********************************************************************************
 * Tests of functions for OFPT_FEATURES_REQUEST.
 ********************************************************************************/

static void
test_create_features_request() {
  buffer *buffer = create_features_request( MY_TRANSACTION_ID );
  assert_true( buffer != NULL );

  struct ofp_header *features_request = ( struct ofp_header * ) buffer->data;
  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_header ) );
  assert_int_equal( features_request->version, OFP_VERSION );
  assert_int_equal( features_request->type, OFPT_FEATURES_REQUEST );
  assert_int_equal( ntohs( features_request->length ), sizeof( struct ofp_header ) );
  assert_int_equal( ( int ) ntohl( features_request->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


static void
test_validate_features_request() {
  buffer *features_request = create_features_request( MY_TRANSACTION_ID );
  assert_true( validate_features_request( features_request ) == SUCCESS );
  free_buffer( features_request );
}


static void
test_validate_features_request_fails_with_NULL() {
  expect_assert_failure( validate_features_request( NULL ) );
}


static void
test_validate_features_request_fails_with_non_features_request_message() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );
  assert_int_equal( validate_features_request( hello ), ERROR_INVALID_TYPE );
  free_buffer( hello );
}


/********************************************************************************
 * Tests of functions for OFPT_FEATURES_REPLY.
 ********************************************************************************/

static void
test_create_features_reply() {
  uint64_t datapath_id = 0x12345600;
  uint32_t n_buffers = 128;
  uint8_t n_tables = 1;
  uint8_t auxiliary_id = 0x13;
  uint32_t capabilities = ( OFPC_FLOW_STATS | OFPC_TABLE_STATS | OFPC_PORT_STATS |
                            OFPC_GROUP_STATS | OFPC_IP_REASM | OFPC_QUEUE_STATS |
                            OFPC_PORT_BLOCKED );
  uint64_t tmp;

  buffer *buffer = create_features_reply( MY_TRANSACTION_ID, datapath_id, n_buffers,
                                          n_tables, auxiliary_id, capabilities );
  assert_true( buffer != NULL );

  struct ofp_switch_features *features_reply = ( struct ofp_switch_features * ) buffer->data;
  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_switch_features ) );
  assert_int_equal( features_reply->header.version, OFP_VERSION );
  assert_int_equal( features_reply->header.type, OFPT_FEATURES_REPLY );
  assert_int_equal( ntohs( features_reply->header.length ), sizeof( struct ofp_switch_features ) );
  assert_int_equal( ( int ) ntohl( features_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  tmp = ntohll( features_reply->datapath_id );
  assert_memory_equal( &tmp, &datapath_id, sizeof( datapath_id ) );
  assert_int_equal( ntohl( features_reply->n_buffers ), n_buffers );
  assert_int_equal( features_reply->n_tables, n_tables );
  assert_int_equal( features_reply->auxiliary_id, auxiliary_id );

  {
    void *pad = xmalloc( sizeof( features_reply->pad ) );
    memset( pad, 0, sizeof( features_reply->pad ) );
    assert_memory_equal( features_reply->pad, pad, sizeof( features_reply->pad ) );
    xfree( pad );
  }

  assert_int_equal( ntohl( features_reply->capabilities ), capabilities );
  assert_int_equal( ntohl( features_reply->reserved ), 0 );

  free_buffer( buffer );
}


/********************************************************************************
 * Test of a function for OFPT_GET_CONFIG_REQUEST.
 ********************************************************************************/

static void
test_create_get_config_request() {
  buffer *buffer;
  struct ofp_header *get_config_request;

  buffer = create_get_config_request( MY_TRANSACTION_ID );
  assert_true( buffer != NULL );

  get_config_request = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_header ) );
  assert_int_equal( get_config_request->version, OFP_VERSION );
  assert_int_equal( get_config_request->type, OFPT_GET_CONFIG_REQUEST );
  assert_int_equal( ntohs( get_config_request->length ), sizeof( struct ofp_header ) );
  assert_int_equal( ( int ) ntohl( get_config_request->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


/********************************************************************************
 * Test of a function for OFPT_GET_CONFIG_REPLY.
 ********************************************************************************/

static void
test_create_get_config_reply() {
  uint16_t flags = OFPC_FRAG_NORMAL;
  uint16_t miss_send_len = OFP_DEFAULT_MISS_SEND_LEN;
  buffer *buffer;
  struct ofp_switch_config *switch_config;

  buffer = create_get_config_reply( MY_TRANSACTION_ID, flags, miss_send_len );
  assert_true( buffer != NULL );

  switch_config = ( struct ofp_switch_config * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_switch_config ) );
  assert_int_equal( switch_config->header.version, OFP_VERSION );
  assert_int_equal( switch_config->header.type, OFPT_GET_CONFIG_REPLY );
  assert_int_equal( ntohs( switch_config->header.length ), sizeof( struct ofp_switch_config ) );
  assert_int_equal( ( int ) ntohl( switch_config->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( switch_config->flags ), flags );
  assert_int_equal( ntohs( switch_config->miss_send_len ), miss_send_len );

  free_buffer( buffer );
}


/********************************************************************************
 * Tests of functions for OFPT_SET_CONFIG.
 ********************************************************************************/

static void
test_create_set_config() {
  buffer *buffer = create_set_config( MY_TRANSACTION_ID, OFPC_FRAG_NORMAL, OFP_DEFAULT_MISS_SEND_LEN );
  assert_true( buffer != NULL );

  struct ofp_switch_config *switch_config = buffer->data;
  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_switch_config ) );
  assert_int_equal( switch_config->header.version, OFP_VERSION );
  assert_int_equal( switch_config->header.type, OFPT_SET_CONFIG );
  assert_int_equal( ntohs( switch_config->header.length ), sizeof( struct ofp_switch_config ) );
  assert_int_equal( ( int ) ntohl( switch_config->header.xid ), ( int ) MY_TRANSACTION_ID );
  assert_int_equal( ntohs( switch_config->flags ), OFPC_FRAG_NORMAL );
  assert_int_equal( ntohs( switch_config->miss_send_len ), OFP_DEFAULT_MISS_SEND_LEN );

  free_buffer( buffer );
}


static void
test_validate_set_config() {
  buffer *set_config = create_set_config( MY_TRANSACTION_ID, OFPC_FRAG_NORMAL, OFP_DEFAULT_MISS_SEND_LEN );
  assert_true( validate_set_config( set_config ) == SUCCESS );
  free_buffer( set_config );
}


static void
test_validate_set_config_fails_with_NULL() {
  expect_assert_failure( validate_set_config( NULL ) );
}


static void
test_validate_set_config_fails_with_non_set_config_message() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );
  assert_int_equal( validate_set_config( hello ), ERROR_INVALID_TYPE );
  free_buffer( hello );
}


/********************************************************************************
 * Test of a function for OFPT_PACKET_IN.
 ********************************************************************************/

static void
test_create_packet_in() {
  uint16_t total_len = 0x1122;
  uint8_t reason = OFPR_NO_MATCH;
  uint8_t table_id = 0x12;
  uint64_t cookie = 0x6543210987654321;
  buffer *expected_data;
  buffer *buffer;
  oxm_match_header *oxm1, *oxm2;
  oxm_matches *match;
  struct ofp_packet_in *packet_in;
  uint64_t tmp;
  uint16_t expected_length;

  // with match
  {
    expected_data = create_dummy_data( SHORT_DATA_LENGTH );

    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );

    buffer = create_packet_in( MY_TRANSACTION_ID, BUFFER_ID, total_len, reason, table_id, cookie, match, expected_data );
    assert_true( buffer != NULL );

    packet_in = buffer->data;

    expected_length = ( uint16_t ) ( offsetof( struct ofp_packet_in, match ) + expected_ofp_match_len + expected_data->length );

    assert_int_equal( ( int ) buffer->length, expected_length );
    assert_int_equal( packet_in->header.version, OFP_VERSION );
    assert_int_equal( packet_in->header.type, OFPT_PACKET_IN );
    assert_int_equal( ntohs( packet_in->header.length ), expected_length );
    assert_int_equal( ( int ) ntohl( packet_in->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ( int ) ntohl( packet_in->buffer_id ), ( int ) BUFFER_ID );
    assert_int_equal( ( int ) ntohs( packet_in->total_len ), ( int ) total_len );
    assert_int_equal( ( int ) packet_in->reason, reason );
    assert_int_equal( ( int ) packet_in->table_id, table_id );
    tmp = ntohll( packet_in->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );

    ntoh_match( &packet_in->match, &packet_in->match );
    assert_memory_equal( &packet_in->match, expected_ofp_match, expected_ofp_match_len );

    void *d = ( void * ) ( ( char * ) buffer->data + offsetof( struct ofp_packet_in, match ) + expected_ofp_match_len );
    assert_memory_equal( d, expected_data->data, expected_data->length );

    delete_oxm_match_testdata();
    delete_oxm_matches( match );
    free_buffer( expected_data );
    free_buffer( buffer );
  }

  // without match
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    expected_data = create_dummy_data( SHORT_DATA_LENGTH );

    expected_empty_ofp_match_len = sizeof( struct ofp_match );
    expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
    expected_empty_ofp_match->type = OFPMT_OXM;
    expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );

    buffer = create_packet_in( MY_TRANSACTION_ID, BUFFER_ID, total_len, reason, table_id, cookie, NULL, expected_data );
    assert_true( buffer != NULL );

    packet_in = buffer->data;

    expected_length = ( uint16_t ) ( offsetof( struct ofp_packet_in, match ) + expected_empty_ofp_match_len + expected_data->length );

    assert_int_equal( ( int ) buffer->length, expected_length );
    assert_int_equal( packet_in->header.version, OFP_VERSION );
    assert_int_equal( packet_in->header.type, OFPT_PACKET_IN );
    assert_int_equal( ntohs( packet_in->header.length ), expected_length );
    assert_int_equal( ( int ) ntohl( packet_in->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ( int ) ntohl( packet_in->buffer_id ), ( int ) BUFFER_ID );
    assert_int_equal( ( int ) ntohs( packet_in->total_len ), ( int ) total_len );
    assert_int_equal( ( int ) packet_in->reason, reason );
    assert_int_equal( ( int ) packet_in->table_id, table_id );
    tmp = ntohll( packet_in->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );

    ntoh_match( &packet_in->match, &packet_in->match );
    assert_memory_equal( &packet_in->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    void *d = ( void * ) ( ( char * ) buffer->data + offsetof( struct ofp_packet_in, match ) + expected_empty_ofp_match_len );
    assert_memory_equal( d, expected_data->data, expected_data->length );

    xfree( expected_empty_ofp_match );
    free_buffer( expected_data );
    free_buffer( buffer );
  }
}


/********************************************************************************
 * Test of a function for OFPT_FLOW_REMOVED.
 ********************************************************************************/

static void
test_create_flow_removed() {
  uint64_t cookie = 0x0102030405060708ULL;
  uint8_t reason = OFPRR_IDLE_TIMEOUT;
  uint8_t table_id = 0x12;
  uint32_t duration_sec = 180;
  uint32_t duration_nsec = 10000;
  uint16_t idle_timeout = 60;
  uint16_t hard_timeout = 120;
  uint64_t packet_count = 1000;
  uint64_t byte_count = 100000;
  buffer *buffer;
  oxm_match_header *oxm1, *oxm2;
  oxm_matches *match;
  struct ofp_flow_removed *flow_removed;
  uint64_t tmp;
  uint16_t expected_msglen;

  // witch match
  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );

    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_flow_removed, match ) + expected_ofp_match_len );

    buffer = create_flow_removed( MY_TRANSACTION_ID, cookie, PRIORITY, reason, table_id, duration_sec,
                                  duration_nsec, idle_timeout, hard_timeout, packet_count, byte_count, match );
    assert_true( buffer != NULL );

    flow_removed = buffer->data;

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( flow_removed->header.version, OFP_VERSION );
    assert_int_equal( flow_removed->header.type, OFPT_FLOW_REMOVED );
    assert_int_equal( ntohs( flow_removed->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( flow_removed->header.xid ), ( int ) MY_TRANSACTION_ID );

    tmp = ntohll( flow_removed->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    assert_int_equal( ntohs( flow_removed->priority ), PRIORITY );
    assert_int_equal( flow_removed->reason, reason );
    assert_int_equal( flow_removed->table_id, table_id );
    assert_int_equal( ( int ) ntohl( flow_removed->duration_sec ), ( int ) duration_sec );
    assert_int_equal( ( int ) ntohl( flow_removed->duration_nsec ), ( int ) duration_nsec );
    assert_int_equal( ntohs( flow_removed->idle_timeout ), idle_timeout );
    assert_int_equal( ntohs( flow_removed->hard_timeout ), hard_timeout );
    tmp = ntohll( flow_removed->packet_count );
    assert_memory_equal( &tmp, &packet_count, sizeof( packet_count ) );
    tmp = ntohll( flow_removed->byte_count );
    assert_memory_equal( &tmp, &byte_count, sizeof( byte_count ) );

    ntoh_match( &flow_removed->match, &flow_removed->match );
    assert_memory_equal( &flow_removed->match, expected_ofp_match, expected_ofp_match_len );

    delete_oxm_match_testdata();
    delete_oxm_matches( match );
    free_buffer( buffer );
  }

  // witchout match
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    expected_empty_ofp_match_len = sizeof( struct ofp_match );
    expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
    expected_empty_ofp_match->type = OFPMT_OXM;
    expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );

    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_flow_removed, match ) + expected_empty_ofp_match_len );

    buffer = create_flow_removed( MY_TRANSACTION_ID, cookie, PRIORITY, reason, table_id, duration_sec,
                                  duration_nsec, idle_timeout, hard_timeout, packet_count, byte_count, NULL );
    assert_true( buffer != NULL );

    flow_removed = buffer->data;

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( flow_removed->header.version, OFP_VERSION );
    assert_int_equal( flow_removed->header.type, OFPT_FLOW_REMOVED );
    assert_int_equal( ntohs( flow_removed->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( flow_removed->header.xid ), ( int ) MY_TRANSACTION_ID );

    tmp = ntohll( flow_removed->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    assert_int_equal( ntohs( flow_removed->priority ), PRIORITY );
    assert_int_equal( flow_removed->reason, reason );
    assert_int_equal( flow_removed->table_id, table_id );
    assert_int_equal( ( int ) ntohl( flow_removed->duration_sec ), ( int ) duration_sec );
    assert_int_equal( ( int ) ntohl( flow_removed->duration_nsec ), ( int ) duration_nsec );
    assert_int_equal( ntohs( flow_removed->idle_timeout ), idle_timeout );
    assert_int_equal( ntohs( flow_removed->hard_timeout ), hard_timeout );
    tmp = ntohll( flow_removed->packet_count );
    assert_memory_equal( &tmp, &packet_count, sizeof( packet_count ) );
    tmp = ntohll( flow_removed->byte_count );
    assert_memory_equal( &tmp, &byte_count, sizeof( byte_count ) );

    ntoh_match( &flow_removed->match, &flow_removed->match );
    assert_memory_equal( &flow_removed->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    xfree( expected_empty_ofp_match );
    free_buffer( buffer );
  }
}


/********************************************************************************
 * Test of a function for OFPT_PORT_STATUS.
 ********************************************************************************/

static void
test_create_port_status() {
  uint8_t reason = OFPPR_ADD;
  buffer *buffer;
  struct ofp_port_status *port_status;

  create_port_desc_testdata();

  buffer = create_port_status( MY_TRANSACTION_ID, reason, *port_desc_testdata[0] );
  assert_true( buffer != NULL );

  port_status = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_port_status ) );
  assert_int_equal( port_status->header.version, OFP_VERSION );
  assert_int_equal( port_status->header.type, OFPT_PORT_STATUS );
  assert_int_equal( ntohs( port_status->header.length ), sizeof( struct ofp_port_status ) );
  assert_int_equal( ( int ) ntohl( port_status->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( port_status->reason, reason );
  {
    void *pad = xmalloc( sizeof( port_status->pad ) );
    memset( pad, 0, sizeof( port_status->pad ) );
    assert_memory_equal( port_status->pad, pad, sizeof( port_status->pad ) );
    xfree( pad );
  }
  {
    struct ofp_port d;
    ntoh_port( &d, &port_status->desc );
    assert_memory_equal( &d, port_desc_testdata[0], sizeof( struct ofp_port ) );
  }

  delete_port_desc_testdata();

  free_buffer( buffer );
}


/********************************************************************************
 * Test of a function for OFPT_GROUP_MOD.
 ********************************************************************************/

static void
test_create_group_mod() {
  uint16_t command = OFPGC_ADD;
  uint8_t type = OFPGT_SELECT;
  uint32_t group_id = 0x10023004;
  buffer *buffer;
  list_element *list;
  openflow_buckets *expected_list;
  struct ofp_bucket *bkt1, *bkt2;
  struct ofp_group_mod *group_mod;
  uint16_t expected_msglen;

  create_bucket_testdata();

  bkt1 = xcalloc( 1, bucket_testdata_len[0] );
  memcpy( bkt1, bucket_testdata[0], bucket_testdata_len[0] );
  bkt2 = xcalloc( 1, bucket_testdata_len[1] );
  memcpy( bkt2, bucket_testdata[1], bucket_testdata_len[1] );

  expected_list = create_buckets();
  append_to_tail( &expected_list->list, bkt1 );
  append_to_tail( &expected_list->list, bkt2 );
  expected_list->n_buckets = 2;

  expected_msglen = ( uint16_t ) ( offsetof( struct ofp_group_mod, buckets )
                                  + bucket_testdata_len[0]
                                  + bucket_testdata_len[1] );

  buffer = create_group_mod( MY_TRANSACTION_ID, command, type, group_id, expected_list );
  assert_true( buffer != NULL );

  group_mod = buffer->data;

  assert_int_equal( ( int ) buffer->length, expected_msglen );
  assert_int_equal( group_mod->header.version, OFP_VERSION );
  assert_int_equal( group_mod->header.type, OFPT_GROUP_MOD );
  assert_int_equal( ntohs( group_mod->header.length ), expected_msglen );
  assert_int_equal( ( int ) ntohl( group_mod->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( group_mod->command ), command );
  assert_int_equal( group_mod->type, type );
  assert_int_equal( group_mod->pad, 0 );
  assert_int_equal( ( int ) ntohl( group_mod->group_id ), ( int ) group_id );

  struct ofp_bucket *buckets = group_mod->buckets;
  struct ofp_bucket *next;

  list = expected_list->list;
  while ( list != NULL ) {
    struct ofp_bucket *expected_bucket = ( struct ofp_bucket * ) list->data;

    next = ( struct ofp_bucket * ) ( ( char * ) buckets + expected_bucket->len );
    ntoh_bucket( buckets, buckets );

    assert_memory_equal( buckets, expected_bucket, expected_bucket->len );

    buckets = next;
    list = list->next;
  }

  delete_bucket_testdata();
  delete_buckets( expected_list );
  free_buffer( buffer );
}


/********************************************************************************
 * Test of a function for OFPT_PORT_MOD.
 ********************************************************************************/

static void
test_create_port_mod() {
  uint32_t port_no = 1;
  uint32_t config = OFPPC_PORT_DOWN;
  uint32_t mask = 0xffffffff;
  uint32_t advertise = 1;
  buffer *buffer;
  struct ofp_port_mod *port_mod;

  buffer = create_port_mod( MY_TRANSACTION_ID, port_no, HW_ADDR, config, mask, advertise );
  assert_true( buffer != NULL );

  port_mod = ( struct ofp_port_mod * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_port_mod ) );
  assert_int_equal( port_mod->header.version, OFP_VERSION );
  assert_int_equal( port_mod->header.type, OFPT_PORT_MOD );
  assert_int_equal( ntohs( port_mod->header.length ), sizeof( struct ofp_port_mod ) );
  assert_int_equal( ( int ) ntohl( port_mod->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohl( port_mod->port_no ), port_no );
  {
    void *pad = xmalloc( sizeof( port_mod->pad ) );
    memset( pad, 0, sizeof( port_mod->pad ) );
    assert_memory_equal( port_mod->pad, pad, sizeof( port_mod->pad ) );
    xfree( pad );
  }
  assert_memory_equal( port_mod->hw_addr, HW_ADDR, sizeof( HW_ADDR ) );
  {
    void *pad2 = xmalloc( sizeof( port_mod->pad2 ) );
    memset( pad2, 0, sizeof( port_mod->pad2 ) );
    assert_memory_equal( port_mod->pad2, pad2, sizeof( port_mod->pad2 ) );
    xfree( pad2 );
  }
  assert_int_equal( ( int ) ntohl( port_mod->config ), ( int ) config );
  assert_int_equal( ( int ) ntohl( port_mod->mask ), ( int ) mask );
  assert_int_equal( ( int ) ntohl( port_mod->advertise ), ( int ) advertise );

  {
    void *pad3 = xmalloc( sizeof( port_mod->pad3 ) );
    memset( pad3, 0, sizeof( port_mod->pad3 ) );
    assert_memory_equal( port_mod->pad3, pad3, sizeof( port_mod->pad3 ) );
    xfree( pad3 );
  }

  free_buffer( buffer );
}


/********************************************************************************
 * Test of a function for OFPT_TABLE_MOD.
 ********************************************************************************/

static void
test_create_table_mod() {
  uint8_t table_id = 0x12;
  uint32_t config = 0x12345678;
  buffer *buffer;
  struct ofp_table_mod *table_mod;

  buffer = create_table_mod( MY_TRANSACTION_ID, table_id, config );
  assert_true( buffer != NULL );

  table_mod = ( struct ofp_table_mod * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_table_mod ) );
  assert_int_equal( table_mod->header.version, OFP_VERSION );
  assert_int_equal( table_mod->header.type, OFPT_TABLE_MOD );
  assert_int_equal( ntohs( table_mod->header.length ), sizeof( struct ofp_table_mod ) );
  assert_int_equal( ( int ) ntohl( table_mod->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( table_mod->table_id, table_id );
  {
    void *pad = xmalloc( sizeof( table_mod->pad ) );
    memset( pad, 0, sizeof( table_mod->pad ) );
    assert_memory_equal( table_mod->pad, pad, sizeof( table_mod->pad ) );
    xfree( pad );
  }
  assert_int_equal( ntohl( table_mod->config ), config );

  free_buffer( buffer );
}


/********************************************************************************
 * Test of functions for creating/deleting actions.
 ********************************************************************************/

static void
test_create_and_delete_actions() {
  openflow_actions *actions = create_actions();
  bool ret;

  assert_true( actions != NULL );
  assert_int_equal( actions->n_actions, 0 );

  ret = delete_actions( actions );
  assert_true( ret );

  actions = NULL;
  expect_assert_failure( delete_actions( NULL ) );
}


/********************************************************************************
 * append_action_output() test.
 ********************************************************************************/

static void
test_append_action_output() {
  openflow_actions *actions = NULL;
  uint32_t port = 1;
  uint16_t max_len = 128;
  struct ofp_action_output *action_output;
  bool ret;

  expect_assert_failure( append_action_output( actions, port, max_len ) );

  actions = create_actions();

  ret = append_action_output( actions, port, max_len );
  assert_true( ret );

  action_output = actions->list->data;

  assert_int_equal( action_output->type, OFPAT_OUTPUT );
  assert_int_equal( action_output->len, sizeof( struct ofp_action_output ) );
  assert_int_equal( action_output->port, port );
  assert_int_equal( action_output->max_len, max_len );
  {
    void *pad = xmalloc( sizeof( action_output->pad ) );
    memset( pad, 0, sizeof( action_output->pad ) );
    assert_memory_equal( action_output->pad, pad, sizeof( action_output->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_set_queue() test.
 ********************************************************************************/

static void
test_append_action_set_queue() {
  openflow_actions *actions = NULL;
  uint32_t queue_id = 10;
  struct ofp_action_set_queue *action_set_queue;
  bool ret;

  expect_assert_failure( append_action_set_queue( actions, queue_id ) );

  actions = create_actions();

  ret = append_action_set_queue( actions, queue_id );
  assert_true( ret );

  action_set_queue = actions->list->data;

  assert_int_equal( action_set_queue->type, OFPAT_SET_QUEUE );
  assert_int_equal( action_set_queue->len, sizeof( struct ofp_action_set_queue ) );
  assert_int_equal( ( int ) action_set_queue->queue_id, ( int ) queue_id );

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_copy_ttl_out() test.
 ********************************************************************************/

static void
test_append_action_copy_ttl_out() {
  openflow_actions *actions = NULL;
  struct ofp_action_header *action_copy_ttl_out;
  bool ret;

  expect_assert_failure( append_action_copy_ttl_out( actions ) );

  actions = create_actions();

  ret = append_action_copy_ttl_out( actions );
  assert_true( ret );

  action_copy_ttl_out = actions->list->data;

  assert_int_equal( action_copy_ttl_out->type, OFPAT_COPY_TTL_OUT );
  assert_int_equal( action_copy_ttl_out->len, sizeof( struct ofp_action_header ) );
  {
    void *pad = xmalloc( sizeof( action_copy_ttl_out->pad ) );
    memset( pad, 0, sizeof( action_copy_ttl_out->pad ) );
    assert_memory_equal( action_copy_ttl_out->pad, pad, sizeof( action_copy_ttl_out->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_copy_ttl_in() test.
 ********************************************************************************/

static void
test_append_action_copy_ttl_in() {
  openflow_actions *actions = NULL;
  struct ofp_action_header *action_copy_ttl_in;
  bool ret;

  expect_assert_failure( append_action_copy_ttl_in( actions ) );

  actions = create_actions();

  ret = append_action_copy_ttl_in( actions );
  assert_true( ret );

  action_copy_ttl_in = actions->list->data;

  assert_int_equal( action_copy_ttl_in->type, OFPAT_COPY_TTL_IN );
  assert_int_equal( action_copy_ttl_in->len, sizeof( struct ofp_action_header ) );
  {
    void *pad = xmalloc( sizeof( action_copy_ttl_in->pad ) );
    memset( pad, 0, sizeof( action_copy_ttl_in->pad ) );
    assert_memory_equal( action_copy_ttl_in->pad, pad, sizeof( action_copy_ttl_in->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_set_mpls_ttl() test.
 ********************************************************************************/

static void
test_append_action_set_mpls_ttl() {
  openflow_actions *actions = NULL;
  uint8_t mpls_ttl = 0x12;
  struct ofp_action_mpls_ttl *action_set_mpls_ttl;
  bool ret;

  expect_assert_failure( append_action_set_mpls_ttl( actions, mpls_ttl ) );

  actions = create_actions();

  ret = append_action_set_mpls_ttl( actions, mpls_ttl );
  assert_true( ret );

  action_set_mpls_ttl = actions->list->data;

  assert_int_equal( action_set_mpls_ttl->type, OFPAT_SET_MPLS_TTL );
  assert_int_equal( action_set_mpls_ttl->len, sizeof( struct ofp_action_mpls_ttl ) );
  assert_int_equal( action_set_mpls_ttl->mpls_ttl, mpls_ttl );
  {
    void *pad = xmalloc( sizeof( action_set_mpls_ttl->pad ) );
    memset( pad, 0, sizeof( action_set_mpls_ttl->pad ) );
    assert_memory_equal( action_set_mpls_ttl->pad, pad, sizeof( action_set_mpls_ttl->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_dec_mpls_ttl() test.
 ********************************************************************************/

static void
test_append_action_dec_mpls_ttl() {
  openflow_actions *actions = NULL;
  struct ofp_action_header *action_dec_mpls_ttl;
  bool ret;

  expect_assert_failure( append_action_dec_mpls_ttl( actions ) );

  actions = create_actions();

  ret = append_action_dec_mpls_ttl( actions );
  assert_true( ret );

  action_dec_mpls_ttl = actions->list->data;

  assert_int_equal( action_dec_mpls_ttl->type, OFPAT_DEC_MPLS_TTL );
  assert_int_equal( action_dec_mpls_ttl->len, sizeof( struct ofp_action_header ) );
  {
    void *pad = xmalloc( sizeof( action_dec_mpls_ttl->pad ) );
    memset( pad, 0, sizeof( action_dec_mpls_ttl->pad ) );
    assert_memory_equal( action_dec_mpls_ttl->pad, pad, sizeof( action_dec_mpls_ttl->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_push_vlan() test.
 ********************************************************************************/

static void
test_append_action_push_vlan() {
  openflow_actions *actions = NULL;
  uint16_t ethertype = 0x1234;
  struct ofp_action_push *action_push_vlan;
  bool ret;

  expect_assert_failure( append_action_push_vlan( actions, ethertype ) );

  actions = create_actions();

  ret = append_action_push_vlan( actions, ethertype );
  assert_true( ret );

  action_push_vlan = actions->list->data;

  assert_int_equal( action_push_vlan->type, OFPAT_PUSH_VLAN );
  assert_int_equal( action_push_vlan->len, sizeof( struct ofp_action_push ) );
  assert_int_equal( action_push_vlan->ethertype, ethertype );
  {
    void *pad = xmalloc( sizeof( action_push_vlan->pad ) );
    memset( pad, 0, sizeof( action_push_vlan->pad ) );
    assert_memory_equal( action_push_vlan->pad, pad, sizeof( action_push_vlan->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_pop_vlan() test.
 ********************************************************************************/

static void
test_append_action_pop_vlan() {
  openflow_actions *actions = NULL;
  struct ofp_action_header *action_pop_vlan;
  bool ret;

  expect_assert_failure( append_action_pop_vlan( actions ) );

  actions = create_actions();

  ret = append_action_pop_vlan( actions );
  assert_true( ret );

  action_pop_vlan = actions->list->data;

  assert_int_equal( action_pop_vlan->type, OFPAT_POP_VLAN );
  assert_int_equal( action_pop_vlan->len, sizeof( struct ofp_action_header ) );
  {
    void *pad = xmalloc( sizeof( action_pop_vlan->pad ) );
    memset( pad, 0, sizeof( action_pop_vlan->pad ) );
    assert_memory_equal( action_pop_vlan->pad, pad, sizeof( action_pop_vlan->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_push_mpls() test.
 ********************************************************************************/

static void
test_append_action_push_mpls() {
  openflow_actions *actions = NULL;
  uint16_t ethertype = 0x1234;
  struct ofp_action_push *action_push_mpls;
  bool ret;

  expect_assert_failure( append_action_push_mpls( actions, ethertype ) );

  actions = create_actions();

  ret = append_action_push_mpls( actions, ethertype );
  assert_true( ret );

  action_push_mpls = actions->list->data;

  assert_int_equal( action_push_mpls->type, OFPAT_PUSH_MPLS );
  assert_int_equal( action_push_mpls->len, sizeof( struct ofp_action_push ) );
  assert_int_equal( action_push_mpls->ethertype, ethertype );
  {
    void *pad = xmalloc( sizeof( action_push_mpls->pad ) );
    memset( pad, 0, sizeof( action_push_mpls->pad ) );
    assert_memory_equal( action_push_mpls->pad, pad, sizeof( action_push_mpls->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_pop_mpls() test.
 ********************************************************************************/

static void
test_append_action_pop_mpls() {
  openflow_actions *actions = NULL;
  uint16_t ethertype = 0x1234;
  struct ofp_action_pop_mpls *action_pop_mpls;
  bool ret;

  expect_assert_failure( append_action_pop_mpls( actions, ethertype ) );

  actions = create_actions();

  ret = append_action_pop_mpls( actions, ethertype );
  assert_true( ret );

  action_pop_mpls = actions->list->data;

  assert_int_equal( action_pop_mpls->type, OFPAT_POP_MPLS );
  assert_int_equal( action_pop_mpls->len, sizeof( struct ofp_action_pop_mpls ) );
  assert_int_equal( action_pop_mpls->ethertype, ethertype );
  {
    void *pad = xmalloc( sizeof( action_pop_mpls->pad ) );
    memset( pad, 0, sizeof( action_pop_mpls->pad ) );
    assert_memory_equal( action_pop_mpls->pad, pad, sizeof( action_pop_mpls->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_group() test.
 ********************************************************************************/

static void
test_append_action_group() {
  openflow_actions *actions = NULL;
  uint32_t group_id = 0x12345678;
  struct ofp_action_group *action_group;
  bool ret;

  expect_assert_failure( append_action_group( actions, group_id ) );

  actions = create_actions();

  ret = append_action_group( actions, group_id );
  assert_true( ret );

  action_group = actions->list->data;

  assert_int_equal( action_group->type, OFPAT_GROUP );
  assert_int_equal( action_group->len, sizeof( struct ofp_action_group ) );
  assert_int_equal( action_group->group_id, group_id );

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_set_nw_ttl() test.
 ********************************************************************************/

static void
test_append_action_set_nw_ttl() {
  openflow_actions *actions = NULL;
  uint8_t nw_ttl = 0x12;
  struct ofp_action_nw_ttl *action_set_nw_ttl;
  bool ret;

  expect_assert_failure( append_action_set_nw_ttl( actions, nw_ttl ) );

  actions = create_actions();

  ret = append_action_set_nw_ttl( actions, nw_ttl );
  assert_true( ret );

  action_set_nw_ttl = actions->list->data;

  assert_int_equal( action_set_nw_ttl->type, OFPAT_SET_NW_TTL );
  assert_int_equal( action_set_nw_ttl->len, sizeof( struct ofp_action_nw_ttl ) );
  assert_int_equal( action_set_nw_ttl->nw_ttl, nw_ttl );
  {
    void *pad = xmalloc( sizeof( action_set_nw_ttl->pad ) );
    memset( pad, 0, sizeof( action_set_nw_ttl->pad ) );
    assert_memory_equal( action_set_nw_ttl->pad, pad, sizeof( action_set_nw_ttl->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_dec_nw_ttl() test.
 ********************************************************************************/

static void
test_append_action_dec_nw_ttl() {
  openflow_actions *actions = NULL;
  struct ofp_action_header *action_dec_nw_ttl;
  bool ret;

  expect_assert_failure( append_action_dec_nw_ttl( actions ) );

  actions = create_actions();

  ret = append_action_dec_nw_ttl( actions );
  assert_true( ret );

  action_dec_nw_ttl = actions->list->data;

  assert_int_equal( action_dec_nw_ttl->type, OFPAT_DEC_NW_TTL );
  assert_int_equal( action_dec_nw_ttl->len, sizeof( struct ofp_action_header ) );
  {
    void *pad = xmalloc( sizeof( action_dec_nw_ttl->pad ) );
    memset( pad, 0, sizeof( action_dec_nw_ttl->pad ) );
    assert_memory_equal( action_dec_nw_ttl->pad, pad, sizeof( action_dec_nw_ttl->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_set_field_*() test.
 ********************************************************************************/

static void
test_append_action_set_field_in_port() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IN_PORT;
  uint32_t val = 10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_in_port( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_in_port( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_in_phy_port() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IN_PHY_PORT;
  uint32_t val = 10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_in_phy_port( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_in_phy_port( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_metadata() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_METADATA;
  uint64_t val = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_metadata( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_metadata( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_eth_dst() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ETH_DST;
  uint8_t val[ OFP_ETH_ALEN ]  = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15 };
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_eth_dst( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_eth_dst( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_eth_src() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ETH_SRC;
  uint8_t val[ OFP_ETH_ALEN ]  = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15 };
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_eth_src( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_eth_src( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_eth_type() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ETH_TYPE;
  uint16_t val  = 0x0806;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_eth_type( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_eth_type( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_vlan_vid() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_VLAN_VID;
  uint16_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_vlan_vid( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_vlan_vid( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_vlan_pcp() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_VLAN_PCP;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_vlan_pcp( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_vlan_pcp( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ip_dscp() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IP_DSCP;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ip_dscp( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ip_dscp( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ip_ecn() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IP_ECN;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ip_ecn( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ip_ecn( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ip_proto() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IP_PROTO;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ip_proto( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ip_proto( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv4_src() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV4_SRC;
  uint32_t val  = 0xC0A80F01;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv4_src( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv4_src( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv4_dst() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV4_DST;
  uint32_t val  = 0xC0A80F0F;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv4_dst( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv4_dst( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_tcp_src() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_TCP_SRC;
  uint16_t val  = 0x0137;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_tcp_src( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_tcp_src( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_tcp_dst() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_TCP_DST;
  uint16_t val  = 0x0138;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_tcp_dst( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_tcp_dst( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_udp_src() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_UDP_SRC;
  uint16_t val  = 0x0137;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_udp_src( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_udp_src( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_udp_dst() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_UDP_DST;
  uint16_t val  = 0x0138;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_udp_dst( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_udp_dst( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_sctp_src() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_SCTP_SRC;
  uint16_t val  = 0x0132;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_sctp_src( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_sctp_src( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_sctp_dst() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_SCTP_DST;
  uint16_t val  = 0x0132;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_sctp_dst( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_sctp_dst( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_icmpv4_type() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ICMPV4_TYPE;
  uint8_t val  = 0x08;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_icmpv4_type( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_icmpv4_type( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_icmpv4_code() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ICMPV4_CODE;
  uint8_t val  = 0x01;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_icmpv4_code( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_icmpv4_code( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_arp_op() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ARP_OP;
  uint16_t val  = 0x01;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_arp_op( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_arp_op( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_arp_spa() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ARP_SPA;
  uint32_t val  = 0xC0A80F01;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_arp_spa( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_arp_spa( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_arp_tpa() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ARP_TPA;
  uint32_t val  = 0xC0A80F0F;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_arp_tpa( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_arp_tpa( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_arp_sha() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ARP_SHA;
  uint8_t val[ OFP_ETH_ALEN ]  = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 };
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_arp_sha( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_arp_sha( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_arp_tha() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ARP_THA;
  uint8_t val[ OFP_ETH_ALEN ]  = { 0x01, 0x02, 0x03, 0x0A, 0x0B, 0x0C };
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_arp_tha( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_arp_tha( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_src() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_SRC;
  struct in6_addr val = { { { 0xFE, 0x80, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x01, 0x02,
                              0x03, 0x04, 0x05, 0x06 } } };

  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_src( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_src( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_dst() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_DST;
  struct in6_addr val = { { { 0xFE, 0x80, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x01, 0x02,
                              0x03, 0x0A, 0x0B, 0x0C } } };

  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_dst( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_dst( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_flabel() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_FLABEL;
  uint32_t val  = 0x01;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_flabel( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_flabel( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_icmpv6_type() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ICMPV6_TYPE;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_icmpv6_type( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_icmpv6_type( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_icmpv6_code() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_ICMPV6_CODE;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_icmpv6_code( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_icmpv6_code( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_nd_target() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_ND_TARGET;
  struct in6_addr val = { { { 0xFE, 0x80, 0x00, 0x00,
                              0x00, 0x00, 0x00, 0x00,
                              0x00, 0x00, 0x01, 0x02,
                              0x03, 0x0A, 0x0B, 0x0C } } };

  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_nd_target( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_nd_target( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_nd_sll() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_ND_SLL;
  uint8_t val[ OFP_ETH_ALEN ]  = { 0x01, 0x02, 0x03, 0x01, 0x02, 0x03 };
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_nd_sll( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_nd_sll( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_nd_tll() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_ND_TLL;
  uint8_t val[ OFP_ETH_ALEN ]  = { 0x01, 0x02, 0x03, 0x0A, 0x0B, 0x0C };
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_nd_tll( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_nd_tll( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_mpls_label() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_MPLS_LABEL;
  uint32_t val  = 0x11223344;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_mpls_label( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_mpls_label( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_mpls_tc() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_MPLS_TC;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_mpls_tc( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_mpls_tc( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_mpls_bos() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_MPLS_BOS;
  uint8_t val  = 0x10;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_mpls_bos( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_mpls_bos( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_pbb_isid() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_PBB_ISID;
  uint32_t val  = 0xAABBCCDD;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_pbb_isid( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_pbb_isid( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_tunnel_id() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_TUNNEL_ID;
  uint32_t val  = 0x11223344;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_tunnel_id( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_tunnel_id( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


static void
test_append_action_set_field_ipv6_exthdr() {
  openflow_actions *actions = NULL;
  struct ofp_action_set_field *action_set_field;
  oxm_match_header type = OXM_OF_IPV6_EXTHDR;
  uint16_t val  = 0x1122;
  uint16_t oxm_len;
  uint16_t act_len;
  struct ofp_action_set_field *expected;
  oxm_match_header *oxm_hdr;
  bool ret;

  expect_assert_failure( append_action_set_field_ipv6_exthdr( actions, val ) );

  {
    oxm_len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( type ) );
    act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + oxm_len );
    act_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );

    actions = create_actions();

    ret = append_action_set_field_ipv6_exthdr( actions, val );
    assert_true( ret );

    expected = xcalloc( 1, act_len );
    expected->type = OFPAT_SET_FIELD;
    expected->len = act_len;
    oxm_hdr = ( oxm_match_header * ) expected->field;
    *oxm_hdr = type;
    memcpy( oxm_hdr + 1, &val, sizeof( val ) );

    action_set_field = actions->list->data;

    assert_memory_equal( action_set_field, expected, act_len );

    xfree( expected );
    delete_actions( actions );
  }
}


/********************************************************************************
 * append_action_push_pbb() test.
 ********************************************************************************/

static void
test_append_action_push_pbb() {
  openflow_actions *actions = NULL;
  uint16_t ethertype = 0x1234;
  struct ofp_action_push *action_push_pbb;
  bool ret;

  expect_assert_failure( append_action_push_pbb( actions, ethertype ) );

  actions = create_actions();

  ret = append_action_push_pbb( actions, ethertype );
  assert_true( ret );

  action_push_pbb = actions->list->data;

  assert_int_equal( action_push_pbb->type, OFPAT_PUSH_PBB );
  assert_int_equal( action_push_pbb->len, sizeof( struct ofp_action_push ) );
  assert_int_equal( action_push_pbb->ethertype, ethertype );
  {
    void *pad = xmalloc( sizeof( action_push_pbb->pad ) );
    memset( pad, 0, sizeof( action_push_pbb->pad ) );
    assert_memory_equal( action_push_pbb->pad, pad, sizeof( action_push_pbb->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_pop_pbb() test.
 ********************************************************************************/

static void
test_append_action_pop_pbb() {
  openflow_actions *actions = NULL;
  struct ofp_action_header *action_pop_pbb;
  bool ret;

  expect_assert_failure( append_action_pop_pbb( actions ) );

  actions = create_actions();

  ret = append_action_pop_pbb( actions );
  assert_true( ret );

  action_pop_pbb = actions->list->data;

  assert_int_equal( action_pop_pbb->type, OFPAT_POP_PBB );
  assert_int_equal( action_pop_pbb->len, sizeof( struct ofp_action_header ) );
  {
    void *pad = xmalloc( sizeof( action_pop_pbb->pad ) );
    memset( pad, 0, sizeof( action_pop_pbb->pad ) );
    assert_memory_equal( action_pop_pbb->pad, pad, sizeof( action_pop_pbb->pad ) );
    xfree( pad );
  }

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * append_action_experimenter() test.
 ********************************************************************************/

static void
test_append_action_experimenter() {
  openflow_actions *actions = NULL;
  uint32_t experimenter = 1;
  buffer *body;
  struct ofp_action_experimenter_header *action_experimenter;
  uint16_t length;
  bool ret;

  body = create_dummy_data( SHORT_DATA_LENGTH );

  length = ( uint16_t ) ( sizeof( struct ofp_action_experimenter_header ) + body->length );

  expect_assert_failure( append_action_experimenter( actions, experimenter, body ) );

  actions = create_actions();

  ret = append_action_experimenter( actions, experimenter, body );
  assert_true( ret );

  action_experimenter = actions->list->data;

  assert_int_equal( action_experimenter->type, OFPAT_EXPERIMENTER );
  assert_int_equal( action_experimenter->len, length );
  assert_int_equal( ( int ) action_experimenter->experimenter, ( int ) experimenter );
  void *data = ( char * ) action_experimenter + sizeof( struct ofp_action_experimenter_header );
  assert_memory_equal( data, body->data, body->length );

  assert_int_equal( actions->n_actions, 1 );

  free_buffer( body );
  delete_actions( actions );
}


/********************************************************************************
 * append_action_experimenter_without_data() test.
 ********************************************************************************/

static void
test_append_action_experimenter_without_data() {
  openflow_actions *actions = NULL;
  uint32_t experimenter = 1;
  buffer *body = NULL;
  struct ofp_action_experimenter_header *action_experimenter;
  uint16_t length;
  bool ret;

  length = ( uint16_t ) sizeof( struct ofp_action_experimenter_header );

  expect_assert_failure( append_action_experimenter( actions, experimenter, body ) );

  actions = create_actions();

  ret = append_action_experimenter( actions, experimenter, body );
  assert_true( ret );

  action_experimenter = actions->list->data;

  assert_int_equal( action_experimenter->type, OFPAT_EXPERIMENTER );
  assert_int_equal( action_experimenter->len, length );
  assert_int_equal( ( int ) action_experimenter->experimenter, ( int ) experimenter );

  assert_int_equal( actions->n_actions, 1 );

  delete_actions( actions );
}


/********************************************************************************
 * Test of functions for creating/deleting instructions.
 ********************************************************************************/

static void
test_create_and_delete_instructions() {
  openflow_instructions *instructions = create_instructions();
  bool ret;

  assert_true( instructions != NULL );
  assert_int_equal( instructions->n_instructions, 0 );

  ret = delete_instructions( instructions );
  assert_true( ret );

  instructions = NULL;
  expect_assert_failure( delete_instructions( NULL ) );
}


/********************************************************************************
 * append_instructions_goto_table() test.
 ********************************************************************************/

static void
test_append_instructions_goto_table() {
  openflow_instructions *instructions = NULL;
  uint8_t table_id = 0x12;
  struct ofp_instruction_goto_table *instruction_goto_table;
  bool ret;

  expect_assert_failure( append_instructions_goto_table( instructions, table_id ) );

  instructions = create_instructions();

  ret = append_instructions_goto_table( instructions, table_id );
  assert_true( ret );

  instruction_goto_table = instructions->list->data;

  assert_int_equal( instruction_goto_table->type, OFPIT_GOTO_TABLE );
  assert_int_equal( instruction_goto_table->len, sizeof( struct ofp_instruction_goto_table ) );
  assert_int_equal( instruction_goto_table->table_id, table_id );
  {
    void *pad = xmalloc( sizeof( instruction_goto_table->pad ) );
    memset( pad, 0, sizeof( instruction_goto_table->pad ) );
    assert_memory_equal( instruction_goto_table->pad, pad, sizeof( instruction_goto_table->pad ) );
    xfree( pad );
  }

  assert_int_equal( instructions->n_instructions, 1 );

  delete_instructions( instructions );
}


/********************************************************************************
 * append_instructions_write_metadata() test.
 ********************************************************************************/

static void
test_append_instructions_write_metadata() {
  openflow_instructions *instructions = NULL;
  uint64_t metadata = 0x1234567890123456;
  uint64_t metadata_mask = 0x6543210987654321;
  struct ofp_instruction_write_metadata *instruction_write_metadata;
  bool ret;

  expect_assert_failure( append_instructions_write_metadata( instructions, metadata, metadata_mask ) );

  instructions = create_instructions();

  ret = append_instructions_write_metadata( instructions, metadata, metadata_mask );
  assert_true( ret );

  instruction_write_metadata = instructions->list->data;

  assert_int_equal( instruction_write_metadata->type, OFPIT_WRITE_METADATA );
  assert_int_equal( instruction_write_metadata->len, sizeof( struct ofp_instruction_write_metadata ) );
  {
    void *pad = xmalloc( sizeof( instruction_write_metadata->pad ) );
    memset( pad, 0, sizeof( instruction_write_metadata->pad ) );
    assert_memory_equal( instruction_write_metadata->pad, pad, sizeof( instruction_write_metadata->pad ) );
    xfree( pad );
  }
  assert_memory_equal( &instruction_write_metadata->metadata, &metadata, sizeof( metadata ) );
  assert_memory_equal( &instruction_write_metadata->metadata_mask, &metadata_mask, sizeof( metadata_mask ) );

  assert_int_equal( instructions->n_instructions, 1 );

  delete_instructions( instructions );
}


/********************************************************************************
 * append_instructions_write_actions() test.
 ********************************************************************************/

static void
test_append_instructions_write_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  struct ofp_action_header *expected_act;
  uint16_t expected_act_len = 0;
  uint16_t expected_instruction_len;
  openflow_instructions *instructions = NULL;
  struct ofp_instruction_actions *instruction_actions;
  bool ret;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  expect_assert_failure( append_instructions_write_actions( instructions, actions ) );

  instructions = create_instructions();

  ret = append_instructions_write_actions( instructions, actions );
  assert_true( ret );

  {
    expected_act_len = ( uint16_t ) ( action_testdata_len[0] + action_testdata_len[1] );
    expected_instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + expected_act_len );
    expected_act = xcalloc( 1, expected_act_len );
    memcpy( expected_act, action_testdata[0], action_testdata_len[0] );
    memcpy( ( char * ) expected_act + action_testdata_len[0], action_testdata[1], action_testdata_len[1] );
  }

  instruction_actions = instructions->list->data;

  assert_int_equal( instruction_actions->type, OFPIT_WRITE_ACTIONS );
  assert_int_equal( instruction_actions->len, expected_instruction_len );
  {
    void *pad = xmalloc( sizeof( instruction_actions->pad ) );
    memset( pad, 0, sizeof( instruction_actions->pad ) );
    assert_memory_equal( instruction_actions->pad, pad, sizeof( instruction_actions->pad ) );
    xfree( pad );
  }
  assert_memory_equal( &instruction_actions->actions, expected_act, expected_act_len );

  assert_int_equal( instructions->n_instructions, 1 );

  xfree( expected_act );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


/********************************************************************************
 * append_instructions_apply_actions() test.
 ********************************************************************************/

static void
test_append_instructions_apply_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  struct ofp_action_header *expected_act;
  uint16_t expected_act_len = 0;
  uint16_t expected_instruction_len;
  openflow_instructions *instructions = NULL;
  struct ofp_instruction_actions *instruction_actions;
  bool ret;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  expect_assert_failure( append_instructions_apply_actions( instructions, actions ) );

  instructions = create_instructions();

  ret = append_instructions_apply_actions( instructions, actions );
  assert_true( ret );

  {
    expected_act_len = ( uint16_t ) ( action_testdata_len[0] + action_testdata_len[1] );
    expected_instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + expected_act_len );
    expected_act = xcalloc( 1, expected_act_len );
    memcpy( expected_act, action_testdata[0], action_testdata_len[0] );
    memcpy( ( char * ) expected_act + action_testdata_len[0], action_testdata[1], action_testdata_len[1] );
  }

  instruction_actions = instructions->list->data;

  assert_int_equal( instruction_actions->type, OFPIT_APPLY_ACTIONS );
  assert_int_equal( instruction_actions->len, expected_instruction_len );
  {
    void *pad = xmalloc( sizeof( instruction_actions->pad ) );
    memset( pad, 0, sizeof( instruction_actions->pad ) );
    assert_memory_equal( instruction_actions->pad, pad, sizeof( instruction_actions->pad ) );
    xfree( pad );
  }
  assert_memory_equal( &instruction_actions->actions, expected_act, expected_act_len );

  assert_int_equal( instructions->n_instructions, 1 );

  xfree( expected_act );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


/********************************************************************************
 * append_instructions_clear_actions() test.
 ********************************************************************************/

static void
test_append_instructions_clear_actions() {
  openflow_instructions *instructions = NULL;
  struct ofp_instruction_actions *instruction_clear_actions;
  bool ret;

  expect_assert_failure( append_instructions_clear_actions( instructions ) );

  instructions = create_instructions();

  ret = append_instructions_clear_actions( instructions );
  assert_true( ret );

  instruction_clear_actions = instructions->list->data;

  assert_int_equal( instruction_clear_actions->type, OFPIT_CLEAR_ACTIONS );
  assert_int_equal( instruction_clear_actions->len, sizeof( struct ofp_instruction_actions ) );
  {
    void *pad = xmalloc( sizeof( instruction_clear_actions->pad ) );
    memset( pad, 0, sizeof( instruction_clear_actions->pad ) );
    assert_memory_equal( instruction_clear_actions->pad, pad, sizeof( instruction_clear_actions->pad ) );
    xfree( pad );
  }

  assert_int_equal( instructions->n_instructions, 1 );

  delete_instructions( instructions );
}


/********************************************************************************
 * append_instructions_meter() test.
 ********************************************************************************/

static void
test_append_instructions_meter() {
  openflow_instructions *instructions = NULL;
  uint32_t meter_id = 0x12345678;
  struct ofp_instruction_meter *instruction_meter;
  bool ret;

  expect_assert_failure( append_instructions_meter( instructions, meter_id ) );

  instructions = create_instructions();

  ret = append_instructions_meter( instructions, meter_id );
  assert_true( ret );

  instruction_meter = instructions->list->data;

  assert_int_equal( instruction_meter->type, OFPIT_METER );
  assert_int_equal( instruction_meter->len, sizeof( struct ofp_instruction_meter ) );
  assert_int_equal( instruction_meter->meter_id, meter_id );

  assert_int_equal( instructions->n_instructions, 1 );

  delete_instructions( instructions );
}


/********************************************************************************
 * append_instructions_experimenter() test.
 ********************************************************************************/

static void
test_append_instructions_experimenter() {
  openflow_instructions *instructions = NULL;
  uint32_t experimenter = 1;
  buffer *body;
  struct ofp_instruction_experimenter *instruction_experimenter;
  uint16_t length;
  bool ret;

  body = create_dummy_data( SHORT_DATA_LENGTH );

  length = ( uint16_t ) ( sizeof( struct ofp_instruction_experimenter ) + body->length );

  expect_assert_failure( append_instructions_experimenter( instructions, experimenter, body ) );

  instructions = create_instructions();

  ret = append_instructions_experimenter( instructions, experimenter, body );
  assert_true( ret );

  instruction_experimenter = instructions->list->data;

  assert_int_equal( instruction_experimenter->type, OFPIT_EXPERIMENTER );
  assert_int_equal( instruction_experimenter->len, length );
  assert_int_equal( ( int ) instruction_experimenter->experimenter, ( int ) experimenter );
  void *data = ( char * ) instruction_experimenter + sizeof( struct ofp_instruction_experimenter );
  assert_memory_equal( data, body->data, body->length );

  assert_int_equal( instructions->n_instructions, 1 );

  free_buffer( body );
  delete_instructions( instructions );
}


/********************************************************************************
 * append_instructions_experimenter_without_data() test.
 ********************************************************************************/

static void
test_append_instructions_experimenter_without_data() {
  openflow_instructions *instructions = NULL;
  uint32_t experimenter = 1;
  buffer *body = NULL;
  struct ofp_instruction_experimenter *instruction_experimenter;
  uint16_t length;
  bool ret;

  length = ( uint16_t ) ( sizeof( struct ofp_instruction_experimenter ) );

  expect_assert_failure( append_instructions_experimenter( instructions, experimenter, body ) );

  instructions = create_instructions();

  ret = append_instructions_experimenter( instructions, experimenter, body );
  assert_true( ret );

  instruction_experimenter = instructions->list->data;

  assert_int_equal( instruction_experimenter->type, OFPIT_EXPERIMENTER );
  assert_int_equal( instruction_experimenter->len, length );
  assert_int_equal( ( int ) instruction_experimenter->experimenter, ( int ) experimenter );

  assert_int_equal( instructions->n_instructions, 1 );

  delete_instructions( instructions );
}


/********************************************************************************
 * create_packet_out() tests.
 ********************************************************************************/

static void
test_create_packet_out() {
  uint32_t in_port = 2;
  uint32_t port = 1;
  uint16_t max_len = 128;
  openflow_actions *actions;
  buffer *expected_data;
  buffer *buffer;
  struct ofp_packet_out *packet_out;
  uint16_t actions_len;
  uint16_t length;

  actions = create_actions();
  append_action_output( actions, port, max_len );

  expected_data = create_dummy_data( LONG_DATA_LENGTH );

  buffer = create_packet_out( MY_TRANSACTION_ID, BUFFER_ID, in_port, actions, expected_data );
  assert_true( buffer != NULL );

  packet_out = buffer->data;

  actions_len = get_actions_length( actions );
  length = ( uint16_t ) ( sizeof( struct ofp_packet_out ) + actions_len + expected_data->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( packet_out->header.version, OFP_VERSION );
  assert_int_equal( packet_out->header.type, OFPT_PACKET_OUT );
  assert_int_equal( ntohs( packet_out->header.length ), length );
  assert_int_equal( ( int ) ntohl( packet_out->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( packet_out->buffer_id ), ( int ) BUFFER_ID );
  assert_int_equal( ntohl( packet_out->in_port ), in_port );
  assert_int_equal( ntohs( packet_out->actions_len ), actions_len );
  {
    void *pad = xmalloc( sizeof( packet_out->pad ) );
    memset( pad, 0, sizeof( packet_out->pad ) );
    assert_memory_equal( packet_out->pad, pad, sizeof( packet_out->pad ) );
    xfree( pad );
  }

  {
    void *a = packet_out->actions;
    list_element *expected_action = actions->list;

    while ( expected_action != NULL ) {
      struct ofp_action_output tmp_a;
      ntoh_action( ( struct ofp_action_header * ) &tmp_a, ( struct ofp_action_header * ) a );

      struct ofp_action_output *expected_action_output = expected_action->data;

      assert_int_equal( tmp_a.type, expected_action_output->type );
      assert_int_equal( tmp_a.len, expected_action_output->len );
      assert_int_equal( tmp_a.port, expected_action_output->port );
      assert_int_equal( tmp_a.max_len, expected_action_output->max_len );
      assert_memory_equal( tmp_a.pad, expected_action_output->pad, sizeof( expected_action_output->pad ) );

      a = ( void * ) ( ( char * ) a + tmp_a.len );
      expected_action = expected_action->next;
    }
  }

  void *d = ( void * ) ( ( char * ) buffer->data + sizeof( struct ofp_packet_out ) + actions_len );
  assert_memory_equal( d, expected_data->data, expected_data->length );

  assert_int_equal( actions->n_actions, 1 );

  free_buffer( expected_data );
  free_buffer( buffer );
  delete_actions( actions );
}


static void
test_create_packet_out_without_actions() {
  uint32_t in_port = 1;
  openflow_actions *actions = NULL;
  buffer *expected_data;
  buffer *buffer;
  struct ofp_packet_out *packet_out;
  uint16_t length;

  expected_data = create_dummy_data( SHORT_DATA_LENGTH );

  buffer = create_packet_out( MY_TRANSACTION_ID, BUFFER_ID, in_port, actions, expected_data );
  assert_true( buffer != NULL );

  packet_out = buffer->data;

  length = ( uint16_t ) ( sizeof( struct ofp_packet_out ) + expected_data->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( packet_out->header.version, OFP_VERSION );
  assert_int_equal( packet_out->header.type, OFPT_PACKET_OUT );
  assert_int_equal( ntohs( packet_out->header.length ), length );
  assert_int_equal( ( int ) ntohl( packet_out->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( packet_out->buffer_id ), ( int ) BUFFER_ID );
  assert_int_equal( ntohl( packet_out->in_port ), in_port );
  assert_int_equal( ntohs( packet_out->actions_len ), 0 );

  void *d = ( void * ) ( ( char * ) buffer->data + sizeof( struct ofp_packet_out ) );
  assert_memory_equal( d, expected_data->data, expected_data->length );

  free_buffer( expected_data );
  free_buffer( buffer );
}


/********************************************************************************
 * create_flow_mod() test.
 ********************************************************************************/

static void
test_create_flow_mod() {
  uint64_t cookie = 10;
  uint64_t cookie_mask = 20;
  uint8_t table_id = 0x12;
  uint8_t command = OFPFC_ADD;
  uint16_t idle_timeout = 5;
  uint16_t hard_timeout = 10;
  uint32_t buffer_id = 10;
  uint32_t out_port = 0x12348765;
  uint32_t out_group = 0x43215678;
  uint16_t flags = OFPFF_CHECK_OVERLAP | OFPFF_SEND_FLOW_REM;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  openflow_instructions *instructions;
  struct ofp_instruction *inst1, *inst2;
  uint16_t instructions_len;

  buffer *buffer;
  struct ofp_flow_mod *flow_mod;
  uint16_t expected_msglen;
  uint64_t tmp;


  // with match
  {
    // ofp_match
    {
      create_oxm_match_testdata();

      oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
      memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
      oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
      memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

      match = create_oxm_matches();
      match->n_matches = 2;
      append_to_tail( &match->list, oxm1 );
      append_to_tail( &match->list, oxm2 );
    }


    // ofp_instruction
    {
      create_instruction_testdata();

      inst1 = xcalloc( 1, instruction_testdata_len[0] );
      memcpy( inst1, instruction_testdata[0], instruction_testdata_len[0] );
      inst2 = xcalloc( 1, instruction_testdata_len[1] );
      memcpy( inst2, instruction_testdata[1], instruction_testdata_len[1] );

      instructions = create_instructions();
      instructions->n_instructions = 2;
      append_to_tail( &instructions->list, inst1 );
      append_to_tail( &instructions->list, inst2 );
    }

    instructions_len = ( uint16_t ) get_instructions_length( instructions );
    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_flow_mod, match ) + expected_ofp_match_len + instructions_len );

    buffer = create_flow_mod( MY_TRANSACTION_ID, cookie, cookie_mask, table_id, command, idle_timeout,
                              hard_timeout, PRIORITY, buffer_id, out_port, out_group, flags, match, instructions );
    assert_true( buffer != NULL );

    flow_mod = ( struct ofp_flow_mod * ) buffer->data;

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( flow_mod->header.version, OFP_VERSION );
    assert_int_equal( flow_mod->header.type, OFPT_FLOW_MOD );
    assert_int_equal( ntohs( flow_mod->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( flow_mod->header.xid ), ( int ) MY_TRANSACTION_ID );

    tmp = ntohll( flow_mod->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    tmp = ntohll( flow_mod->cookie_mask );
    assert_memory_equal( &tmp, &cookie_mask, sizeof( cookie_mask ) );
    assert_int_equal( ( int ) flow_mod->table_id, table_id );
    assert_int_equal( ( int ) flow_mod->command, command );
    assert_int_equal( ntohs( flow_mod->idle_timeout ), idle_timeout );
    assert_int_equal( ntohs( flow_mod->hard_timeout ), hard_timeout );
    assert_int_equal( ntohs( flow_mod->priority ), PRIORITY );
    assert_int_equal( ( int ) ntohl( flow_mod->buffer_id ), ( int ) buffer_id );
    assert_int_equal( ntohl( flow_mod->out_port ), out_port );
    assert_int_equal( ntohl( flow_mod->out_group ), out_group );
    assert_int_equal( ntohs( flow_mod->flags ), flags );

    ntoh_match( &flow_mod->match, &flow_mod->match );
    assert_memory_equal( &flow_mod->match, expected_ofp_match, expected_ofp_match_len );

    {
      struct ofp_instruction *a = ( struct ofp_instruction * ) ( ( char * ) flow_mod + offsetof( struct ofp_flow_mod, match ) + expected_ofp_match_len );
      list_element *expected_instruction = instructions->list;

      while ( expected_instruction != NULL ) {
        ntoh_instruction( a, a );

        struct ofp_instruction *expected_inst = expected_instruction->data;

        assert_memory_equal( a, expected_inst, expected_inst->len );

        a = ( struct ofp_instruction * ) ( ( char * ) a + a->len );
        expected_instruction = expected_instruction->next;
      }
    }

    free_buffer( buffer );
    delete_oxm_matches( match );
    delete_instructions( instructions );

    delete_oxm_match_testdata();
    delete_instruction_testdata();
  }

  // without match
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    // ofp_match
    {
      expected_empty_ofp_match_len = sizeof( struct ofp_match );
      expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
      expected_empty_ofp_match->type = OFPMT_OXM;
      expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );
    }


    // ofp_instruction
    {
      create_instruction_testdata();

      inst1 = xcalloc( 1, instruction_testdata_len[0] );
      memcpy( inst1, instruction_testdata[0], instruction_testdata_len[0] );
      inst2 = xcalloc( 1, instruction_testdata_len[1] );
      memcpy( inst2, instruction_testdata[1], instruction_testdata_len[1] );

      instructions = create_instructions();
      instructions->n_instructions = 2;
      append_to_tail( &instructions->list, inst1 );
      append_to_tail( &instructions->list, inst2 );
    }

    instructions_len = ( uint16_t ) get_instructions_length( instructions );
    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_flow_mod, match ) + expected_empty_ofp_match_len + instructions_len );

    buffer = create_flow_mod( MY_TRANSACTION_ID, cookie, cookie_mask, table_id, command, idle_timeout,
                              hard_timeout, PRIORITY, buffer_id, out_port, out_group, flags, NULL, instructions );
    assert_true( buffer != NULL );

    flow_mod = ( struct ofp_flow_mod * ) buffer->data;

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( flow_mod->header.version, OFP_VERSION );
    assert_int_equal( flow_mod->header.type, OFPT_FLOW_MOD );
    assert_int_equal( ntohs( flow_mod->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( flow_mod->header.xid ), ( int ) MY_TRANSACTION_ID );

    tmp = ntohll( flow_mod->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    tmp = ntohll( flow_mod->cookie_mask );
    assert_memory_equal( &tmp, &cookie_mask, sizeof( cookie_mask ) );
    assert_int_equal( ( int ) flow_mod->table_id, table_id );
    assert_int_equal( ( int ) flow_mod->command, command );
    assert_int_equal( ntohs( flow_mod->idle_timeout ), idle_timeout );
    assert_int_equal( ntohs( flow_mod->hard_timeout ), hard_timeout );
    assert_int_equal( ntohs( flow_mod->priority ), PRIORITY );
    assert_int_equal( ( int ) ntohl( flow_mod->buffer_id ), ( int ) buffer_id );
    assert_int_equal( ntohl( flow_mod->out_port ), out_port );
    assert_int_equal( ntohl( flow_mod->out_group ), out_group );
    assert_int_equal( ntohs( flow_mod->flags ), flags );

    ntoh_match( &flow_mod->match, &flow_mod->match );
    assert_memory_equal( &flow_mod->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    {
      struct ofp_instruction *a = ( struct ofp_instruction * ) ( ( char * ) flow_mod + offsetof( struct ofp_flow_mod, match ) + expected_empty_ofp_match_len );
      list_element *expected_instruction = instructions->list;

      while ( expected_instruction != NULL ) {
        ntoh_instruction( a, a );

        struct ofp_instruction *expected_inst = expected_instruction->data;

        assert_memory_equal( a, expected_inst, expected_inst->len );

        a = ( struct ofp_instruction * ) ( ( char * ) a + a->len );
        expected_instruction = expected_instruction->next;
      }
    }

    free_buffer( buffer );
    xfree( expected_empty_ofp_match );
    delete_instructions( instructions );

    delete_instruction_testdata();
  }
}


/********************************************************************************
 * create_multipart_request() test.
 ********************************************************************************/

static void
test_create_multipart_request() {
  uint16_t type = OFPMP_DESC;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  uint16_t length;

  length = sizeof( struct ofp_multipart_request );

  buffer = create_multipart_request( MY_TRANSACTION_ID, type, length, NO_FLAGS );
  assert_true( buffer != NULL );

  stats_request = buffer->data;

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), type );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * create_multipart_reply() test.
 ********************************************************************************/

static void
test_create_multipart_reply() {
  uint16_t type = OFPMP_DESC;
  uint16_t length = sizeof( struct ofp_multipart_reply );
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;

  buffer = create_multipart_reply( MY_TRANSACTION_ID, type, length, NO_FLAGS );
  assert_true( buffer != NULL );

  stats_reply = ( struct ofp_multipart_reply * ) buffer->data;

  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), type );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * create_desc_multipart_request() test.
 ********************************************************************************/

static void
test_create_desc_multipart_request() {
  buffer *buffer;
  struct ofp_multipart_request *stats_request;

  buffer = create_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_multipart_request ) );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), sizeof( struct ofp_multipart_request ) );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_DESC );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * create_desc_multipart_reply() test.
 ********************************************************************************/

static void
test_create_desc_multipart_reply() {
  const char mfr_desc[ DESC_STR_LEN ] = "NEC Corporation";
  const char hw_desc[ DESC_STR_LEN ] = "OpenFlow Switch Hardware";
  const char sw_desc[ DESC_STR_LEN ] = "OpenFlow Switch Software";
  const char serial_num[ SERIAL_NUM_LEN ] = "1234";
  const char dp_desc[ DESC_STR_LEN ] = "Datapath 0";
  uint16_t length;
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_desc *desc_stats;

  length = ( uint16_t ) ( sizeof( struct ofp_multipart_reply ) + sizeof( struct ofp_desc ) );

  buffer = create_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, mfr_desc, hw_desc, sw_desc, serial_num, dp_desc );
  assert_true( buffer != NULL );

  stats_reply = ( struct ofp_multipart_reply * ) buffer->data;
  desc_stats = ( struct ofp_desc * ) ( ( char * ) buffer->data + sizeof( struct ofp_multipart_reply ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_DESC );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  assert_memory_equal( desc_stats->mfr_desc, mfr_desc, strlen( mfr_desc ) + 1 );
  assert_memory_equal( desc_stats->hw_desc, hw_desc, strlen( mfr_desc ) + 1 );
  assert_memory_equal( desc_stats->sw_desc, sw_desc, strlen( mfr_desc ) + 1 );
  assert_memory_equal( desc_stats->serial_num, serial_num, strlen( mfr_desc ) + 1 );
  assert_memory_equal( desc_stats->dp_desc, dp_desc, strlen( mfr_desc ) + 1 );

  free_buffer( buffer );
}


/********************************************************************************
 * create_flow_multipart_request() test.
 ********************************************************************************/

static void
test_create_flow_multipart_request() {
  uint8_t table_id = 0xff;
  uint32_t out_port = 1;
  uint32_t out_group = 5;
  uint64_t cookie = 0x1234567890123456;
  uint64_t cookie_mask = 0x6543210987654321;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_flow_stats_request *flow_stats_request;
  uint16_t expected_length;
  uint64_t tmp;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  // with match
  {
    // ofp_match
    {
      create_oxm_match_testdata();

      oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
      memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
      oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
      memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

      match = create_oxm_matches();
      match->n_matches = 2;
      append_to_tail( &match->list, oxm1 );
      append_to_tail( &match->list, oxm2 );
    }

    buffer = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, match );
    assert_true( buffer != NULL );

    stats_request = ( struct ofp_multipart_request * ) buffer->data;
    expected_length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body ) + offsetof( struct ofp_flow_stats_request, match ) + expected_ofp_match_len );

    assert_int_equal( ( int ) buffer->length, expected_length );
    assert_int_equal( stats_request->header.version, OFP_VERSION );
    assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
    assert_int_equal( ntohs( stats_request->header.length ), expected_length );
    assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_request->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

    flow_stats_request = ( struct ofp_flow_stats_request * ) ( ( char * ) buffer->data
                         + offsetof( struct ofp_multipart_request, body ) );

    assert_int_equal( flow_stats_request->table_id, table_id );
    {
      void *pad = xmalloc( sizeof( flow_stats_request->pad ) );
      memset( pad, 0, sizeof( flow_stats_request->pad ) );
      assert_memory_equal( flow_stats_request->pad, pad, sizeof( flow_stats_request->pad ) );
      xfree( pad );
    }
    assert_int_equal( ntohl( flow_stats_request->out_port ), out_port );
    assert_int_equal( ntohl( flow_stats_request->out_group ), out_group );
    {
      void *pad = xmalloc( sizeof( flow_stats_request->pad2 ) );
      memset( pad, 0, sizeof( flow_stats_request->pad2 ) );
      assert_memory_equal( flow_stats_request->pad2, pad, sizeof( flow_stats_request->pad2 ) );
      xfree( pad );
    }
    tmp = ntohll( flow_stats_request->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    tmp = ntohll( flow_stats_request->cookie_mask );
    assert_memory_equal( &tmp, &cookie_mask, sizeof( cookie_mask ) );

    ntoh_match( &flow_stats_request->match, &flow_stats_request->match );
    assert_memory_equal( &flow_stats_request->match, expected_ofp_match, expected_ofp_match_len );

    delete_oxm_matches( match );
    delete_oxm_match_testdata();
    free_buffer( buffer );
  }

  // without match
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    // ofp_match
    {
      expected_empty_ofp_match_len = sizeof( struct ofp_match );
      expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
      expected_empty_ofp_match->type = OFPMT_OXM;
      expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );
    }

    buffer = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, NULL );
    assert_true( buffer != NULL );

    stats_request = ( struct ofp_multipart_request * ) buffer->data;
    expected_length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body ) + offsetof( struct ofp_flow_stats_request, match ) + expected_empty_ofp_match_len );

    assert_int_equal( ( int ) buffer->length, expected_length );
    assert_int_equal( stats_request->header.version, OFP_VERSION );
    assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
    assert_int_equal( ntohs( stats_request->header.length ), expected_length );
    assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_request->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

    flow_stats_request = ( struct ofp_flow_stats_request * ) ( ( char * ) buffer->data
                         + offsetof( struct ofp_multipart_request, body ) );

    assert_int_equal( flow_stats_request->table_id, table_id );
    {
      void *pad = xmalloc( sizeof( flow_stats_request->pad ) );
      memset( pad, 0, sizeof( flow_stats_request->pad ) );
      assert_memory_equal( flow_stats_request->pad, pad, sizeof( flow_stats_request->pad ) );
      xfree( pad );
    }
    assert_int_equal( ntohl( flow_stats_request->out_port ), out_port );
    assert_int_equal( ntohl( flow_stats_request->out_group ), out_group );
    {
      void *pad = xmalloc( sizeof( flow_stats_request->pad2 ) );
      memset( pad, 0, sizeof( flow_stats_request->pad2 ) );
      assert_memory_equal( flow_stats_request->pad2, pad, sizeof( flow_stats_request->pad2 ) );
      xfree( pad );
    }
    tmp = ntohll( flow_stats_request->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    tmp = ntohll( flow_stats_request->cookie_mask );
    assert_memory_equal( &tmp, &cookie_mask, sizeof( cookie_mask ) );

    ntoh_match( &flow_stats_request->match, &flow_stats_request->match );
    assert_memory_equal( &flow_stats_request->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    xfree( expected_empty_ofp_match );
    free_buffer( buffer );
  }
}


/********************************************************************************
 * create_flow_multipart_reply() test.
 ********************************************************************************/

static void
test_create_flow_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *expected_list, *list;
  buffer *buffer;
  uint16_t stats_len = 0;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_flow_stats *expected_stats[ 2 ], *flow_stats;
  struct ofp_instruction *inst;
  uint16_t length;

  // with match
  {
    create_oxm_match_testdata();
    create_instruction_testdata();

    stats_len = ( uint16_t ) ( offsetof( struct ofp_flow_stats, match ) + expected_ofp_match_len + expected_ofp_instruction_len );

    expected_stats[ 0 ] = xcalloc( 1, stats_len );
    expected_stats[ 1 ] = xcalloc( 1, stats_len );

    expected_stats[ 0 ]->length = stats_len;
    expected_stats[ 0 ]->table_id = 1;
    expected_stats[ 0 ]->pad = 0;
    expected_stats[ 0 ]->duration_sec = 60;
    expected_stats[ 0 ]->duration_nsec = 10000;
    expected_stats[ 0 ]->priority = 1024;
    expected_stats[ 0 ]->idle_timeout = 60;
    expected_stats[ 0 ]->hard_timeout = 3600;
    expected_stats[ 0 ]->flags = OFPFF_NO_BYT_COUNTS;
    memset( expected_stats[ 0 ]->pad2, 0, sizeof( expected_stats[ 0 ]->pad2 ) );
    expected_stats[ 0 ]->cookie = 0x0102030405060708ULL;
    expected_stats[ 0 ]->packet_count = 1000;
    expected_stats[ 0 ]->byte_count = 100000;
    memcpy( &expected_stats[ 0 ]->match, expected_ofp_match, expected_ofp_match_len );
    inst = ( struct ofp_instruction * ) ( ( char * ) &expected_stats[ 0 ]->match + expected_ofp_match_len );
    memcpy( inst, expected_ofp_instruction, expected_ofp_instruction_len );

    memcpy( expected_stats[ 1 ], expected_stats[ 0 ], stats_len );
    expected_stats[ 1 ]->cookie = 0x0203040506070809ULL;

    create_list( &expected_list );
    append_to_tail( &expected_list, expected_stats[ 0 ] );
    append_to_tail( &expected_list, expected_stats[ 1 ] );

    buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );
    assert_true( buffer != NULL );

    stats_reply = buffer->data;
    flow_stats = ( struct ofp_flow_stats * ) stats_reply->body;
    length = ( uint16_t ) ( stats_len * 2 );
    length = ( uint16_t ) ( length + offsetof( struct ofp_multipart_reply, body ) );

    assert_int_equal( ( int ) buffer->length, length );
    assert_int_equal( stats_reply->header.version, OFP_VERSION );
    assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
    assert_int_equal( ntohs( stats_reply->header.length ), length );
    assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_reply->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_reply->flags ), flags );

    list = expected_list;
    while ( list != NULL ) {
      struct ofp_flow_stats *next = flow_stats;
      struct ofp_flow_stats *expected_flow_stats = list->data;

      next = ( struct ofp_flow_stats * ) ( ( char * ) flow_stats + ntohs( flow_stats->length ) );
      ntoh_flow_stats( flow_stats, flow_stats );

      assert_memory_equal( flow_stats, expected_flow_stats, expected_flow_stats->length );

      flow_stats = next;
      list = list->next;
    }

    xfree( expected_stats[ 0 ] );
    xfree( expected_stats[ 1 ] );
    delete_list( expected_list );

    delete_oxm_match_testdata();
    delete_instruction_testdata();
    free_buffer( buffer );
  }

  // without match instruction
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    // ofp_match
    {
      expected_empty_ofp_match_len = sizeof( struct ofp_match );
      expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
      expected_empty_ofp_match->type = OFPMT_OXM;
      expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );
    }

    stats_len = ( uint16_t ) ( offsetof( struct ofp_flow_stats, match ) + expected_empty_ofp_match_len );

    expected_stats[ 0 ] = xcalloc( 1, stats_len );
    expected_stats[ 1 ] = xcalloc( 1, stats_len );

    expected_stats[ 0 ]->length = stats_len;
    expected_stats[ 0 ]->table_id = 1;
    expected_stats[ 0 ]->pad = 0;
    expected_stats[ 0 ]->duration_sec = 60;
    expected_stats[ 0 ]->duration_nsec = 10000;
    expected_stats[ 0 ]->priority = 1024;
    expected_stats[ 0 ]->idle_timeout = 60;
    expected_stats[ 0 ]->hard_timeout = 3600;
    expected_stats[ 0 ]->flags = OFPFF_NO_BYT_COUNTS;
    memset( expected_stats[ 0 ]->pad2, 0, sizeof( expected_stats[ 0 ]->pad2 ) );
    expected_stats[ 0 ]->cookie = 0x0102030405060708ULL;
    expected_stats[ 0 ]->packet_count = 1000;
    expected_stats[ 0 ]->byte_count = 100000;
    memcpy( &expected_stats[ 0 ]->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    memcpy( expected_stats[ 1 ], expected_stats[ 0 ], stats_len );
    expected_stats[ 1 ]->cookie = 0x0203040506070809ULL;

    create_list( &expected_list );
    append_to_tail( &expected_list, expected_stats[ 0 ] );
    append_to_tail( &expected_list, expected_stats[ 1 ] );

    buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );
    assert_true( buffer != NULL );

    stats_reply = buffer->data;
    flow_stats = ( struct ofp_flow_stats * ) stats_reply->body;
    length = ( uint16_t ) ( stats_len * 2 );
    length = ( uint16_t ) ( length + offsetof( struct ofp_multipart_reply, body ) );

    assert_int_equal( ( int ) buffer->length, length );
    assert_int_equal( stats_reply->header.version, OFP_VERSION );
    assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
    assert_int_equal( ntohs( stats_reply->header.length ), length );
    assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_reply->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_reply->flags ), flags );

    list = expected_list;
    while ( list != NULL ) {
      struct ofp_flow_stats *next = flow_stats;
      struct ofp_flow_stats *expected_flow_stats = list->data;

      next = ( struct ofp_flow_stats * ) ( ( char * ) flow_stats + ntohs( flow_stats->length ) );
      ntoh_flow_stats( flow_stats, flow_stats );

      assert_memory_equal( flow_stats, expected_flow_stats, expected_flow_stats->length );

      flow_stats = next;
      list = list->next;
    }

    xfree( expected_stats[ 0 ] );
    xfree( expected_stats[ 1 ] );
    xfree( expected_empty_ofp_match );
    delete_list( expected_list );

    free_buffer( buffer );
  }

  // without payload
  {
    buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, NULL );
    assert_true( buffer != NULL );

    stats_reply = buffer->data;
    flow_stats = ( struct ofp_flow_stats * ) stats_reply->body;
    length = ( uint16_t ) offsetof( struct ofp_multipart_reply, body );

    assert_int_equal( ( int ) buffer->length, length );
    assert_int_equal( stats_reply->header.version, OFP_VERSION );
    assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
    assert_int_equal( ntohs( stats_reply->header.length ), length );
    assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_reply->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_reply->flags ), flags );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * create_aggregate_multipart_request() test.
 ********************************************************************************/

static void
test_create_aggregate_multipart_request() {
  uint8_t table_id = 0xff;
  uint32_t out_port = 1;
  uint32_t out_group = 5;
  uint64_t cookie = 0x1234567890123456;
  uint64_t cookie_mask = 0x6543210987654321;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_aggregate_stats_request *ofp_aggregate_stats_request;
  uint16_t expected_length;
  uint64_t tmp;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  // with match
  {
    // ofp_match
    {
      create_oxm_match_testdata();

      oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
      memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
      oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
      memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

      match = create_oxm_matches();
      match->n_matches = 2;
      append_to_tail( &match->list, oxm1 );
      append_to_tail( &match->list, oxm2 );
    }

    buffer = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, match );
    assert_true( buffer != NULL );

    stats_request = ( struct ofp_multipart_request * ) buffer->data;
    expected_length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body ) + offsetof( struct ofp_aggregate_stats_request, match ) + expected_ofp_match_len );

    assert_int_equal( ( int ) buffer->length, expected_length );
    assert_int_equal( stats_request->header.version, OFP_VERSION );
    assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
    assert_int_equal( ntohs( stats_request->header.length ), expected_length );
    assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_request->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

    ofp_aggregate_stats_request = ( struct ofp_aggregate_stats_request * ) ( ( char * ) buffer->data
                         + offsetof( struct ofp_multipart_request, body ) );

    assert_int_equal( ofp_aggregate_stats_request->table_id, table_id );
    {
      void *pad = xmalloc( sizeof( ofp_aggregate_stats_request->pad ) );
      memset( pad, 0, sizeof( ofp_aggregate_stats_request->pad ) );
      assert_memory_equal( ofp_aggregate_stats_request->pad, pad, sizeof( ofp_aggregate_stats_request->pad ) );
      xfree( pad );
    }
    assert_int_equal( ntohl( ofp_aggregate_stats_request->out_port ), out_port );
    assert_int_equal( ntohl( ofp_aggregate_stats_request->out_group ), out_group );
    {
      void *pad = xmalloc( sizeof( ofp_aggregate_stats_request->pad2 ) );
      memset( pad, 0, sizeof( ofp_aggregate_stats_request->pad2 ) );
      assert_memory_equal( ofp_aggregate_stats_request->pad2, pad, sizeof( ofp_aggregate_stats_request->pad2 ) );
      xfree( pad );
    }
    tmp = ntohll( ofp_aggregate_stats_request->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    tmp = ntohll( ofp_aggregate_stats_request->cookie_mask );
    assert_memory_equal( &tmp, &cookie_mask, sizeof( cookie_mask ) );

    ntoh_match( &ofp_aggregate_stats_request->match, &ofp_aggregate_stats_request->match );
    assert_memory_equal( &ofp_aggregate_stats_request->match, expected_ofp_match, expected_ofp_match_len );

    delete_oxm_matches( match );
    delete_oxm_match_testdata();
    free_buffer( buffer );
  }

  // with match
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    // ofp_match
    {
      expected_empty_ofp_match_len = sizeof( struct ofp_match );
      expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
      expected_empty_ofp_match->type = OFPMT_OXM;
      expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );
    }

    buffer = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, NULL );
    assert_true( buffer != NULL );

    stats_request = ( struct ofp_multipart_request * ) buffer->data;
    expected_length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body ) + offsetof( struct ofp_aggregate_stats_request, match ) + expected_empty_ofp_match_len );

    assert_int_equal( ( int ) buffer->length, expected_length );
    assert_int_equal( stats_request->header.version, OFP_VERSION );
    assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
    assert_int_equal( ntohs( stats_request->header.length ), expected_length );
    assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_request->type ), OFPMP_FLOW );
    assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

    ofp_aggregate_stats_request = ( struct ofp_aggregate_stats_request * ) ( ( char * ) buffer->data
                         + offsetof( struct ofp_multipart_request, body ) );

    assert_int_equal( ofp_aggregate_stats_request->table_id, table_id );
    {
      void *pad = xmalloc( sizeof( ofp_aggregate_stats_request->pad ) );
      memset( pad, 0, sizeof( ofp_aggregate_stats_request->pad ) );
      assert_memory_equal( ofp_aggregate_stats_request->pad, pad, sizeof( ofp_aggregate_stats_request->pad ) );
      xfree( pad );
    }
    assert_int_equal( ntohl( ofp_aggregate_stats_request->out_port ), out_port );
    assert_int_equal( ntohl( ofp_aggregate_stats_request->out_group ), out_group );
    {
      void *pad = xmalloc( sizeof( ofp_aggregate_stats_request->pad2 ) );
      memset( pad, 0, sizeof( ofp_aggregate_stats_request->pad2 ) );
      assert_memory_equal( ofp_aggregate_stats_request->pad2, pad, sizeof( ofp_aggregate_stats_request->pad2 ) );
      xfree( pad );
    }
    tmp = ntohll( ofp_aggregate_stats_request->cookie );
    assert_memory_equal( &tmp, &cookie, sizeof( cookie ) );
    tmp = ntohll( ofp_aggregate_stats_request->cookie_mask );
    assert_memory_equal( &tmp, &cookie_mask, sizeof( cookie_mask ) );

    ntoh_match( &ofp_aggregate_stats_request->match, &ofp_aggregate_stats_request->match );
    assert_memory_equal( &ofp_aggregate_stats_request->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    xfree( expected_empty_ofp_match );
    free_buffer( buffer );
  }
}


/********************************************************************************
 * create_aggregate_multipart_reply() test.
 ********************************************************************************/

static void
test_create_aggregate_multipart_reply() {
  uint32_t flow_count = 1000;
  uint64_t packet_count = 1000;
  uint64_t byte_count = 10000;
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_aggregate_stats_reply *aggregate_stats_reply;
  uint16_t length;
  uint64_t tmp;

  buffer = create_aggregate_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, packet_count, byte_count, flow_count );
  assert_true( buffer != NULL );

  stats_reply = ( struct ofp_multipart_reply * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body ) + sizeof( struct ofp_aggregate_stats_reply ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_AGGREGATE );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  aggregate_stats_reply = ( struct ofp_aggregate_stats_reply * ) stats_reply->body;

  tmp = ntohll( aggregate_stats_reply->packet_count );
  assert_memory_equal( &tmp, &packet_count, sizeof( packet_count ) );
  tmp = ntohll( aggregate_stats_reply->byte_count );
  assert_memory_equal( &tmp, &byte_count, sizeof( byte_count ) );
  assert_int_equal( ( int ) ntohl( aggregate_stats_reply->flow_count ), ( int ) flow_count );

  free_buffer( buffer );
}


/********************************************************************************
 * create_table_multipart_request() test.
 ********************************************************************************/

static void
test_create_table_multipart_request() {
  buffer *buffer;
  struct ofp_multipart_request *stats_request;

  buffer = create_table_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );
  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_multipart_request ) );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), sizeof( struct ofp_multipart_request ) );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_TABLE );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * create_table_multipart_reply() test.
 ********************************************************************************/

static void
test_create_table_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  uint16_t stats_len;
  buffer *buffer;
  list_element *expected_list, *list;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_table_stats *stats[ 2 ], *table_stats, *next;
  uint16_t length = 0;

  stats_len = sizeof( struct ofp_table_stats );

  stats[ 0 ] = xcalloc( 1, stats_len );
  stats[ 1 ] = xcalloc( 1, stats_len );

  stats[ 0 ]->table_id = 1;
  stats[ 0 ]->active_count = 1000;
  stats[ 0 ]->lookup_count = 100000;
  stats[ 0 ]->matched_count = 10000;

  memcpy( stats[ 1 ], stats[ 0 ], stats_len );
  stats[ 1 ]->table_id = 2;

  create_list( &expected_list );
  append_to_tail( &expected_list, stats[ 0 ] );
  append_to_tail( &expected_list, stats[ 1 ] );

  buffer = create_table_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );
  assert_true( buffer != NULL );

  stats_reply = ( struct ofp_multipart_reply * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body ) + sizeof( struct ofp_table_stats ) * 2 );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_TABLE );
  assert_int_equal( ntohs( stats_reply->flags ), flags );

  table_stats = ( struct ofp_table_stats * ) stats_reply->body;

  list = expected_list;
  while ( list != NULL ) {
    struct ofp_table_stats *expected_table_stats = ( struct ofp_table_stats * ) list->data;

    next = ( struct ofp_table_stats * ) ( ( char * ) table_stats + sizeof( struct ofp_table_stats ) );
    ntoh_table_stats( table_stats, table_stats );

    assert_memory_equal( table_stats, expected_table_stats, sizeof( struct ofp_table_stats ) );

    table_stats = next;
    list = list->next;
  }

  xfree( stats[ 0 ] );
  xfree( stats[ 1 ] );
  delete_list( expected_list );
  free_buffer( buffer );
}


/********************************************************************************
 * create_port_multipart_request() test.
 ********************************************************************************/

static void
test_create_port_multipart_request() {
  uint32_t port_no = 1;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_port_stats_request *port_stats_request;
  uint16_t length;

  buffer = create_port_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, port_no );
  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body )
           + sizeof( struct ofp_port_stats_request ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_PORT_STATS );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  port_stats_request = ( struct ofp_port_stats_request * ) ( ( char * ) buffer->data
                       + offsetof( struct ofp_multipart_request, body ) );

  assert_int_equal( ntohl( port_stats_request->port_no ), port_no );

  {
    void *pad = xmalloc( sizeof( port_stats_request->pad ) );
    memset( pad, 0, sizeof( port_stats_request->pad ) );
    assert_memory_equal( port_stats_request->pad, pad, sizeof( port_stats_request->pad ) );
    xfree( pad );
  }

  free_buffer( buffer );
}


/********************************************************************************
 * create_port_multipart_reply() test.
 ********************************************************************************/

static void
test_create_port_multipart_reply() {
  void *expected_data;
  uint16_t flags = OFPMPF_REPLY_MORE;
  uint16_t stats_len;
  buffer *buffer;
  list_element *expected_list, *list;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_port_stats *stats[ 2 ], *port_stats, *next;
  uint16_t length = 0;

  stats_len = sizeof( struct ofp_port_stats );

  stats[ 0 ] = xcalloc( 1, stats_len );
  stats[ 1 ] = xcalloc( 1, stats_len );

  stats[ 0 ]->port_no = 1;
  stats[ 0 ]->rx_packets = 10000;
  stats[ 0 ]->tx_packets = 20000;
  stats[ 0 ]->rx_bytes = 30000;
  stats[ 0 ]->tx_bytes = 40000;
  stats[ 0 ]->rx_dropped = 50000;
  stats[ 0 ]->tx_dropped = 60000;
  stats[ 0 ]->rx_errors = 70000;
  stats[ 0 ]->tx_errors = 80000;
  stats[ 0 ]->rx_frame_err = 1;
  stats[ 0 ]->rx_over_err = 2;
  stats[ 0 ]->rx_crc_err = 1;
  stats[ 0 ]->collisions = 3;

  memcpy( stats[ 1 ], stats[ 0 ], stats_len );
  stats[ 1 ]->port_no = 2;

  create_list( &expected_list );
  append_to_tail( &expected_list, stats[ 0 ] );
  append_to_tail( &expected_list, stats[ 1 ] );

  expected_data = xcalloc( 1, ( size_t ) ( stats_len * 2 ) );
  memcpy( expected_data, stats[ 0 ], stats_len );
  memcpy( ( char * ) expected_data + stats_len, stats[ 1 ], stats_len );

  buffer = create_port_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
           + sizeof( struct ofp_port_stats ) * 2 );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_PORT_STATS );
  assert_int_equal( ntohs( stats_reply->flags ), flags );

  port_stats = ( struct ofp_port_stats * ) stats_reply->body;

  list = expected_list;
  while ( list != NULL ) {
    struct ofp_port_stats *expected_port_stats = ( struct ofp_port_stats * ) list->data;

    next = ( struct ofp_port_stats * ) ( ( char * ) port_stats + sizeof( struct ofp_port_stats ) );
    ntoh_port_stats( port_stats, port_stats );

    assert_memory_equal( port_stats, expected_port_stats, sizeof( struct ofp_port_stats ) );

    port_stats = next;
    list = list->next;
  }

  xfree( stats[ 0 ] );
  xfree( stats[ 1 ] );
  xfree( expected_data );
  delete_list( expected_list );
  free_buffer( buffer );
}


/********************************************************************************
 * create_queue_multipart_request() test.
 ********************************************************************************/

static void
test_create_queue_multipart_request() {
  uint32_t port_no = 1;
  uint32_t queue_id = 10;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_queue_stats_request *queue_stats_request;
  uint16_t length;

  buffer = create_queue_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, port_no, queue_id );
  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body )
           + sizeof( struct ofp_queue_stats_request ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_QUEUE );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  queue_stats_request = ( struct ofp_queue_stats_request * ) ( ( char * ) buffer->data
                        + offsetof( struct ofp_multipart_request, body ) );

  assert_int_equal( ntohl( queue_stats_request->port_no ), port_no );
  assert_int_equal( ntohl( queue_stats_request->queue_id ), queue_id );

  free_buffer( buffer );
}


/********************************************************************************
 * create_queue_multipart_reply() test.
 ********************************************************************************/

static void
test_create_queue_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *list, *l;
  uint16_t stats_len;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_queue_stats *stats[ 2 ], *queue_stats;
  uint16_t n_queues = 2;
  uint16_t length;
  buffer *buffer;

  stats_len = sizeof( struct ofp_queue_stats );

  stats[ 0 ] = xcalloc( 1, stats_len );
  stats[ 1 ] = xcalloc( 1, stats_len );

  stats[ 0 ]->port_no = 1;
  stats[ 0 ]->queue_id = 2;
  stats[ 0 ]->tx_bytes = 100000;
  stats[ 0 ]->tx_packets = 60000;
  stats[ 0 ]->tx_errors = 80;
  stats[ 0 ]->duration_sec = 0x12345678;
  stats[ 0 ]->duration_nsec = 0x87654321;

  memcpy( stats[ 1 ], stats[ 0 ], stats_len );
  stats[ 1 ]->queue_id = 3;

  create_list( &list );
  append_to_tail( &list, stats[ 0 ] );
  append_to_tail( &list, stats[ 1 ] );

  buffer = create_queue_multipart_reply( MY_TRANSACTION_ID, flags, list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
           + sizeof( struct ofp_queue_stats ) * n_queues );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_QUEUE );
  assert_int_equal( ntohs( stats_reply->flags ), flags );

  queue_stats = ( struct ofp_queue_stats * ) stats_reply->body;
  l = list;
  while ( list != NULL ) {
    void *next = ( char * ) queue_stats + stats_len;
    ntoh_queue_stats( queue_stats, queue_stats );

    assert_memory_equal( queue_stats, list->data, stats_len );

    list = list->next;
    queue_stats = next;
  }

  xfree( stats[ 0 ] );
  xfree( stats[ 1 ] );
  delete_list( l );
  free_buffer( buffer );
}


/********************************************************************************
 * create_barrier_request() test.
 ********************************************************************************/

static void
test_create_barrier_request() {
  buffer *buffer;
  struct ofp_header *barrier_request;

  buffer = create_barrier_request( MY_TRANSACTION_ID );

  assert_true( buffer != NULL );

  barrier_request = ( struct ofp_header * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_header ) );
  assert_int_equal( barrier_request->version, OFP_VERSION );
  assert_int_equal( barrier_request->type, OFPT_BARRIER_REQUEST );
  assert_int_equal( ntohs( barrier_request->length ), sizeof( struct ofp_header ) );
  assert_int_equal( ( int ) ntohl( barrier_request->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


/********************************************************************************
 * create_barrier_reply() test.
 ********************************************************************************/

static void
test_create_barrier_reply() {
  buffer *buffer;
  struct ofp_header *barrier_reply;

  buffer = create_barrier_reply( MY_TRANSACTION_ID );
  assert_true( buffer != NULL );

  barrier_reply = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_header ) );
  assert_int_equal( barrier_reply->version, OFP_VERSION );
  assert_int_equal( barrier_reply->type, OFPT_BARRIER_REPLY );
  assert_int_equal( ntohs( barrier_reply->length ), sizeof( struct ofp_header ) );
  assert_int_equal( ( int ) ntohl( barrier_reply->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


/********************************************************************************
 * create_queue_get_config_request() test.
 ********************************************************************************/

static void
test_create_queue_get_config_request() {
  uint32_t port = 1;
  buffer *buffer;
  struct ofp_queue_get_config_request *queue_get_config_request;

  buffer = create_queue_get_config_request( MY_TRANSACTION_ID, port );

  assert_true( buffer != NULL );

  queue_get_config_request = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_queue_get_config_request ) );
  assert_int_equal( queue_get_config_request->header.version, OFP_VERSION );
  assert_int_equal( queue_get_config_request->header.type, OFPT_QUEUE_GET_CONFIG_REQUEST );
  assert_int_equal( ntohs( queue_get_config_request->header.length ), sizeof( struct ofp_queue_get_config_request ) );
  assert_int_equal( ( int ) ntohl( queue_get_config_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( queue_get_config_request->port ), ( int ) port );

  {
    void *pad = xmalloc( sizeof( queue_get_config_request->pad ) );
    memset( pad, 0, sizeof( queue_get_config_request->pad ) );
    assert_memory_equal( queue_get_config_request->pad, pad, sizeof( queue_get_config_request->pad ) );
    xfree( pad );
  }

  free_buffer( buffer );
}


/********************************************************************************
 * create_queue_get_config_reply() test.
 ********************************************************************************/

static void
test_create_queue_get_config_reply() {
  size_t queue_0len, queue_1len;
  uint32_t port = 1;
  uint8_t expected_pad[ 6 ];
  list_element *list, *l;
  buffer *buffer;
  struct ofp_queue_get_config_reply *queue_get_config_reply;
  struct ofp_packet_queue *queue[ 2 ], *packet_queue;
  struct ofp_queue_prop_min_rate *prop_min_header;
  struct ofp_queue_prop_max_rate *prop_max_header;
  uint16_t queues_length;
  uint16_t length;

  queue_0len = offsetof( struct ofp_packet_queue, properties ) + sizeof( struct ofp_queue_prop_min_rate );
  queue_1len = offsetof( struct ofp_packet_queue, properties ) + sizeof( struct ofp_queue_prop_max_rate );
  queue[ 0 ] = xcalloc( 1, queue_0len );
  queue[ 1 ] = xcalloc( 1, queue_1len );

  queue[ 0 ]->queue_id = 1;
  queue[ 0 ]->port = 0x01020304;
  queue[ 0 ]->len = ( uint16_t ) queue_0len;
  prop_min_header = ( struct ofp_queue_prop_min_rate * ) queue[ 0 ]->properties;
  prop_min_header->prop_header.property = OFPQT_MIN_RATE;
  prop_min_header->prop_header.len = sizeof( struct ofp_queue_prop_min_rate );
  prop_min_header->rate = 0x1122;

  queue[ 1 ]->queue_id = 2;
  queue[ 1 ]->port = 0x05060708;
  queue[ 1 ]->len = ( uint16_t ) queue_1len;
  prop_max_header = ( struct ofp_queue_prop_max_rate * ) queue[ 1 ]->properties;
  prop_max_header->prop_header.property = OFPQT_MAX_RATE;
  prop_max_header->prop_header.len = sizeof( struct ofp_queue_prop_max_rate );
  prop_max_header->rate = 0x3344;

  create_list( &list );
  append_to_tail( &list, queue[ 0 ] );
  append_to_tail( &list, queue[ 1 ] );

  buffer = create_queue_get_config_reply( MY_TRANSACTION_ID, port, list );
  assert_true( buffer != NULL );

  queue_get_config_reply = buffer->data;

  queues_length = ( uint16_t ) ( queue[ 0 ]->len + queue[ 1 ]->len );
  length = ( uint16_t ) ( offsetof( struct ofp_queue_get_config_reply, queues ) + queues_length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( queue_get_config_reply->header.version, OFP_VERSION );
  assert_int_equal( queue_get_config_reply->header.type, OFPT_QUEUE_GET_CONFIG_REPLY );
  assert_int_equal( ntohs( queue_get_config_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( queue_get_config_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  memset( &expected_pad, 0, sizeof( expected_pad ) );
  assert_int_equal( ntohl( queue_get_config_reply->port ), port );
  assert_memory_equal( queue_get_config_reply->pad, expected_pad, sizeof( expected_pad ) );

  l = list;
  packet_queue = queue_get_config_reply->queues;
  while ( list != NULL ) {
    ntoh_packet_queue( packet_queue, packet_queue );
    void *next = ( char * ) packet_queue + packet_queue->len;
    struct ofp_packet_queue *expected_packet_queue = ( struct ofp_packet_queue * ) list->data;
    assert_memory_equal( packet_queue, expected_packet_queue, expected_packet_queue->len );

    list = list->next;
    packet_queue = next;
  }

  xfree( queue[ 0 ] );
  xfree( queue[ 1 ] );
  delete_list( l );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_group_multipart_request() tests.
 ********************************************************************************/

static void
test_create_group_multipart_request() {
  uint32_t group_id = 10;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_group_stats_request *group_stats_request;
  uint16_t length;

  buffer = create_group_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, group_id );
  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body )
           + sizeof( struct ofp_group_stats_request ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_GROUP );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  group_stats_request = ( struct ofp_group_stats_request * ) ( ( char * ) buffer->data
                        + offsetof( struct ofp_multipart_request, body ) );

  assert_int_equal( ntohl( group_stats_request->group_id ), group_id );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_group_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_group_multipart_reply() {
  size_t grpsts_0len, grpsts_1len;
  list_element *list, *l;
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_group_stats *grpsts[ 2 ], *group_stats;
  struct ofp_bucket_counter *bktcnt;
  uint16_t grpstss_length;
  uint16_t length;

  grpsts_0len = offsetof( struct ofp_group_stats, bucket_stats ) + sizeof( struct ofp_bucket_counter );
  grpsts_1len = offsetof( struct ofp_group_stats, bucket_stats ) + sizeof( struct ofp_bucket_counter );
  grpsts[ 0 ] = xcalloc( 1, grpsts_0len );
  grpsts[ 1 ] = xcalloc( 1, grpsts_1len );

  grpsts[ 0 ]->length = ( uint16_t ) grpsts_0len;
  grpsts[ 0 ]->group_id = 1;
  grpsts[ 0 ]->ref_count = 2;
  grpsts[ 0 ]->packet_count = 3;
  grpsts[ 0 ]->byte_count = 4;
  grpsts[ 0 ]->duration_sec = 5;
  grpsts[ 0 ]->duration_nsec = 6;
  bktcnt = ( struct ofp_bucket_counter * ) grpsts[ 0 ]->bucket_stats;
  bktcnt->packet_count = 7;
  bktcnt->byte_count = 8;

  grpsts[ 1 ]->length = ( uint16_t ) grpsts_1len;
  grpsts[ 1 ]->group_id = 11;
  grpsts[ 1 ]->ref_count = 12;
  grpsts[ 1 ]->packet_count = 13;
  grpsts[ 1 ]->byte_count = 14;
  grpsts[ 1 ]->duration_sec = 15;
  grpsts[ 1 ]->duration_nsec = 16;
  bktcnt = ( struct ofp_bucket_counter * ) grpsts[ 1 ]->bucket_stats;
  bktcnt->packet_count = 17;
  bktcnt->byte_count = 18;

  create_list( &list );
  append_to_tail( &list, grpsts[ 0 ] );
  append_to_tail( &list, grpsts[ 1 ] );

  buffer = create_group_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;

  grpstss_length = ( uint16_t ) ( grpsts[ 0 ]->length + grpsts[ 1 ]->length );
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body ) + grpstss_length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_GROUP );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  l = list;
  group_stats = ( struct ofp_group_stats * ) stats_reply->body;
  while ( list != NULL ) {
    struct ofp_group_stats *expected_group_stats = ( struct ofp_group_stats * ) list->data;

    void *next = ( char * ) group_stats + expected_group_stats->length;
    ntoh_group_stats( group_stats, group_stats );
    assert_memory_equal( group_stats, expected_group_stats, expected_group_stats->length );

    list = list->next;
    group_stats = next;
  }

  xfree( grpsts[ 0 ] );
  xfree( grpsts[ 1 ] );
  delete_list( l );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_group_desc_multipart_request() tests.
 ********************************************************************************/

static void
test_create_group_desc_multipart_request() {
  buffer *buffer;
  struct ofp_multipart_request *stats_request;

  buffer = create_group_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_multipart_request ) );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), sizeof( struct ofp_multipart_request ) );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_GROUP_DESC );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_group_desc_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_group_desc_multipart_reply() {
  uint16_t grpdsc_len[2];
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_group_desc_stats *grpdsc;
  list_element *expected_list, *list;
  struct ofp_group_desc_stats *dsc1, *dsc2;
  uint16_t expected_msglen;

  create_bucket_testdata();

  grpdsc_len[0] = ( uint16_t ) ( offsetof( struct ofp_group_desc_stats, buckets ) + bucket_testdata_len[0] );
  dsc1 = xcalloc( 1, grpdsc_len[0] );
  dsc1->length = grpdsc_len[0];
  dsc1->type = OFPGT_SELECT;
  dsc1->group_id = 0x11223344;
  memcpy( dsc1->buckets, bucket_testdata[0], bucket_testdata_len[0] );

  grpdsc_len[1] = ( uint16_t ) ( offsetof( struct ofp_group_desc_stats, buckets ) + bucket_testdata_len[1] );
  dsc2 = xcalloc( 1, grpdsc_len[1] );
  dsc2->length = grpdsc_len[1];
  dsc2->type = OFPGT_INDIRECT;
  dsc2->group_id = 0x55667788;
  memcpy( dsc2->buckets, bucket_testdata[1], bucket_testdata_len[1] );

  create_list( &expected_list );
  append_to_tail( &expected_list, dsc1 );
  append_to_tail( &expected_list, dsc2 );

  buffer = create_group_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;

  expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                                  + grpdsc_len[0]
                                  + grpdsc_len[1] );

  assert_int_equal( ( int ) buffer->length, expected_msglen );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_GROUP_DESC );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  list = expected_list;
  grpdsc = ( struct ofp_group_desc_stats * ) stats_reply->body;
  while ( list != NULL ) {
    struct ofp_group_desc_stats *expected_group_desc = ( struct ofp_group_desc_stats * ) list->data;

    void *next = ( char * ) grpdsc + expected_group_desc->length;
    ntoh_group_desc_stats( grpdsc, grpdsc );
    assert_memory_equal( grpdsc, expected_group_desc, expected_group_desc->length );

    list = list->next;
    grpdsc = next;
  }

  delete_bucket_testdata();
  xfree( dsc1 );
  xfree( dsc2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_group_features_multipart_request() tests.
 ********************************************************************************/

static void
test_create_group_features_multipart_request() {
  buffer *buffer;
  struct ofp_multipart_request *stats_request;

  buffer = create_group_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_multipart_request ) );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), sizeof( struct ofp_multipart_request ) );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_GROUP_FEATURES );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_group_features_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_group_features_multipart_reply() {
  uint16_t grpftr_len;
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_group_features *grpftr;
  uint16_t expected_msglen;

  grpftr_len = sizeof( struct ofp_group_features );
  grpftr = xcalloc( 1, grpftr_len );
  grpftr->types = OFPGT_SELECT;
  grpftr->capabilities = OFPGFC_CHAINING;
  grpftr->max_groups[0] = 1;
  grpftr->max_groups[1] = 2;
  grpftr->max_groups[2] = 3;
  grpftr->max_groups[3] = 4;
  grpftr->actions[0] = 5;
  grpftr->actions[1] = 6;
  grpftr->actions[2] = 7;
  grpftr->actions[3] = 8;
  struct ofp_group_features *expected_group_desc = grpftr;

  buffer = create_group_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, grpftr->types,
    grpftr->capabilities, grpftr->max_groups, grpftr->actions );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;

  expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                                  + grpftr_len );

  assert_int_equal( ( int ) buffer->length, expected_msglen );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_GROUP_FEATURES );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  grpftr = ( struct ofp_group_features * ) stats_reply->body;

  ntoh_group_features_stats( grpftr, grpftr );
  assert_memory_equal( grpftr, expected_group_desc, grpftr_len );

  xfree( expected_group_desc );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_multipart_request() tests.
 ********************************************************************************/

static void
test_create_meter_multipart_request() {
  uint32_t meter_id = 10;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_meter_multipart_request *meter_multipart_request;
  uint16_t length;

  buffer = create_meter_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, meter_id );
  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body )
           + sizeof( struct ofp_meter_multipart_request ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_METER );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  meter_multipart_request = ( struct ofp_meter_multipart_request * ) ( ( char * ) buffer->data
                        + offsetof( struct ofp_multipart_request, body ) );

  assert_int_equal( ntohl( meter_multipart_request->meter_id ), meter_id );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_meter_multipart_reply() {
  uint16_t mtrsts_len[2];
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_meter_stats *mtrsts;
  list_element *expected_list, *list;
  struct ofp_meter_stats *mtr1, *mtr2;
  struct ofp_meter_band_stats *mtrbnd;
  uint16_t expected_msglen;

  mtrsts_len[0] = ( uint16_t ) ( offsetof( struct ofp_meter_stats, band_stats ) + sizeof( struct ofp_meter_band_stats ) );
  mtr1 = xcalloc( 1, mtrsts_len[0] );
  mtr1->meter_id = 0xaabbccdd;
  mtr1->len = mtrsts_len[0];
  mtr1->flow_count = 1;
  mtr1->packet_in_count = 2;
  mtr1->byte_in_count = 3;
  mtr1->duration_sec = 4;
  mtr1->duration_nsec = 5;
  mtrbnd = mtr1->band_stats;
  mtrbnd->packet_band_count = 0x11223344;
  mtrbnd->byte_band_count = 0x55667788;

  mtrsts_len[1] = ( uint16_t ) ( offsetof( struct ofp_meter_stats, band_stats ) + sizeof( struct ofp_meter_band_stats ) );
  mtr2 = xcalloc( 1, mtrsts_len[1] );
  mtr2->meter_id = 0x12345566;
  mtr2->len = mtrsts_len[1];
  mtr2->flow_count = 1;
  mtr2->packet_in_count = 2;
  mtr2->byte_in_count = 3;
  mtr2->duration_sec = 4;
  mtr2->duration_nsec = 5;
  mtrbnd = mtr2->band_stats;
  mtrbnd->packet_band_count = 0x11223344;
  mtrbnd->byte_band_count = 0x55667788;

  create_list( &expected_list );
  append_to_tail( &expected_list, mtr1 );
  append_to_tail( &expected_list, mtr2 );

  buffer = create_meter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;

  expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                                  + mtrsts_len[0]
                                  + mtrsts_len[1] );

  assert_int_equal( ( int ) buffer->length, expected_msglen );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_METER );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  list = expected_list;
  mtrsts = ( struct ofp_meter_stats * ) stats_reply->body;
  while ( list != NULL ) {
    struct ofp_meter_stats *expected_meter_stats = ( struct ofp_meter_stats * ) list->data;

    void *next = ( char * ) mtrsts + expected_meter_stats->len;
    ntoh_meter_stats( mtrsts, mtrsts );
    assert_memory_equal( mtrsts, expected_meter_stats, expected_meter_stats->len );

    list = list->next;
    mtrsts = next;
  }

  xfree( mtr1 );
  xfree( mtr2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_config_multipart_request() tests.
 ********************************************************************************/

static void
test_create_meter_config_multipart_request() {
  uint32_t meter_id = 10;
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_meter_multipart_request *meter_config_multipart_request;
  uint16_t length;

  buffer = create_meter_config_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, meter_id );
  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body )
           + sizeof( struct ofp_meter_multipart_request ) );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_METER_CONFIG );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  meter_config_multipart_request = ( struct ofp_meter_multipart_request * ) ( ( char * ) buffer->data
                        + offsetof( struct ofp_multipart_request, body ) );

  assert_int_equal( ntohl( meter_config_multipart_request->meter_id ), meter_id );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_config_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_meter_config_multipart_reply() {
  uint16_t mtrcfg_len[2];
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_meter_config *mtrcfg;
  list_element *expected_list, *list;
  struct ofp_meter_config *mtr1, *mtr2;
  struct ofp_meter_band_drop *mtrbnd;
  uint16_t expected_msglen;

  mtrcfg_len[0] = ( uint16_t ) ( offsetof( struct ofp_meter_config, bands ) + sizeof( struct ofp_meter_band_drop ) );
  mtr1 = xcalloc( 1, mtrcfg_len[0] );
  mtr1->length = mtrcfg_len[0];
  mtr1->flags = OFPMC_MODIFY;
  mtr1->meter_id = 1;
  mtrbnd = ( struct ofp_meter_band_drop * ) mtr1->bands;
  mtrbnd->type = OFPMBT_DROP;
  mtrbnd->len = sizeof( struct ofp_meter_band_drop );
  mtrbnd->rate = 0x11223344;
  mtrbnd->burst_size = 0x55667788;

  mtrcfg_len[1] = ( uint16_t ) ( offsetof( struct ofp_meter_config, bands ) + sizeof( struct ofp_meter_band_drop ) );
  mtr2 = xcalloc( 1, mtrcfg_len[1] );
  mtr2->length = mtrcfg_len[1];
  mtr2->flags = OFPMC_DELETE;
  mtr2->meter_id = 1;
  mtrbnd = ( struct ofp_meter_band_drop * ) mtr2->bands;
  mtrbnd->type = OFPMBT_DROP;
  mtrbnd->len = sizeof( struct ofp_meter_band_drop );
  mtrbnd->rate = 0x12345555;
  mtrbnd->burst_size = 0x56789999;

  create_list( &expected_list );
  append_to_tail( &expected_list, mtr1 );
  append_to_tail( &expected_list, mtr2 );

  buffer = create_meter_config_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;

  expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                                  + mtrcfg_len[0]
                                  + mtrcfg_len[1] );

  assert_int_equal( ( int ) buffer->length, expected_msglen );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_METER_CONFIG );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  list = expected_list;
  mtrcfg = ( struct ofp_meter_config * ) stats_reply->body;
  while ( list != NULL ) {
    struct ofp_meter_config *expected_meter_stats = ( struct ofp_meter_config * ) list->data;

    void *next = ( char * ) mtrcfg + expected_meter_stats->length;
    ntoh_meter_config( mtrcfg, mtrcfg );
    assert_memory_equal( mtrcfg, expected_meter_stats, expected_meter_stats->length );

    list = list->next;
    mtrcfg = next;
  }

  xfree( mtr1 );
  xfree( mtr2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_features_multipart_request() tests.
 ********************************************************************************/

static void
test_create_meter_features_multipart_request() {
  buffer *buffer;
  struct ofp_multipart_request *stats_request;

  buffer = create_meter_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_multipart_request ) );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), sizeof( struct ofp_multipart_request ) );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_METER_FEATURES );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_features_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_meter_features_multipart_reply() {
  uint16_t mtrftr_len;
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_meter_features *mtrftr;
  uint16_t expected_msglen;

  mtrftr_len = sizeof( struct ofp_meter_features );
  mtrftr = xcalloc( 1, mtrftr_len );
  mtrftr->max_meter = 0x12345678;
  mtrftr->band_types = OFPMBT_DSCP_REMARK;
  mtrftr->capabilities = OFPMF_STATS;
  mtrftr->max_bands = 1;
  mtrftr->max_color = 2;
  struct ofp_meter_features *expected_meter_feature = mtrftr;

  buffer = create_meter_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, mtrftr->max_meter,
    mtrftr->band_types, mtrftr->capabilities, mtrftr->max_bands, mtrftr->max_color );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;

  expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                                  + mtrftr_len );

  assert_int_equal( ( int ) buffer->length, expected_msglen );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_METER_FEATURES );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  mtrftr = ( struct ofp_meter_features * ) stats_reply->body;

  ntoh_meter_features( mtrftr, mtrftr );
  assert_memory_equal( mtrftr, expected_meter_feature, mtrftr_len );

  xfree( expected_meter_feature );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_table_features_multipart_request() tests.
 ********************************************************************************/

static void
test_create_table_features_multipart_request() {
  uint16_t tblftr_len[2];
  buffer *buffer;
  struct ofp_multipart_request *stats_request;
  struct ofp_table_features *tblftr;
  list_element *expected_list, *list;
  struct ofp_table_features *ftr1, *ftr2;
  struct ofp_table_feature_prop_next_tables *nxttbl;
  uint16_t prop_len, prop_pad_len;
  uint16_t expected_msglen;

  // with table_features 
  {
    prop_len = ( uint16_t ) ( sizeof( struct ofp_table_feature_prop_next_tables ) + sizeof( uint8_t ) * 2 );
    prop_pad_len = ( uint16_t ) ( prop_len + PADLEN_TO_64( prop_len ) );

    tblftr_len[0] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr1 = xcalloc( 1, tblftr_len[0] );
    ftr1->length = tblftr_len[0];
    ftr1->table_id = 1;
    memcpy( ftr1->name, "table 1", sizeof( ftr1->name ) );
    ftr1->metadata_match = 0x1234567890123456;
    ftr1->metadata_write = 0x6543210987654321;
    ftr1->config = 11011;
    ftr1->max_entries = 10;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr1 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    tblftr_len[1] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr2 = xcalloc( 1, tblftr_len[1] );
    ftr2->length = tblftr_len[1];
    ftr2->table_id = 2;
    memcpy( ftr2->name, "table 2", sizeof( ftr2->name ) );
    ftr2->metadata_match = 0x1122334455667788;
    ftr2->metadata_write = 0x99AABBCCDDEEFF00;
    ftr2->config = 22022;
    ftr2->max_entries = 20;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr2 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES_MISS;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    create_list( &expected_list );
    append_to_tail( &expected_list, ftr1 );
    append_to_tail( &expected_list, ftr2 );

    buffer = create_table_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, expected_list );
    assert_true( buffer != NULL );

    stats_request = buffer->data;

    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_request, body )
                                    + tblftr_len[0]
                                    + tblftr_len[1] );

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( stats_request->header.version, OFP_VERSION );
    assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
    assert_int_equal( ntohs( stats_request->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_request->type ), OFPMP_TABLE_FEATURES );
    assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

    list = expected_list;
    tblftr = ( struct ofp_table_features * ) stats_request->body;
    while ( list != NULL ) {
      struct ofp_table_features *expected_meter_stats = ( struct ofp_table_features * ) list->data;

      void *next = ( char * ) tblftr + expected_meter_stats->length;
      ntoh_table_features( tblftr, tblftr );
      assert_memory_equal( tblftr, expected_meter_stats, expected_meter_stats->length );

      list = list->next;
      tblftr = next;
    }

    xfree( ftr1 );
    xfree( ftr2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  // without table_features 
  {
    buffer = create_table_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, NULL );
    assert_true( buffer != NULL );

    stats_request = buffer->data;

    expected_msglen = ( uint16_t ) offsetof( struct ofp_multipart_request, body );

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( stats_request->header.version, OFP_VERSION );
    assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
    assert_int_equal( ntohs( stats_request->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_request->type ), OFPMP_TABLE_FEATURES );
    assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * test_create_table_features_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_table_features_multipart_reply() {
  uint16_t tblftr_len[2];
  buffer *buffer;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_table_features *tblftr;
  list_element *expected_list, *list;
  struct ofp_table_features *ftr1, *ftr2;
  struct ofp_table_feature_prop_next_tables *nxttbl;
  uint16_t prop_len, prop_pad_len;
  uint16_t expected_msglen;

  // with table_features
  {
    prop_len = ( uint16_t ) ( sizeof( struct ofp_table_feature_prop_next_tables ) + sizeof( uint8_t ) * 2 );
    prop_pad_len = ( uint16_t ) ( prop_len + PADLEN_TO_64( prop_len ) );

    tblftr_len[0] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr1 = xcalloc( 1, tblftr_len[0] );
    ftr1->length = tblftr_len[0];
    ftr1->table_id = 1;
    memcpy( ftr1->name, "table 1", sizeof( ftr1->name ) );
    ftr1->metadata_match = 0x1234567890123456;
    ftr1->metadata_write = 0x6543210987654321;
    ftr1->config = 11011;
    ftr1->max_entries = 10;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr1 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    tblftr_len[1] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr2 = xcalloc( 1, tblftr_len[1] );
    ftr2->length = tblftr_len[1];
    ftr2->table_id = 2;
    memcpy( ftr2->name, "table 2", sizeof( ftr2->name ) );
    ftr2->metadata_match = 0x1122334455667788;
    ftr2->metadata_write = 0x99AABBCCDDEEFF00;
    ftr2->config = 22022;
    ftr2->max_entries = 20;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr2 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES_MISS;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    create_list( &expected_list );
    append_to_tail( &expected_list, ftr1 );
    append_to_tail( &expected_list, ftr2 );

    buffer = create_table_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );
    assert_true( buffer != NULL );

    stats_reply = buffer->data;

    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                                    + tblftr_len[0]
                                    + tblftr_len[1] );

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( stats_reply->header.version, OFP_VERSION );
    assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
    assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_reply->type ), OFPMP_TABLE_FEATURES );
    assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

    list = expected_list;
    tblftr = ( struct ofp_table_features * ) stats_reply->body;
    while ( list != NULL ) {
      struct ofp_table_features *expected_meter_stats = ( struct ofp_table_features * ) list->data;

      void *next = ( char * ) tblftr + expected_meter_stats->length;
      ntoh_table_features( tblftr, tblftr );
      assert_memory_equal( tblftr, expected_meter_stats, expected_meter_stats->length );

      list = list->next;
      tblftr = next;
    }

    xfree( ftr1 );
    xfree( ftr2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  // without table_features
  {
    buffer = create_table_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, NULL );
    assert_true( buffer != NULL );

    stats_reply = buffer->data;

    expected_msglen = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body ) );

    assert_int_equal( ( int ) buffer->length, expected_msglen );
    assert_int_equal( stats_reply->header.version, OFP_VERSION );
    assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
    assert_int_equal( ntohs( stats_reply->header.length ), expected_msglen );
    assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

    assert_int_equal( ntohs( stats_reply->type ), OFPMP_TABLE_FEATURES );
    assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * test_create_port_desc_multipart_request() tests.
 ********************************************************************************/

static void
test_create_port_desc_multipart_request() {
  buffer *buffer;
  struct ofp_multipart_request *stats_request;

  buffer = create_port_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_true( buffer != NULL );

  stats_request = ( struct ofp_multipart_request * ) buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_multipart_request ) );
  assert_int_equal( stats_request->header.version, OFP_VERSION );
  assert_int_equal( stats_request->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ntohs( stats_request->header.length ), sizeof( struct ofp_multipart_request ) );
  assert_int_equal( ( int ) ntohl( stats_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_request->type ), OFPMP_PORT_DESC );
  assert_int_equal( ntohs( stats_request->flags ), NO_FLAGS );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_port_desc_multipart_reply() tests.
 ********************************************************************************/

static void
test_create_port_desc_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *list, *l;
  uint16_t stats_len;
  struct ofp_multipart_reply *stats_reply;
  struct ofp_port *port_desc;
  uint16_t n_queues = 2;
  uint16_t length;
  buffer *buffer;
  struct ofp_port *port1, *port2;

  stats_len = sizeof( struct ofp_port );

  create_port_desc_testdata();

  port1 = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );
  memcpy( port1, port_desc_testdata[0], port_desc_testdata_len[0] );
  port2 = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );
  memcpy( port2, port_desc_testdata[1], port_desc_testdata_len[1] );

  create_list( &list );
  append_to_tail( &list, port1 );
  append_to_tail( &list, port2 );

  buffer = create_port_desc_multipart_reply( MY_TRANSACTION_ID, flags, list );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
           + sizeof( struct ofp_port ) * n_queues );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_PORT_DESC );
  assert_int_equal( ntohs( stats_reply->flags ), flags );

  port_desc = ( struct ofp_port * ) stats_reply->body;
  l = list;
  while ( list != NULL ) {
    void *next = ( char * ) port_desc + stats_len;
    ntoh_port( port_desc, port_desc );

    assert_memory_equal( port_desc, list->data, stats_len );

    list = list->next;
    port_desc = next;
  }

  delete_port_desc_testdata();
  xfree( port1 );
  xfree( port2 );
  delete_list( l );
  free_buffer( buffer );
}


/********************************************************************************
 * create_experimenter_multipart_request() tests.
 ********************************************************************************/

static void
test_create_experimenter_multipart_request() {
  const uint16_t body_length = 128;

  buffer *body = create_dummy_data( body_length );
  buffer *buffer = create_experimenter_multipart_request( MY_TRANSACTION_ID, EXPERIMENTER_STATS_FLAG, EXPERIMENTER_ID, EXPERIMENTER_TYPE, body );
  assert_true( buffer != NULL );

  assert_int_equal( ( int ) buffer->length,
                    ( int ) ( offsetof( struct ofp_multipart_request, body ) + sizeof( struct ofp_experimenter_multipart_header ) + body_length ) );

  struct ofp_multipart_request *stats = buffer->data;

  assert_int_equal( stats->header.version, OFP_VERSION );
  assert_int_equal( stats->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ( int ) ntohs( stats->header.length ),
                    ( int ) ( offsetof( struct ofp_multipart_request, body ) + sizeof( struct ofp_experimenter_multipart_header ) + body_length ) );
  assert_int_equal( ( int ) ntohl( stats->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohs( stats->type ), ( int ) OFPMP_EXPERIMENTER );
  assert_int_equal( ( int ) ntohs( stats->flags ), ( int ) EXPERIMENTER_STATS_FLAG );
  struct ofp_experimenter_multipart_header *exp_hdr;
  exp_hdr = ( struct ofp_experimenter_multipart_header * ) ( ( char * ) stats + offsetof( struct ofp_multipart_request, body ) );
  assert_int_equal( ( int ) ntohl( exp_hdr->experimenter ), ( int ) EXPERIMENTER_ID );
  assert_int_equal( ( int ) ntohl( exp_hdr->exp_type ), ( int ) EXPERIMENTER_TYPE );
  assert_memory_equal( ( char * ) stats + offsetof( struct ofp_multipart_request, body ) + sizeof ( struct ofp_experimenter_multipart_header ),
                       body->data, body_length );

  free_buffer( body );
  free_buffer( buffer );
}


static void
test_create_experimenter_multipart_request_without_data() {
  buffer *buffer = create_experimenter_multipart_request( MY_TRANSACTION_ID, EXPERIMENTER_STATS_FLAG, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );
  assert_true( buffer != NULL );

  assert_int_equal( ( int ) buffer->length,
                    ( int ) ( offsetof( struct ofp_multipart_request, body ) + sizeof( struct ofp_experimenter_multipart_header ) ) );

  struct ofp_multipart_request *stats = buffer->data;

  assert_int_equal( stats->header.version, OFP_VERSION );
  assert_int_equal( stats->header.type, OFPT_MULTIPART_REQUEST );
  assert_int_equal( ( int ) ntohs( stats->header.length ),
                    ( int ) ( offsetof( struct ofp_multipart_request, body ) + sizeof( struct ofp_experimenter_multipart_header ) ) );
  assert_int_equal( ( int ) ntohl( stats->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohs( stats->type ), ( int ) OFPMP_EXPERIMENTER );
  assert_int_equal( ( int ) ntohs( stats->flags ), ( int ) EXPERIMENTER_STATS_FLAG );
  struct ofp_experimenter_multipart_header *exp_hdr;
  exp_hdr = ( struct ofp_experimenter_multipart_header * ) ( ( char * ) stats + offsetof( struct ofp_multipart_request, body ) );
  assert_int_equal( ( int ) ntohl( exp_hdr->experimenter ), ( int ) EXPERIMENTER_ID );
  assert_int_equal( ( int ) ntohl( exp_hdr->exp_type ), ( int ) EXPERIMENTER_TYPE );

  free_buffer( buffer );
}


/********************************************************************************
 * create_experimenter_multipart_reply() test.
 ********************************************************************************/

static void
test_create_experimenter_multipart_reply() {
  void *data;
  uint32_t expected_experimenter = EXPERIMENTER_ID;
  uint32_t expected_exp_type = EXPERIMENTER_TYPE;
  buffer *buffer, *body;
  struct ofp_multipart_reply *stats_reply;
  uint16_t length;

  body = alloc_buffer_with_length( 128 );
  append_back_buffer( body, 128 );
  memset( body->data, 0xa1, body->length );

  buffer = create_experimenter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_experimenter, expected_exp_type, body );
  assert_true( buffer != NULL );

  stats_reply = buffer->data;
  length = ( uint16_t ) ( offsetof( struct ofp_multipart_reply, body )
                         + sizeof( struct ofp_experimenter_multipart_header ) + body->length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( stats_reply->header.version, OFP_VERSION );
  assert_int_equal( stats_reply->header.type, OFPT_MULTIPART_REPLY );
  assert_int_equal( ntohs( stats_reply->header.length ), length );
  assert_int_equal( ( int ) ntohl( stats_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ntohs( stats_reply->type ), OFPMP_EXPERIMENTER );
  assert_int_equal( ntohs( stats_reply->flags ), NO_FLAGS );

  struct ofp_experimenter_multipart_header *exp_hdr;
  exp_hdr = ( struct ofp_experimenter_multipart_header * ) stats_reply->body;
  assert_int_equal( ( int ) ntohl( exp_hdr->experimenter ), ( int ) expected_experimenter );
  assert_int_equal( ( int ) ntohl( exp_hdr->exp_type ), ( int ) expected_exp_type );

  data = ( char * ) exp_hdr + sizeof( struct ofp_experimenter_multipart_header );
  assert_memory_equal( data, body->data, body->length );

  free_buffer( body );
  free_buffer( buffer );
}


/********************************************************************************
 * test_create_role_request() test.
 ********************************************************************************/

static void
test_create_role_request() {
  uint32_t role = OFPCR_ROLE_SLAVE;
  uint64_t generation_id = 0x1234567890123456;
  buffer *buffer;
  struct ofp_role_request *role_request;

  buffer = create_role_request( MY_TRANSACTION_ID, role, generation_id );

  assert_true( buffer != NULL );

  role_request = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_role_request ) );
  assert_int_equal( role_request->header.version, OFP_VERSION );
  assert_int_equal( role_request->header.type, OFPT_ROLE_REQUEST );
  assert_int_equal( ntohs( role_request->header.length ), sizeof( struct ofp_role_request ) );
  assert_int_equal( ( int ) ntohl( role_request->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( role_request->role ), ( int ) role );
  {
    void *pad = xmalloc( sizeof( role_request->pad ) );
    memset( pad, 0, sizeof( role_request->pad ) );
    assert_memory_equal( role_request->pad, pad, sizeof( role_request->pad ) );
    xfree( pad );
  }
  uint64_t tmp = ntohll( role_request->generation_id );
  assert_memory_equal( &tmp, &generation_id, sizeof( generation_id ) );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_role_reply() test.
 ********************************************************************************/

static void
test_create_role_reply() {
  uint32_t role = OFPCR_ROLE_SLAVE;
  uint64_t generation_id = 0x1234567890123456;
  buffer *buffer;
  struct ofp_role_request *role_reply;

  buffer = create_role_reply( MY_TRANSACTION_ID, role, generation_id );

  assert_true( buffer != NULL );

  role_reply = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_role_request ) );
  assert_int_equal( role_reply->header.version, OFP_VERSION );
  assert_int_equal( role_reply->header.type, OFPT_ROLE_REPLY );
  assert_int_equal( ntohs( role_reply->header.length ), sizeof( struct ofp_role_request ) );
  assert_int_equal( ( int ) ntohl( role_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( role_reply->role ), ( int ) role );
  {
    void *pad = xmalloc( sizeof( role_reply->pad ) );
    memset( pad, 0, sizeof( role_reply->pad ) );
    assert_memory_equal( role_reply->pad, pad, sizeof( role_reply->pad ) );
    xfree( pad );
  }
  uint64_t tmp = ntohll( role_reply->generation_id );
  assert_memory_equal( &tmp, &generation_id, sizeof( generation_id ) );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_get_async_request() test.
 ********************************************************************************/

static void
test_create_get_async_request() {
  buffer *buffer;
  struct ofp_header *get_async_request;

  buffer = create_get_async_request( MY_TRANSACTION_ID );
  assert_true( buffer != NULL );

  get_async_request = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_header ) );
  assert_int_equal( get_async_request->version, OFP_VERSION );
  assert_int_equal( get_async_request->type, OFPT_GET_ASYNC_REQUEST );
  assert_int_equal( ntohs( get_async_request->length ), sizeof( struct ofp_header ) );
  assert_int_equal( ( int ) ntohl( get_async_request->xid ), ( int ) MY_TRANSACTION_ID );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_get_async_reply() test.
 ********************************************************************************/

static void
test_create_get_async_reply() {
  uint32_t packet_in_mask[2] = { 0x11223344, 0x55667788 };
  uint32_t port_status_mask[2] = { 0x12123434, 0x56567878 };
  uint32_t flow_removed_mask[2] = { 0x99887766, 0x55443322 };
  buffer *buffer;
  struct ofp_async_config *get_async_reply;

  buffer = create_get_async_reply( MY_TRANSACTION_ID, packet_in_mask, port_status_mask, flow_removed_mask );

  assert_true( buffer != NULL );

  get_async_reply = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_async_config ) );
  assert_int_equal( get_async_reply->header.version, OFP_VERSION );
  assert_int_equal( get_async_reply->header.type, OFPT_GET_ASYNC_REPLY );
  assert_int_equal( ntohs( get_async_reply->header.length ), sizeof( struct ofp_async_config ) );
  assert_int_equal( ( int ) ntohl( get_async_reply->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( get_async_reply->packet_in_mask[0] ), ( int ) packet_in_mask[0] );
  assert_int_equal( ( int ) ntohl( get_async_reply->packet_in_mask[1] ), ( int ) packet_in_mask[1] );
  assert_int_equal( ( int ) ntohl( get_async_reply->port_status_mask[0] ), ( int ) port_status_mask[0] );
  assert_int_equal( ( int ) ntohl( get_async_reply->port_status_mask[1] ), ( int ) port_status_mask[1] );
  assert_int_equal( ( int ) ntohl( get_async_reply->flow_removed_mask[0] ), ( int ) flow_removed_mask[0] );
  assert_int_equal( ( int ) ntohl( get_async_reply->flow_removed_mask[1] ), ( int ) flow_removed_mask[1] );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_set_async() test.
 ********************************************************************************/

static void
test_create_set_async() {
  uint32_t packet_in_mask[2] = { 0x11223344, 0x55667788 };
  uint32_t port_status_mask[2] = { 0x12123434, 0x56567878 };
  uint32_t flow_removed_mask[2] = { 0x99887766, 0x55443322 };
  buffer *buffer;
  struct ofp_async_config *set_async;

  buffer = create_set_async( MY_TRANSACTION_ID, packet_in_mask, port_status_mask, flow_removed_mask );

  assert_true( buffer != NULL );

  set_async = buffer->data;

  assert_int_equal( ( int ) buffer->length, sizeof( struct ofp_async_config ) );
  assert_int_equal( set_async->header.version, OFP_VERSION );
  assert_int_equal( set_async->header.type, OFPT_SET_ASYNC );
  assert_int_equal( ntohs( set_async->header.length ), sizeof( struct ofp_async_config ) );
  assert_int_equal( ( int ) ntohl( set_async->header.xid ), ( int ) MY_TRANSACTION_ID );

  assert_int_equal( ( int ) ntohl( set_async->packet_in_mask[0] ), ( int ) packet_in_mask[0] );
  assert_int_equal( ( int ) ntohl( set_async->packet_in_mask[1] ), ( int ) packet_in_mask[1] );
  assert_int_equal( ( int ) ntohl( set_async->port_status_mask[0] ), ( int ) port_status_mask[0] );
  assert_int_equal( ( int ) ntohl( set_async->port_status_mask[1] ), ( int ) port_status_mask[1] );
  assert_int_equal( ( int ) ntohl( set_async->flow_removed_mask[0] ), ( int ) flow_removed_mask[0] );
  assert_int_equal( ( int ) ntohl( set_async->flow_removed_mask[1] ), ( int ) flow_removed_mask[1] );

  free_buffer( buffer );
}


/********************************************************************************
 * test_create_meter_mod() test.
 ********************************************************************************/

static void
test_create_meter_mod() {
  size_t band_0len, band_1len;
  uint16_t command = 0x0305;
  uint16_t flags = 0x0204;
  uint32_t meter_id = 0x18273645;
  list_element *list, *l;
  buffer *buffer;
  struct ofp_meter_mod *meter_mod;
  struct ofp_meter_band_header *meter_band;
  struct ofp_meter_band_drop *band_drop_header;
  struct ofp_meter_band_dscp_remark *band_dscp_remark_header;
  uint16_t bands_length;
  uint16_t length;

  band_0len = sizeof( struct ofp_meter_band_drop );
  band_1len = sizeof( struct ofp_meter_band_dscp_remark );
  band_drop_header = xcalloc( 1, band_0len );
  band_dscp_remark_header = xcalloc( 1, band_1len );

  band_drop_header->type = OFPMBT_DROP;
  band_drop_header->len = ( uint16_t ) band_0len;
  band_drop_header->rate = 0x01020304;
  band_drop_header->burst_size = 0x05060708;

  band_dscp_remark_header->type = OFPMBT_DSCP_REMARK;
  band_dscp_remark_header->len = ( uint16_t ) band_1len;
  band_dscp_remark_header->rate = 0x11223344;
  band_dscp_remark_header->burst_size = 0x55667788;
  band_dscp_remark_header->prec_level = 0x12;

  create_list( &list );
  append_to_tail( &list, band_drop_header );
  append_to_tail( &list, band_dscp_remark_header );

  buffer = create_meter_mod( MY_TRANSACTION_ID, command, flags, meter_id, list );
  assert_true( buffer != NULL );

  meter_mod = buffer->data;

  bands_length = ( uint16_t ) ( band_drop_header->len + band_dscp_remark_header->len );
  length = ( uint16_t ) ( offsetof( struct ofp_meter_mod, bands ) + bands_length );

  assert_int_equal( ( int ) buffer->length, length );
  assert_int_equal( meter_mod->header.version, OFP_VERSION );
  assert_int_equal( meter_mod->header.type, OFPT_METER_MOD );
  assert_int_equal( ntohs( meter_mod->header.length ), length );
  assert_int_equal( ( int ) ntohl( meter_mod->header.xid ), ( int ) MY_TRANSACTION_ID );

  l = list;
  meter_band = meter_mod->bands;
  while ( list != NULL ) {
    ntoh_meter_band_header( meter_band, meter_band );
    void *next = ( char * ) meter_band + meter_band->len;
    struct ofp_meter_band_header *expected_meter_band = ( struct ofp_meter_band_header * ) list->data;
    assert_memory_equal( meter_band, expected_meter_band, expected_meter_band->len );

    list = list->next;
    meter_band = next;
  }

  xfree( band_drop_header );
  xfree( band_dscp_remark_header );
  delete_list( l );
  free_buffer( buffer );
}


/********************************************************************************
 * validate_error() test.
 ********************************************************************************/

static void
test_validate_error() {
  uint16_t type = OFPET_HELLO_FAILED;
  uint16_t code = OFPHFC_INCOMPATIBLE;
  buffer *expected_data;
  buffer *expected_message = NULL;
  int ret_val;

  expect_assert_failure( validate_error( expected_message ) );

  expected_data = create_dummy_data( SHORT_DATA_LENGTH );

  expected_message = create_error( MY_TRANSACTION_ID, type, code, expected_data );

  ret_val = validate_error( expected_message );
  assert_int_equal( ret_val, 0 );

  free_buffer( expected_data );
  free_buffer( expected_message );

  // error case.
  expected_message = create_echo_request( MY_TRANSACTION_ID, NULL );

  ret_val = validate_error( expected_message );
  assert_int_equal( ret_val, ERROR_INVALID_TYPE );

  free_buffer( expected_message );
}


/********************************************************************************
 * validate_validate_experimenter() tests.
 ********************************************************************************/

static void
test_validate_experimenter() {
  buffer *data = create_dummy_data( 32 );
  buffer *message = create_experimenter( MY_TRANSACTION_ID, EXPERIMENTER_ID, EXPERIMENTER_TYPE, data );

  assert_int_equal( validate_experimenter( message ), 0 );

  free_buffer( data );
  free_buffer( message );
}


static void
test_validate_experimenter_without_data() {
  buffer *message = create_experimenter( MY_TRANSACTION_ID, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );

  assert_int_equal( validate_experimenter( message ), 0 );

  free_buffer( message );
}


static void
test_validate_experimenter_fails_if_message_is_NULL() {
  expect_assert_failure( validate_experimenter( NULL ) );
}


static void
test_validate_experimenter_fails_if_message_is_not_experimenter_header() {
  buffer *message = create_hello( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_experimenter( message ), ERROR_INVALID_TYPE );

  free_buffer( message );
}


/********************************************************************************
 * validate_features_reply() test.
 ********************************************************************************/

static void
test_validate_features_reply() {
  uint64_t datapath_id = 0x12345600;
  uint32_t n_buffers = 128;
  uint8_t n_tables = 1;
  uint8_t auxiliary_id = 0x89;
  uint32_t capabilities;
  buffer *expected_message = NULL;
  int ret_val;

  expect_assert_failure( validate_features_reply( expected_message ) );

  capabilities = ( OFPC_FLOW_STATS | OFPC_TABLE_STATS | OFPC_PORT_STATS | OFPC_GROUP_STATS | OFPC_IP_REASM | OFPC_QUEUE_STATS | OFPC_PORT_BLOCKED );

  expected_message = create_features_reply( MY_TRANSACTION_ID, datapath_id, n_buffers, n_tables, auxiliary_id, capabilities );

  ret_val = validate_features_reply( expected_message );
  assert_int_equal( ret_val, 0 );

  free_buffer( expected_message );

  // error case.
  expected_message = create_hello( MY_TRANSACTION_ID, NULL );

  ret_val = validate_features_reply( expected_message );
  assert_int_equal( ret_val, ERROR_INVALID_TYPE );

  free_buffer( expected_message );
}


/********************************************************************************
 * validate_get_config_request() tests.
 ********************************************************************************/

static void
test_validate_get_config_request() {
  buffer *get_config_request = create_get_config_request( MY_TRANSACTION_ID );

  assert_int_equal( validate_get_config_request( get_config_request ), 0 );

  free_buffer( get_config_request );
}


static void
test_validate_get_config_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_get_config_request( NULL ) );
}


static void
test_validate_get_config_request_fails_if_message_is_not_get_config_request() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_get_config_request( hello ), ERROR_INVALID_TYPE );

  free_buffer( hello );
}


/********************************************************************************
 * validate_get_config_reply() test.
 ********************************************************************************/

static void
test_validate_get_config_reply() {
  uint16_t flags = OFPC_FRAG_NORMAL;
  uint16_t miss_send_len = OFP_DEFAULT_MISS_SEND_LEN;
  buffer *expected_message = NULL;
  int ret_val;

  expect_assert_failure( validate_get_config_reply( expected_message ) );

  expected_message = create_get_config_reply( MY_TRANSACTION_ID, flags, miss_send_len );

  ret_val = validate_get_config_reply( expected_message );
  assert_int_equal( ret_val, 0 );

  free_buffer( expected_message );

  // error case.
  expected_message = create_echo_request( MY_TRANSACTION_ID, NULL );

  ret_val = validate_get_config_reply( expected_message );
  assert_int_equal( ret_val, ERROR_INVALID_TYPE );

  free_buffer( expected_message );
}


/********************************************************************************
 * validate_packet_in() test.
 ********************************************************************************/

static void
test_validate_packet_in() {
  uint16_t total_len;
  uint8_t reason = OFPR_INVALID_TTL;
  uint8_t table_id = 0x12;
  uint64_t cookie = 0x1122334455667788;
  buffer *expected_data = NULL;
  buffer *expected_message = NULL;
  int ret_val;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  expect_assert_failure( validate_packet_in( expected_message ) );

  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );

    expected_data = create_dummy_data( LONG_DATA_LENGTH );
    total_len = ( uint16_t ) expected_data->length;
    expected_message = create_packet_in( MY_TRANSACTION_ID, BUFFER_ID, total_len, reason, table_id, cookie, match, expected_data );

    ret_val = validate_packet_in( expected_message );
    assert_int_equal( ret_val, 0 );

    delete_oxm_matches( match );
    delete_oxm_match_testdata();
    free_buffer( expected_message );
  }

  // error case.
  {
    expected_message = create_echo_request( MY_TRANSACTION_ID, NULL );

    ret_val = validate_packet_in( expected_message );
    assert_int_equal( ret_val, ERROR_INVALID_TYPE );

    free_buffer( expected_data );
    free_buffer( expected_message );
  }
}


/********************************************************************************
 * validate_flow_removed() test.
 ********************************************************************************/

static void
test_validate_flow_removed() {
  uint64_t cookie = 0x0102030405060708ULL;
  uint8_t reason = OFPRR_IDLE_TIMEOUT;
  uint8_t table_id = 0x12;
  uint32_t duration_sec = 180;
  uint32_t duration_nsec = 10000;
  uint16_t idle_timeout = 60;
  uint16_t hard_timeout = 900;
  uint64_t packet_count = 1000;
  uint64_t byte_count = 100000;
  buffer *expected_message = NULL;
  int ret_val;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  expect_assert_failure( validate_flow_removed( expected_message ) );

  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );

    expected_message = create_flow_removed( MY_TRANSACTION_ID, cookie, PRIORITY, reason, table_id, duration_sec,
                                            duration_nsec, idle_timeout, hard_timeout, packet_count, byte_count, match );

    ret_val = validate_flow_removed( expected_message );
    assert_int_equal( ret_val, 0 );

    delete_oxm_matches( match );
    delete_oxm_match_testdata();
    free_buffer( expected_message );
  }

  // error case.
  {
    expected_message = create_echo_request( MY_TRANSACTION_ID, NULL );

    ret_val = validate_flow_removed( expected_message );
    assert_int_equal( ret_val, ERROR_INVALID_TYPE );

    free_buffer( expected_message );
  }
}


/********************************************************************************
 * validate_port_status() test.
 ********************************************************************************/

static void
test_validate_port_status() {
  uint8_t reason = OFPPR_ADD;
  struct ofp_port desc;
  buffer *expected_message = NULL;
  int ret_val;

  expect_assert_failure( validate_port_status( expected_message ) );

  {
    desc.port_no = 1;
    memcpy( desc.hw_addr, HW_ADDR, sizeof( desc.hw_addr ) );
    memset( desc.name, '\0', OFP_MAX_PORT_NAME_LEN );
    strcpy( desc.name, "Navy" );
    desc.config = OFPPC_PORT_DOWN;
    desc.state = OFPPS_LINK_DOWN;
    desc.curr = ( OFPPF_1GB_FD | OFPPF_COPPER | OFPPF_PAUSE );
    desc.advertised = PORT_FEATURES;
    desc.supported = PORT_FEATURES;
    desc.peer = PORT_FEATURES;
    desc.curr_speed = 10000;
    desc.max_speed = 1000000;
    expected_message = create_port_status( MY_TRANSACTION_ID, reason, desc );

    ret_val = validate_port_status( expected_message );
    assert_int_equal( ret_val, 0 );

    free_buffer( expected_message );
  }

  // error case.
  {
    expected_message = create_echo_request( MY_TRANSACTION_ID, NULL );

    ret_val = validate_port_status( expected_message );
    assert_int_equal( ret_val, ERROR_INVALID_TYPE );

    free_buffer( expected_message );
  }
}


/********************************************************************************
 * validate_packet_out() tests.
 ********************************************************************************/

static void
test_validate_packet_out() {
  openflow_actions *actions = create_actions();
  append_action_output( actions, 1, 128 );
  buffer *data = create_dummy_data( LONG_DATA_LENGTH );
  buffer *packet_out = create_packet_out( MY_TRANSACTION_ID, UINT32_MAX, 1, actions, data );

  assert_int_equal( validate_packet_out( packet_out ), 0 );

  free_buffer( data );
  free_buffer( packet_out );
  delete_actions( actions );
}


static void
test_validate_packet_out_without_data() {
  openflow_actions *actions = create_actions();
  append_action_output( actions, 1, 128 );
  buffer *packet_out = create_packet_out( MY_TRANSACTION_ID, BUFFER_ID, 1, actions, NULL );

  assert_int_equal( validate_packet_out( packet_out ), 0 );

  free_buffer( packet_out );
  delete_actions( actions );
}


static void
test_validate_packet_out_fails_if_message_is_NULL() {
  expect_assert_failure( validate_packet_out( NULL ) );
}


static void
test_validate_packet_out_fails_if_message_is_not_packet_out() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_packet_out( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_flow_mod() tests.
 ********************************************************************************/

static void
test_validate_flow_mod() {
  uint64_t cookie = 10;
  uint64_t cookie_mask = 20;
  uint8_t table_id = 0x12;
  uint16_t hard_timeout = 10;
  uint16_t idle_timeout = 5;
  uint32_t out_port = 1;
  uint32_t out_group = 2;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  openflow_instructions *instructions;
  struct ofp_instruction *inst1, *inst2;

  // ofp_match
  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );
  }

  // ofp_instruction
  {
    create_instruction_testdata();

    inst1 = xcalloc( 1, instruction_testdata_len[0] );
    memcpy( inst1, instruction_testdata[0], instruction_testdata_len[0] );
    inst2 = xcalloc( 1, instruction_testdata_len[1] );
    memcpy( inst2, instruction_testdata[1], instruction_testdata_len[1] );

    instructions = create_instructions();
    instructions->n_instructions = 2;
    append_to_tail( &instructions->list, inst1 );
    append_to_tail( &instructions->list, inst2 );
  }

  buffer *flow_mod = create_flow_mod( MY_TRANSACTION_ID, cookie, cookie_mask, table_id, OFPFC_ADD, idle_timeout, hard_timeout, PRIORITY,
                                      BUFFER_ID, out_port, out_group, OFPFF_CHECK_OVERLAP | OFPFF_SEND_FLOW_REM, match, instructions );

  assert_int_equal( validate_flow_mod( flow_mod ), 0 );

  free_buffer( flow_mod );
  delete_oxm_matches( match );
  delete_instructions( instructions );
  delete_oxm_match_testdata();
  delete_instruction_testdata();
}


static void
test_validate_flow_mod_fails_if_message_is_NULL() {
  expect_assert_failure( validate_flow_mod( NULL ) );
}


static void
test_validate_flow_mod_fails_if_message_is_not_flow_mod() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_flow_mod( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_group_mod() tests.
 ********************************************************************************/

static void
test_validate_group_mod() {
  uint16_t command = OFPGC_ADD;
  uint8_t type = OFPGT_SELECT;
  uint32_t group_id = 0x10023004;
  openflow_buckets *buckets;
  struct ofp_bucket *bkt1, *bkt2;

  create_bucket_testdata();

  bkt1 = xcalloc( 1, bucket_testdata_len[0] );
  memcpy( bkt1, bucket_testdata[0], bucket_testdata_len[0] );
  bkt2 = xcalloc( 1, bucket_testdata_len[1] );
  memcpy( bkt2, bucket_testdata[1], bucket_testdata_len[1] );

  buckets = create_buckets();
  append_to_tail( &buckets->list, bkt1 );
  append_to_tail( &buckets->list, bkt2 );
  buckets->n_buckets = 2;

  buffer *group_mod = create_group_mod( MY_TRANSACTION_ID, command, type, group_id, buckets );

  assert_int_equal( validate_group_mod( group_mod ), 0 );

  free_buffer( group_mod );
  delete_buckets( buckets );
  delete_bucket_testdata();
}


static void
test_validate_group_mod_fails_if_message_is_NULL() {
  expect_assert_failure( validate_group_mod( NULL ) );
}


static void
test_validate_group_mod_fails_if_message_is_not_group_mod() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_group_mod( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_port_mod() tests.
 ********************************************************************************/

static void
test_validate_port_mod() {
  uint32_t port_no = 1;
  uint32_t mask = 0;
  uint32_t advertise = 1;
  buffer *port_mod = create_port_mod( MY_TRANSACTION_ID, port_no, HW_ADDR, OFPPC_PORT_DOWN, mask, advertise );

  assert_int_equal( validate_port_mod( port_mod ), 0 );

  free_buffer( port_mod );
}


static void
test_validate_port_mod_fails_if_message_is_NULL() {
  expect_assert_failure( validate_port_mod( NULL ) );
}


static void
test_validate_port_mod_fails_if_message_is_not_port_mod() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_port_mod( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_table_mod() tests.
 ********************************************************************************/

static void
test_validate_table_mod() {
  uint8_t table_id = 0x12;
  uint32_t config = 0x12345678;

  buffer *table_mod = create_table_mod( MY_TRANSACTION_ID, table_id, config );

  assert_int_equal( validate_table_mod( table_mod ), 0 );

  free_buffer( table_mod );
}


static void
test_validate_table_mod_fails_if_message_is_NULL() {
  expect_assert_failure( validate_table_mod( NULL ) );
}


static void
test_validate_table_mod_fails_if_message_is_not_group_mod() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_table_mod( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_desc_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_desc_multipart_request() {
  buffer *desc_stats_request = create_desc_multipart_request( MY_TRANSACTION_ID, 0 );

  assert_int_equal( validate_desc_multipart_request( desc_stats_request ), 0 );

  free_buffer( desc_stats_request );
}


static void
test_validate_desc_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_desc_multipart_request( NULL ) );
}


static void
test_validate_desc_multipart_request_fails_if_message_is_not_desc_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_desc_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_desc_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_desc_multipart_reply() {
  const char mfr_desc[ DESC_STR_LEN ] = "NEC Corporation";
  const char hw_desc[ DESC_STR_LEN ] = "OpenFlow Switch Hardware";
  const char sw_desc[ DESC_STR_LEN ] = "OpenFlow Switch Software";
  const char serial_num[ SERIAL_NUM_LEN ] = "1234";
  const char dp_desc[ DESC_STR_LEN ] = "Datapath 0";
  buffer *expected_message = NULL;
  int ret_val;

  expect_assert_failure( validate_desc_multipart_reply( expected_message ) );

  {
    expected_message = create_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, mfr_desc, hw_desc, sw_desc, serial_num, dp_desc );

    ret_val = validate_desc_multipart_reply( expected_message );
    assert_int_equal( ret_val, 0 );

    free_buffer( expected_message );
  }

  {
    buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_desc_multipart_reply( echo_request ), ERROR_INVALID_TYPE );

    free_buffer( echo_request );
  }
}


/********************************************************************************
 * validate_flow_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_flow_multipart_request() {
  uint8_t table_id = 0xff;
  uint32_t out_port = 1;
  uint32_t out_group = 5;
  uint64_t cookie = 0x1234567890123456;
  uint64_t cookie_mask = 0x6543210987654321;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  {
    // ofp_match
    {
      create_oxm_match_testdata();

      oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
      memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
      oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
      memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

      match = create_oxm_matches();
      match->n_matches = 2;
      append_to_tail( &match->list, oxm1 );
      append_to_tail( &match->list, oxm2 );
    }

    buffer *flow_stats_request = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, match );

    assert_int_equal( validate_flow_multipart_request( flow_stats_request ), 0 );

    free_buffer( flow_stats_request );
    delete_oxm_matches( match );
    delete_oxm_match_testdata();
  }

  {
    buffer *flow_stats_request = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, NULL );

    assert_int_equal( validate_flow_multipart_request( flow_stats_request ), 0 );

    free_buffer( flow_stats_request );
  }
}


static void
test_validate_flow_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_flow_multipart_request( NULL ) );
}


static void
test_validate_flow_multipart_request_fails_if_message_is_not_flow_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_flow_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_flow_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_flow_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *expected_list;
  buffer *buffer;
  uint16_t stats_len = 0;
  struct ofp_flow_stats *expected_stats[ 2 ];
  struct ofp_instruction *inst;

  // with match
  {
    create_oxm_match_testdata();
    create_instruction_testdata();

    stats_len = ( uint16_t ) ( offsetof( struct ofp_flow_stats, match ) + expected_ofp_match_len + expected_ofp_instruction_len );

    expected_stats[ 0 ] = xcalloc( 1, stats_len );
    expected_stats[ 1 ] = xcalloc( 1, stats_len );

    expected_stats[ 0 ]->length = stats_len;
    expected_stats[ 0 ]->table_id = 1;
    expected_stats[ 0 ]->pad = 0;
    expected_stats[ 0 ]->duration_sec = 60;
    expected_stats[ 0 ]->duration_nsec = 10000;
    expected_stats[ 0 ]->priority = 1024;
    expected_stats[ 0 ]->idle_timeout = 60;
    expected_stats[ 0 ]->hard_timeout = 3600;
    expected_stats[ 0 ]->flags = OFPFF_NO_BYT_COUNTS;
    memset( expected_stats[ 0 ]->pad2, 0, sizeof( expected_stats[ 0 ]->pad2 ) );
    expected_stats[ 0 ]->cookie = 0x0102030405060708ULL;
    expected_stats[ 0 ]->packet_count = 1000;
    expected_stats[ 0 ]->byte_count = 100000;
    memcpy( &expected_stats[ 0 ]->match, expected_ofp_match, expected_ofp_match_len );
    inst = ( struct ofp_instruction * ) ( ( char * ) &expected_stats[ 0 ]->match + expected_ofp_match_len );
    memcpy( inst, expected_ofp_instruction, expected_ofp_instruction_len );

    memcpy( expected_stats[ 1 ], expected_stats[ 0 ], stats_len );
    expected_stats[ 1 ]->cookie = 0x0203040506070809ULL;

    create_list( &expected_list );
    append_to_tail( &expected_list, expected_stats[ 0 ] );
    append_to_tail( &expected_list, expected_stats[ 1 ] );

    buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

    assert_int_equal( validate_flow_multipart_reply( buffer ), 0 );

    xfree( expected_stats[ 0 ] );
    xfree( expected_stats[ 1 ] );
    delete_list( expected_list );

    delete_oxm_match_testdata();
    delete_instruction_testdata();
    free_buffer( buffer );
  }

  // without match instruction
  {
    struct ofp_match *expected_empty_ofp_match;
    uint16_t expected_empty_ofp_match_len;

    // ofp_match
    {
      expected_empty_ofp_match_len = sizeof( struct ofp_match );
      expected_empty_ofp_match = ( struct ofp_match * ) xcalloc( 1, expected_empty_ofp_match_len );
      expected_empty_ofp_match->type = OFPMT_OXM;
      expected_empty_ofp_match->length = ( uint16_t ) offsetof( struct ofp_match, oxm_fields );
    }

    stats_len = ( uint16_t ) ( offsetof( struct ofp_flow_stats, match ) + expected_empty_ofp_match_len );

    expected_stats[ 0 ] = xcalloc( 1, stats_len );
    expected_stats[ 1 ] = xcalloc( 1, stats_len );

    expected_stats[ 0 ]->length = stats_len;
    expected_stats[ 0 ]->table_id = 1;
    expected_stats[ 0 ]->pad = 0;
    expected_stats[ 0 ]->duration_sec = 60;
    expected_stats[ 0 ]->duration_nsec = 10000;
    expected_stats[ 0 ]->priority = 1024;
    expected_stats[ 0 ]->idle_timeout = 60;
    expected_stats[ 0 ]->hard_timeout = 3600;
    expected_stats[ 0 ]->flags = OFPFF_NO_BYT_COUNTS;
    memset( expected_stats[ 0 ]->pad2, 0, sizeof( expected_stats[ 0 ]->pad2 ) );
    expected_stats[ 0 ]->cookie = 0x0102030405060708ULL;
    expected_stats[ 0 ]->packet_count = 1000;
    expected_stats[ 0 ]->byte_count = 100000;
    memcpy( &expected_stats[ 0 ]->match, expected_empty_ofp_match, expected_empty_ofp_match_len );

    memcpy( expected_stats[ 1 ], expected_stats[ 0 ], stats_len );
    expected_stats[ 1 ]->cookie = 0x0203040506070809ULL;

    create_list( &expected_list );
    append_to_tail( &expected_list, expected_stats[ 0 ] );
    append_to_tail( &expected_list, expected_stats[ 1 ] );

    buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

    assert_int_equal( validate_flow_multipart_reply( buffer ), 0 );

    xfree( expected_stats[ 0 ] );
    xfree( expected_stats[ 1 ] );
    xfree( expected_empty_ofp_match );
    delete_list( expected_list );

    free_buffer( buffer );
  }

  // without payload
  {
    buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, NULL );

    assert_int_equal( validate_flow_multipart_reply( buffer ), 0 );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_aggregate_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_aggregate_multipart_request() {
  uint8_t table_id = 0xff;
  uint32_t out_port = 1;
  uint32_t out_group = 5;
  uint64_t cookie = 0x1234567890123456;
  uint64_t cookie_mask = 0x6543210987654321;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  {
    // ofp_match
    {
      create_oxm_match_testdata();

      oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
      memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
      oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
      memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

      match = create_oxm_matches();
      match->n_matches = 2;
      append_to_tail( &match->list, oxm1 );
      append_to_tail( &match->list, oxm2 );
    }

    buffer *aggregate_stats_request = create_aggregate_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, match );

    assert_int_equal( validate_aggregate_multipart_request( aggregate_stats_request ), 0 );

    free_buffer( aggregate_stats_request );
    delete_oxm_matches( match );
    delete_oxm_match_testdata();
  }

  {
    buffer *aggregate_stats_request = create_aggregate_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, NULL );

    assert_int_equal( validate_aggregate_multipart_request( aggregate_stats_request ), 0 );

    free_buffer( aggregate_stats_request );
  }
}


static void
test_validate_aggregate_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_aggregate_multipart_request( NULL ) );
}


static void
test_validate_aggregate_multipart_request_fails_if_message_is_not_aggregate_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_aggregate_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_aggregate_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_aggregate_multipart_reply() {
  uint32_t flow_count = 1000;
  uint64_t packet_count = 1000;
  uint64_t byte_count = 10000;
  buffer *expected_message = NULL;
  int ret_val;

  expected_message = create_aggregate_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, packet_count, byte_count, flow_count );

  ret_val = validate_aggregate_multipart_reply( expected_message );
  assert_int_equal( ret_val, 0 );

  free_buffer( expected_message );
}


/********************************************************************************
 * validate_table_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_table_multipart_request() {
  buffer *table_stats_request = create_table_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_table_multipart_request( table_stats_request ), 0 );

  free_buffer( table_stats_request );
}


static void
test_validate_table_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_table_multipart_request( NULL ) );
}


static void
test_validate_table_multipart_request_fails_if_message_is_not_table_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_table_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_table_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_table_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  uint16_t stats_len;
  list_element *expected_list;
  struct ofp_table_stats *stats[ 2 ];
  buffer *expected_message = NULL;
  int ret_val;

  {
    stats_len = sizeof( struct ofp_table_stats );

    stats[ 0 ] = xcalloc( 1, stats_len );
    stats[ 1 ] = xcalloc( 1, stats_len );

    stats[ 0 ]->table_id = 1;
    stats[ 0 ]->active_count = 1000;
    stats[ 0 ]->lookup_count = 100000;
    stats[ 0 ]->matched_count = 10000;

    memcpy( stats[ 1 ], stats[ 0 ], stats_len );
    stats[ 1 ]->table_id = 2;

    create_list( &expected_list );
    append_to_tail( &expected_list, stats[ 0 ] );
    append_to_tail( &expected_list, stats[ 1 ] );

    expected_message = create_table_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

    ret_val = validate_table_multipart_reply( expected_message );
    assert_int_equal( ret_val, 0 );

    xfree( stats[ 0 ] );
    xfree( stats[ 1 ] );
    delete_list( expected_list );
    free_buffer( expected_message );
  }
}


/********************************************************************************
 * validate_port_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_port_multipart_request() {
  uint32_t port_no = 1;
  buffer *port_stats_request = create_port_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, port_no );

  assert_int_equal( validate_port_multipart_request( port_stats_request ), 0 );

  free_buffer( port_stats_request );
}


static void
test_validate_port_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_port_multipart_request( NULL ) );
}


static void
test_validate_port_multipart_request_fails_if_message_is_not_port_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_port_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_port_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_port_multipart_reply() {
  void *expected_data;
  uint16_t flags = OFPMPF_REPLY_MORE;
  uint16_t stats_len;
  list_element *expected_list;
  struct ofp_port_stats *stats[ 2 ];
  buffer *expected_message = NULL;
  int ret_val;

  {
    stats_len = sizeof( struct ofp_port_stats );

    stats[ 0 ] = xcalloc( 1, stats_len );
    stats[ 1 ] = xcalloc( 1, stats_len );

    stats[ 0 ]->port_no = 1;
    stats[ 0 ]->rx_packets = 10000;
    stats[ 0 ]->tx_packets = 20000;
    stats[ 0 ]->rx_bytes = 30000;
    stats[ 0 ]->tx_bytes = 40000;
    stats[ 0 ]->rx_dropped = 50000;
    stats[ 0 ]->tx_dropped = 60000;
    stats[ 0 ]->rx_errors = 70000;
    stats[ 0 ]->tx_errors = 80000;
    stats[ 0 ]->rx_frame_err = 1;
    stats[ 0 ]->rx_over_err = 2;
    stats[ 0 ]->rx_crc_err = 1;
    stats[ 0 ]->collisions = 3;
    stats[ 0 ]->duration_sec = 112233;
    stats[ 0 ]->duration_nsec = 445566;

    memcpy( stats[ 1 ], stats[ 0 ], stats_len );
    stats[ 1 ]->port_no = 2;

    create_list( &expected_list );
    append_to_tail( &expected_list, stats[ 0 ] );
    append_to_tail( &expected_list, stats[ 1 ] );

    expected_data = xcalloc( 1, ( size_t ) ( stats_len * 2 ) );
    memcpy( expected_data, stats[ 0 ], stats_len );
    memcpy( ( char * ) expected_data + stats_len, stats[ 1 ], stats_len );

    expected_message = create_port_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

    ret_val = validate_port_multipart_reply( expected_message );
    assert_int_equal( ret_val, 0 );

    xfree( stats[ 0 ] );
    xfree( stats[ 1 ] );
    xfree( expected_data );
    delete_list( expected_list );
    free_buffer( expected_message );
  }
}


/********************************************************************************
 * validate_group_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_group_multipart_request() {
  uint32_t group_id = 10;

  buffer *group_stats_req = create_group_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, group_id );

  assert_int_equal( validate_group_multipart_request( group_stats_req ), 0 );

  free_buffer( group_stats_req );
}


static void
test_validate_group_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_group_multipart_request( NULL ) );
}


static void
test_validate_group_multipart_request_fails_if_message_is_not_group_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_group_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_group_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_group_multipart_reply() {
  size_t grpsts_0len, grpsts_1len;
  list_element *list;
  buffer *expected_message;
  struct ofp_group_stats *grpsts[ 2 ];
  struct ofp_bucket_counter *bktcnt;

  {
    grpsts_0len = offsetof( struct ofp_group_stats, bucket_stats ) + sizeof( struct ofp_bucket_counter );
    grpsts_1len = offsetof( struct ofp_group_stats, bucket_stats ) + sizeof( struct ofp_bucket_counter );
    grpsts[ 0 ] = xcalloc( 1, grpsts_0len );
    grpsts[ 1 ] = xcalloc( 1, grpsts_1len );

    grpsts[ 0 ]->length = ( uint16_t ) grpsts_0len;
    grpsts[ 0 ]->group_id = 1;
    grpsts[ 0 ]->ref_count = 2;
    grpsts[ 0 ]->packet_count = 3;
    grpsts[ 0 ]->byte_count = 4;
    grpsts[ 0 ]->duration_sec = 5;
    grpsts[ 0 ]->duration_nsec = 6;
    bktcnt = ( struct ofp_bucket_counter * ) grpsts[ 0 ]->bucket_stats;
    bktcnt->packet_count = 7;
    bktcnt->byte_count = 8;

    grpsts[ 1 ]->length = ( uint16_t ) grpsts_1len;
    grpsts[ 1 ]->group_id = 11;
    grpsts[ 1 ]->ref_count = 12;
    grpsts[ 1 ]->packet_count = 13;
    grpsts[ 1 ]->byte_count = 14;
    grpsts[ 1 ]->duration_sec = 15;
    grpsts[ 1 ]->duration_nsec = 16;
    bktcnt = ( struct ofp_bucket_counter * ) grpsts[ 1 ]->bucket_stats;
    bktcnt->packet_count = 17;
    bktcnt->byte_count = 18;

    create_list( &list );
    append_to_tail( &list, grpsts[ 0 ] );
    append_to_tail( &list, grpsts[ 1 ] );

    expected_message = create_group_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, list );

    assert_int_equal( 0, validate_group_multipart_reply( expected_message ) );

    xfree( grpsts[ 0 ] );
    xfree( grpsts[ 1 ] );
    delete_list( list );
    free_buffer( expected_message );
  }

  {
    expected_message = create_group_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, NULL );

    assert_int_equal( 0, validate_group_multipart_reply( expected_message ) );

    free_buffer( expected_message );
  }

  expect_assert_failure( validate_group_multipart_reply( NULL ) );

  {
    buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_group_multipart_reply( echo_request ), ERROR_INVALID_TYPE );

    free_buffer( echo_request );
  }
}


/********************************************************************************
 * validate_group_desc_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_group_desc_multipart_request() {
  buffer *buffer;

  buffer = create_group_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_group_desc_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_group_desc_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_group_desc_multipart_request( NULL ) );
}


static void
test_validate_group_desc_multipart_request_fails_if_message_is_not_group_desc_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_group_desc_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_group_desc_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_group_desc_multipart_reply() {
  uint16_t grpdsc_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_group_desc_stats *dsc1, *dsc2;

  {
    create_bucket_testdata();

    grpdsc_len[0] = ( uint16_t ) ( offsetof( struct ofp_group_desc_stats, buckets ) + bucket_testdata_len[0] );
    dsc1 = xcalloc( 1, grpdsc_len[0] );
    dsc1->length = grpdsc_len[0];
    dsc1->type = OFPGT_SELECT;
    dsc1->group_id = 0x11223344;
    memcpy( dsc1->buckets, bucket_testdata[0], bucket_testdata_len[0] );

    grpdsc_len[1] = ( uint16_t ) ( offsetof( struct ofp_group_desc_stats, buckets ) + bucket_testdata_len[1] );
    dsc2 = xcalloc( 1, grpdsc_len[1] );
    dsc2->length = grpdsc_len[1];
    dsc2->type = OFPGT_INDIRECT;
    dsc2->group_id = 0x55667788;
    memcpy( dsc2->buckets, bucket_testdata[1], bucket_testdata_len[1] );

    create_list( &expected_list );
    append_to_tail( &expected_list, dsc1 );
    append_to_tail( &expected_list, dsc2 );

    buffer = create_group_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

    assert_int_equal( 0, validate_group_desc_multipart_reply( buffer ) );

    delete_bucket_testdata();
    xfree( dsc1 );
    xfree( dsc2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  {
    buffer = create_group_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, NULL );

    assert_int_equal( 0, validate_group_desc_multipart_reply( buffer ) );

    free_buffer( buffer );
  }

  expect_assert_failure( validate_group_desc_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_group_desc_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_group_features_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_group_features_multipart_request() {
  buffer *buffer;

  buffer = create_group_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_group_features_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_group_features_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_group_features_multipart_request( NULL ) );
}


static void
test_validate_group_features_multipart_request_fails_if_message_is_not_group_features_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_group_features_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_group_features_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_group_features_multipart_reply() {
  buffer *buffer;
  struct ofp_group_features *grpftr;

  {
    uint16_t grpftr_len = sizeof( struct ofp_group_features );
    grpftr = xcalloc( 1, grpftr_len );
    grpftr->types = OFPGT_SELECT;
    grpftr->capabilities = OFPGFC_CHAINING;
    grpftr->max_groups[0] = 1;
    grpftr->max_groups[1] = 2;
    grpftr->max_groups[2] = 3;
    grpftr->max_groups[3] = 4;
    grpftr->actions[0] = 5;
    grpftr->actions[1] = 6;
    grpftr->actions[2] = 7;
    grpftr->actions[3] = 8;

    buffer = create_group_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, grpftr->types,
      grpftr->capabilities, grpftr->max_groups, grpftr->actions );

    assert_int_equal( 0, validate_group_features_multipart_reply( buffer ) );

    xfree( grpftr );
    free_buffer( buffer );
  }

  expect_assert_failure( validate_group_features_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_group_features_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_meter_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_meter_multipart_request() {
  uint32_t meter_id = 10;
  buffer *buffer;

  buffer = create_meter_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, meter_id );

  assert_int_equal( validate_meter_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_meter_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_meter_multipart_request( NULL ) );
}


static void
test_validate_meter_multipart_request_fails_if_message_is_not_meter_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_meter_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_meter_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_meter_multipart_reply() {
  uint16_t mtrsts_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_meter_stats *mtr1, *mtr2;
  struct ofp_meter_band_stats *mtrbnd;

  {
    mtrsts_len[0] = ( uint16_t ) ( offsetof( struct ofp_meter_stats, band_stats ) + sizeof( struct ofp_meter_band_stats ) );
    mtr1 = xcalloc( 1, mtrsts_len[0] );
    mtr1->meter_id = 0xaabbccdd;
    mtr1->len = mtrsts_len[0];
    mtr1->flow_count = 1;
    mtr1->packet_in_count = 2;
    mtr1->byte_in_count = 3;
    mtr1->duration_sec = 4;
    mtr1->duration_nsec = 5;
    mtrbnd = mtr1->band_stats;
    mtrbnd->packet_band_count = 0x11223344;
    mtrbnd->byte_band_count = 0x55667788;

    mtrsts_len[1] = ( uint16_t ) ( offsetof( struct ofp_meter_stats, band_stats ) + sizeof( struct ofp_meter_band_stats ) );
    mtr2 = xcalloc( 1, mtrsts_len[1] );
    mtr2->meter_id = 0x12345566;
    mtr2->len = mtrsts_len[1];
    mtr2->flow_count = 1;
    mtr2->packet_in_count = 2;
    mtr2->byte_in_count = 3;
    mtr2->duration_sec = 4;
    mtr2->duration_nsec = 5;
    mtrbnd = mtr2->band_stats;
    mtrbnd->packet_band_count = 0x11223344;
    mtrbnd->byte_band_count = 0x55667788;

    create_list( &expected_list );
    append_to_tail( &expected_list, mtr1 );
    append_to_tail( &expected_list, mtr2 );

    buffer = create_meter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

    assert_int_equal( 0, validate_meter_multipart_reply( buffer ) );

    xfree( mtr1 );
    xfree( mtr2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  {
    buffer = create_meter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, NULL );

    assert_int_equal( 0, validate_meter_multipart_reply( buffer ) );

    free_buffer( buffer );
  }

  expect_assert_failure( validate_meter_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_meter_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_meter_config_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_meter_config_multipart_request() {
  uint32_t meter_id = 10;
  buffer *buffer;

  buffer = create_meter_config_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, meter_id );

  assert_int_equal( validate_meter_config_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_meter_config_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_meter_config_multipart_request( NULL ) );
}


static void
test_validate_meter_config_multipart_request_fails_if_message_is_not_meter_config_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_meter_config_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_meter_config_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_meter_config_multipart_reply() {
  uint16_t mtrcfg_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_meter_config *mtr1, *mtr2;
  struct ofp_meter_band_drop *mtrbnd;

  {
    mtrcfg_len[0] = ( uint16_t ) ( offsetof( struct ofp_meter_config, bands ) + sizeof( struct ofp_meter_band_drop ) );
    mtr1 = xcalloc( 1, mtrcfg_len[0] );
    mtr1->length = mtrcfg_len[0];
    mtr1->flags = OFPMC_MODIFY;
    mtr1->meter_id = 1;
    mtrbnd = ( struct ofp_meter_band_drop * ) mtr1->bands;
    mtrbnd->type = OFPMBT_DROP;
    mtrbnd->len = sizeof( struct ofp_meter_band_drop );
    mtrbnd->rate = 0x11223344;
    mtrbnd->burst_size = 0x55667788;

    mtrcfg_len[1] = ( uint16_t ) ( offsetof( struct ofp_meter_config, bands ) + sizeof( struct ofp_meter_band_drop ) );
    mtr2 = xcalloc( 1, mtrcfg_len[1] );
    mtr2->length = mtrcfg_len[1];
    mtr2->flags = OFPMC_DELETE;
    mtr2->meter_id = 1;
    mtrbnd = ( struct ofp_meter_band_drop * ) mtr2->bands;
    mtrbnd->type = OFPMBT_DROP;
    mtrbnd->len = sizeof( struct ofp_meter_band_drop );
    mtrbnd->rate = 0x12345555;
    mtrbnd->burst_size = 0x56789999;

    create_list( &expected_list );
    append_to_tail( &expected_list, mtr1 );
    append_to_tail( &expected_list, mtr2 );

    buffer = create_meter_config_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

    assert_int_equal( 0, validate_meter_config_multipart_reply( buffer ) );

    xfree( mtr1 );
    xfree( mtr2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  {
    buffer = create_meter_config_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, NULL );

    assert_int_equal( 0, validate_meter_config_multipart_reply( buffer ) );

    free_buffer( buffer );
  }

  expect_assert_failure( validate_meter_config_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_meter_config_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_meter_features_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_meter_features_multipart_request() {
  buffer *buffer;

  buffer = create_meter_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_meter_features_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_meter_features_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_meter_features_multipart_request( NULL ) );
}


static void
test_validate_meter_features_multipart_request_fails_if_message_is_not_meter_features_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_meter_features_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_meter_features_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_meter_features_multipart_reply() {
  uint16_t mtrftr_len;
  buffer *buffer;
  struct ofp_meter_features *mtrftr;

  {
    mtrftr_len = sizeof( struct ofp_meter_features );
    mtrftr = xcalloc( 1, mtrftr_len );
    mtrftr->max_meter = 0x12345678;
    mtrftr->band_types = OFPMBT_DSCP_REMARK;
    mtrftr->capabilities = OFPMF_STATS;
    mtrftr->max_bands = 1;
    mtrftr->max_color = 2;

    buffer = create_meter_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, mtrftr->max_meter,
      mtrftr->band_types, mtrftr->capabilities, mtrftr->max_bands, mtrftr->max_color );

    assert_int_equal( 0, validate_meter_features_multipart_reply( buffer ) );

    xfree( mtrftr );
    free_buffer( buffer );
  }

  expect_assert_failure( validate_meter_features_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_meter_features_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_table_features_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_table_features_multipart_request() {
  uint16_t tblftr_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_table_features *ftr1, *ftr2;
  struct ofp_table_feature_prop_next_tables *nxttbl;
  uint16_t prop_len, prop_pad_len;

  // with table_features 
  {
    prop_len = ( uint16_t ) ( sizeof( struct ofp_table_feature_prop_next_tables ) + sizeof( uint8_t ) * 2 );
    prop_pad_len = ( uint16_t ) ( prop_len + PADLEN_TO_64( prop_len ) );

    tblftr_len[0] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr1 = xcalloc( 1, tblftr_len[0] );
    ftr1->length = tblftr_len[0];
    ftr1->table_id = 1;
    memcpy( ftr1->name, "table 1", sizeof( ftr1->name ) );
    ftr1->metadata_match = 0x1234567890123456;
    ftr1->metadata_write = 0x6543210987654321;
    ftr1->config = 11011;
    ftr1->max_entries = 10;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr1 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    tblftr_len[1] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr2 = xcalloc( 1, tblftr_len[1] );
    ftr2->length = tblftr_len[1];
    ftr2->table_id = 2;
    memcpy( ftr2->name, "table 2", sizeof( ftr2->name ) );
    ftr2->metadata_match = 0x1122334455667788;
    ftr2->metadata_write = 0x99AABBCCDDEEFF00;
    ftr2->config = 22022;
    ftr2->max_entries = 20;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr2 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES_MISS;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    create_list( &expected_list );
    append_to_tail( &expected_list, ftr1 );
    append_to_tail( &expected_list, ftr2 );

    buffer = create_table_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

    assert_int_equal( validate_table_features_multipart_request( buffer ), 0 );

    xfree( ftr1 );
    xfree( ftr2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  // without table_features 
  {
    buffer = create_table_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, NULL );

    assert_int_equal( validate_table_features_multipart_request( buffer ), 0 );

    free_buffer( buffer );
  }
}


static void
test_validate_table_features_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_table_features_multipart_request( NULL ) );
}


static void
test_validate_table_features_multipart_request_fails_if_message_is_not_table_features_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_table_features_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_table_features_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_table_features_multipart_reply() {
  uint16_t tblftr_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_table_features *ftr1, *ftr2;
  struct ofp_table_feature_prop_next_tables *nxttbl;

  // with table_features
  {
    uint16_t prop_len = ( uint16_t ) ( sizeof( struct ofp_table_feature_prop_next_tables ) + sizeof( uint8_t ) * 2 );
    uint16_t prop_pad_len = ( uint16_t ) ( prop_len + PADLEN_TO_64( prop_len ) );

    tblftr_len[0] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr1 = xcalloc( 1, tblftr_len[0] );
    ftr1->length = tblftr_len[0];
    ftr1->table_id = 1;
    memcpy( ftr1->name, "table 1", sizeof( ftr1->name ) );
    ftr1->metadata_match = 0x1234567890123456;
    ftr1->metadata_write = 0x6543210987654321;
    ftr1->config = 11011;
    ftr1->max_entries = 10;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr1 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    tblftr_len[1] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
    ftr2 = xcalloc( 1, tblftr_len[1] );
    ftr2->length = tblftr_len[1];
    ftr2->table_id = 2;
    memcpy( ftr2->name, "table 2", sizeof( ftr2->name ) );
    ftr2->metadata_match = 0x1122334455667788;
    ftr2->metadata_write = 0x99AABBCCDDEEFF00;
    ftr2->config = 22022;
    ftr2->max_entries = 20;
    nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr2 + sizeof( struct ofp_table_features ) );
    nxttbl->type = OFPTFPT_NEXT_TABLES_MISS;
    nxttbl->length = prop_len;
    nxttbl->next_table_ids[0] = 0x1A;
    nxttbl->next_table_ids[1] = 0x1B;

    create_list( &expected_list );
    append_to_tail( &expected_list, ftr1 );
    append_to_tail( &expected_list, ftr2 );

    buffer = create_table_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

    assert_int_equal( 0, validate_table_features_multipart_reply( buffer ) );

    xfree( ftr1 );
    xfree( ftr2 );
    delete_list( expected_list );
    free_buffer( buffer );
  }

  // without table_features
  {
    buffer = create_table_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, NULL );

    assert_int_equal( 0, validate_table_features_multipart_reply( buffer ) );

    free_buffer( buffer );
  }

  expect_assert_failure( validate_table_features_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_table_features_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_port_desc_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_port_desc_multipart_request() {
  buffer *buffer;

  buffer = create_port_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_port_desc_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_port_desc_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_port_desc_multipart_request( NULL ) );
}


static void
test_validate_port_desc_multipart_request_fails_if_message_is_not_port_desc_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_port_desc_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_port_desc_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_port_desc_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *list;
  buffer *buffer;
  struct ofp_port *port1, *port2;

  {
    create_port_desc_testdata();

    port1 = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );
    memcpy( port1, port_desc_testdata[0], port_desc_testdata_len[0] );
    port2 = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );
    memcpy( port2, port_desc_testdata[1], port_desc_testdata_len[1] );

    create_list( &list );
    append_to_tail( &list, port1 );
    append_to_tail( &list, port2 );

    buffer = create_port_desc_multipart_reply( MY_TRANSACTION_ID, flags, list );

    assert_int_equal( 0, validate_port_desc_multipart_reply( buffer ) );

    delete_port_desc_testdata();
    xfree( port1 );
    xfree( port2 );
    delete_list( list );
    free_buffer( buffer );
  }

  {
    buffer = create_port_desc_multipart_reply( MY_TRANSACTION_ID, flags, NULL );

    assert_int_equal( 0, validate_port_desc_multipart_reply( buffer ) );

    free_buffer( buffer );
  }
  expect_assert_failure( validate_port_desc_multipart_reply( NULL ) );

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_port_desc_multipart_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_multipart_request_sucseed_with_OFPMP_DESC_message() {
  buffer *stats_desc_request = create_desc_multipart_request( MY_TRANSACTION_ID, 0 );

  assert_int_equal( validate_multipart_request( stats_desc_request ), NO_FLAGS );

  free_buffer( stats_desc_request );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_FLOW_message() {
  uint8_t table_id = 0xff;
  uint32_t out_port = 1;
  uint32_t out_group = 5;
  uint64_t cookie = 0x1234567890123456;
  uint64_t cookie_mask = 0x6543210987654321;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  // ofp_match
  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );
  }

  buffer *buffer = create_flow_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, match );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
  delete_oxm_matches( match );
  delete_oxm_match_testdata();
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_AGGREGATE_message() {
  uint8_t table_id = 0xff;
  uint32_t out_port = 1;
  uint32_t out_group = 5;
  uint64_t cookie = 0x1234567890123456;
  uint64_t cookie_mask = 0x6543210987654321;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  // ofp_match
  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );
  }

  buffer *buffer = create_aggregate_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, table_id, out_port, out_group, cookie, cookie_mask, match );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
  delete_oxm_matches( match );
  delete_oxm_match_testdata();
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_TABLE_message() {
  buffer *stats_table_request = create_table_multipart_request( MY_TRANSACTION_ID, 0 );

  assert_int_equal( validate_multipart_request( stats_table_request ), NO_FLAGS );

  free_buffer( stats_table_request );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_PORT_STATS_message() {
  uint32_t port_no = 1;
  buffer *buffer;

  buffer = create_port_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, port_no );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_QUEUE_message() {
  uint32_t port_no = 1;
  uint32_t queue_id = 10;
  buffer *buffer;

  buffer = create_queue_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, port_no, queue_id );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_GROUP_message() {
  uint32_t group_id = 10;
  buffer *buffer;

  buffer = create_group_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, group_id );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_GROUP_DESC_message() {
  buffer *buffer;

  buffer = create_group_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_GROUP_FEATURES_message() {
  buffer *buffer;

  buffer = create_group_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_METER_message() {
  uint32_t meter_id = 10;
  buffer *buffer;

  buffer = create_meter_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, meter_id );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_METER_CONFIG_message() {
  uint32_t meter_id = 10;
  buffer *buffer;

  buffer = create_meter_config_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, meter_id );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_METER_FEATURES_message() {
  buffer *buffer;

  buffer = create_meter_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_TABLE_FEATURES_message() {
  uint16_t tblftr_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_table_features *ftr1, *ftr2;
  struct ofp_table_feature_prop_next_tables *nxttbl;
  uint16_t prop_len, prop_pad_len;

  prop_len = ( uint16_t ) ( sizeof( struct ofp_table_feature_prop_next_tables ) + sizeof( uint8_t ) * 2 );
  prop_pad_len = ( uint16_t ) ( prop_len + PADLEN_TO_64( prop_len ) );

  tblftr_len[0] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
  ftr1 = xcalloc( 1, tblftr_len[0] );
  ftr1->length = tblftr_len[0];
  ftr1->table_id = 1;
  memcpy( ftr1->name, "table 1", sizeof( ftr1->name ) );
  ftr1->metadata_match = 0x1234567890123456;
  ftr1->metadata_write = 0x6543210987654321;
  ftr1->config = 11011;
  ftr1->max_entries = 10;
  nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr1 + sizeof( struct ofp_table_features ) );
  nxttbl->type = OFPTFPT_NEXT_TABLES;
  nxttbl->length = prop_len;
  nxttbl->next_table_ids[0] = 0x1A;
  nxttbl->next_table_ids[1] = 0x1B;

  tblftr_len[1] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
  ftr2 = xcalloc( 1, tblftr_len[1] );
  ftr2->length = tblftr_len[1];
  ftr2->table_id = 2;
  memcpy( ftr2->name, "table 2", sizeof( ftr2->name ) );
  ftr2->metadata_match = 0x1122334455667788;
  ftr2->metadata_write = 0x99AABBCCDDEEFF00;
  ftr2->config = 22022;
  ftr2->max_entries = 20;
  nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr2 + sizeof( struct ofp_table_features ) );
  nxttbl->type = OFPTFPT_NEXT_TABLES_MISS;
  nxttbl->length = prop_len;
  nxttbl->next_table_ids[0] = 0x1A;
  nxttbl->next_table_ids[1] = 0x1B;

  create_list( &expected_list );
  append_to_tail( &expected_list, ftr1 );
  append_to_tail( &expected_list, ftr2 );

  buffer = create_table_features_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  xfree( ftr1 );
  xfree( ftr2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_PORT_DESC_message() {
  buffer *buffer;

  buffer = create_port_desc_multipart_request( MY_TRANSACTION_ID, NO_FLAGS );

  assert_int_equal( validate_multipart_request( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_multipart_request_sucseed_with_OFPMP_EXPERIMENTER_message() {
  buffer *stats_experimenter_request = create_experimenter_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );

  assert_int_equal( validate_multipart_request( stats_experimenter_request ), 0 );

  free_buffer( stats_experimenter_request );
}


static void
test_validate_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_multipart_request( NULL ) );
}


static void
test_validate_multipart_request_fails_with_unsupported_multipart_type() {
  buffer *broken_stats_request = create_experimenter_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );
  struct ofp_multipart_request *stats_request = ( struct ofp_multipart_request * ) broken_stats_request->data;
  const uint16_t unsupported_stats_type = ( uint16_t ) -2;
  stats_request->type = htons( unsupported_stats_type );

  assert_int_equal( validate_multipart_request( broken_stats_request ), ERROR_UNSUPPORTED_STATS_TYPE );

  free_buffer( broken_stats_request );
}


/********************************************************************************
 * validate_multipart_reply() tests.
 ********************************************************************************/

static void
test_validate_multipart_reply_with_OFPMP_DESC_message() {
  const char mfr_desc[ DESC_STR_LEN ] = "Trema Corporation";
  const char hw_desc[ DESC_STR_LEN ] = "Switching Hub type:B - for Trema";
  const char sw_desc[ DESC_STR_LEN ] = "System - b - OS version 1.0.0";
  const char serial_num[ SERIAL_NUM_LEN ] = "SN101224";
  const char dp_desc[ DESC_STR_LEN ] = "readble datapath 1012-1103";
  buffer *desc_stats_reply = create_desc_multipart_reply( MY_TRANSACTION_ID, 0, mfr_desc, hw_desc, sw_desc, serial_num, dp_desc );

  assert_int_equal( validate_multipart_reply( desc_stats_reply ), 0 );

  free_buffer( desc_stats_reply );
}


static void
test_validate_multipart_reply_with_OFPMP_FLOW_message() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *expected_list;
  buffer *buffer;
  uint16_t stats_len = 0;
  struct ofp_flow_stats *expected_stats[ 2 ];
  struct ofp_instruction *inst;

  create_oxm_match_testdata();
  create_instruction_testdata();

  stats_len = ( uint16_t ) ( offsetof( struct ofp_flow_stats, match ) + expected_ofp_match_len + expected_ofp_instruction_len );

  expected_stats[ 0 ] = xcalloc( 1, stats_len );
  expected_stats[ 1 ] = xcalloc( 1, stats_len );

  expected_stats[ 0 ]->length = stats_len;
  expected_stats[ 0 ]->table_id = 1;
  expected_stats[ 0 ]->pad = 0;
  expected_stats[ 0 ]->duration_sec = 60;
  expected_stats[ 0 ]->duration_nsec = 10000;
  expected_stats[ 0 ]->priority = 1024;
  expected_stats[ 0 ]->idle_timeout = 60;
  expected_stats[ 0 ]->hard_timeout = 3600;
  expected_stats[ 0 ]->flags = OFPFF_NO_BYT_COUNTS;
  memset( expected_stats[ 0 ]->pad2, 0, sizeof( expected_stats[ 0 ]->pad2 ) );
  expected_stats[ 0 ]->cookie = 0x0102030405060708ULL;
  expected_stats[ 0 ]->packet_count = 1000;
  expected_stats[ 0 ]->byte_count = 100000;
  memcpy( &expected_stats[ 0 ]->match, expected_ofp_match, expected_ofp_match_len );
  inst = ( struct ofp_instruction * ) ( ( char * ) &expected_stats[ 0 ]->match + expected_ofp_match_len );
  memcpy( inst, expected_ofp_instruction, expected_ofp_instruction_len );

  memcpy( expected_stats[ 1 ], expected_stats[ 0 ], stats_len );
  expected_stats[ 1 ]->cookie = 0x0203040506070809ULL;

  create_list( &expected_list );
  append_to_tail( &expected_list, expected_stats[ 0 ] );
  append_to_tail( &expected_list, expected_stats[ 1 ] );

  buffer = create_flow_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

  assert_int_equal( validate_multipart_reply( buffer ), 0 );

  xfree( expected_stats[ 0 ] );
  xfree( expected_stats[ 1 ] );
  delete_list( expected_list );

  delete_oxm_match_testdata();
  delete_instruction_testdata();
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_AGGREGATE_message() {
  uint32_t flow_count = 1000;
  uint64_t packet_count = RECEIVED_PACKETS;
  uint64_t byte_count = RECEIVED_BYTES;
  buffer *aggregate_stats_reply = create_aggregate_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, packet_count, byte_count, flow_count );

  assert_int_equal( validate_multipart_reply( aggregate_stats_reply ), 0 );

  free_buffer( aggregate_stats_reply );
}


static void
test_validate_multipart_reply_with_OFPMP_TABLE_message() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  uint16_t stats_len;
  list_element *expected_list;
  struct ofp_table_stats *stats[ 2 ];
  buffer *expected_message = NULL;
  int ret_val;

  {
    stats_len = sizeof( struct ofp_table_stats );

    stats[ 0 ] = xcalloc( 1, stats_len );
    stats[ 1 ] = xcalloc( 1, stats_len );

    stats[ 0 ]->table_id = 1;
    stats[ 0 ]->active_count = 1000;
    stats[ 0 ]->lookup_count = 100000;
    stats[ 0 ]->matched_count = 10000;

    memcpy( stats[ 1 ], stats[ 0 ], stats_len );
    stats[ 1 ]->table_id = 2;

    create_list( &expected_list );
    append_to_tail( &expected_list, stats[ 0 ] );
    append_to_tail( &expected_list, stats[ 1 ] );

    expected_message = create_table_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

    ret_val = validate_multipart_reply( expected_message );
    assert_int_equal( ret_val, 0 );

    xfree( stats[ 0 ] );
    xfree( stats[ 1 ] );
    delete_list( expected_list );
    free_buffer( expected_message );
  }
}


static void
test_validate_multipart_reply_with_OFPMP_PORT_STATS_message() {
  void *expected_data;
  uint16_t flags = OFPMPF_REPLY_MORE;
  uint16_t stats_len;
  list_element *expected_list;
  struct ofp_port_stats *stats[ 2 ];
  buffer *expected_message = NULL;
  int ret_val;

  {
    stats_len = sizeof( struct ofp_port_stats );

    stats[ 0 ] = xcalloc( 1, stats_len );
    stats[ 1 ] = xcalloc( 1, stats_len );

    stats[ 0 ]->port_no = 1;
    stats[ 0 ]->rx_packets = 10000;
    stats[ 0 ]->tx_packets = 20000;
    stats[ 0 ]->rx_bytes = 30000;
    stats[ 0 ]->tx_bytes = 40000;
    stats[ 0 ]->rx_dropped = 50000;
    stats[ 0 ]->tx_dropped = 60000;
    stats[ 0 ]->rx_errors = 70000;
    stats[ 0 ]->tx_errors = 80000;
    stats[ 0 ]->rx_frame_err = 1;
    stats[ 0 ]->rx_over_err = 2;
    stats[ 0 ]->rx_crc_err = 1;
    stats[ 0 ]->collisions = 3;
    stats[ 0 ]->duration_sec = 112233;
    stats[ 0 ]->duration_nsec = 445566;

    memcpy( stats[ 1 ], stats[ 0 ], stats_len );
    stats[ 1 ]->port_no = 2;

    create_list( &expected_list );
    append_to_tail( &expected_list, stats[ 0 ] );
    append_to_tail( &expected_list, stats[ 1 ] );

    expected_data = xcalloc( 1, ( size_t ) ( stats_len * 2 ) );
    memcpy( expected_data, stats[ 0 ], stats_len );
    memcpy( ( char * ) expected_data + stats_len, stats[ 1 ], stats_len );

    expected_message = create_port_multipart_reply( MY_TRANSACTION_ID, flags, expected_list );

    ret_val = validate_multipart_reply( expected_message );
    assert_int_equal( ret_val, 0 );

    xfree( stats[ 0 ] );
    xfree( stats[ 1 ] );
    xfree( expected_data );
    delete_list( expected_list );
    free_buffer( expected_message );
  }
}


static void
test_validate_multipart_reply_with_OFPMP_QUEUE_message() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *list;
  uint16_t stats_len;
  struct ofp_queue_stats *stats[ 2 ];
  buffer *buffer;

  stats_len = sizeof( struct ofp_queue_stats );

  stats[ 0 ] = xcalloc( 1, stats_len );
  stats[ 1 ] = xcalloc( 1, stats_len );

  stats[ 0 ]->port_no = 1;
  stats[ 0 ]->queue_id = 2;
  stats[ 0 ]->tx_bytes = 100000;
  stats[ 0 ]->tx_packets = 60000;
  stats[ 0 ]->tx_errors = 80;
  stats[ 0 ]->duration_sec = 0x12345678;
  stats[ 0 ]->duration_nsec = 0x87654321;

  memcpy( stats[ 1 ], stats[ 0 ], stats_len );
  stats[ 1 ]->queue_id = 3;

  create_list( &list );
  append_to_tail( &list, stats[ 0 ] );
  append_to_tail( &list, stats[ 1 ] );

  buffer = create_queue_multipart_reply( MY_TRANSACTION_ID, flags, list );

  assert_int_equal( validate_multipart_reply( buffer ), 0 );

  xfree( stats[ 0 ] );
  xfree( stats[ 1 ] );
  delete_list( list );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_GROUP_message() {
  size_t grpsts_0len, grpsts_1len;
  list_element *list;
  buffer *expected_message;
  struct ofp_group_stats *grpsts[ 2 ];
  struct ofp_bucket_counter *bktcnt;

  grpsts_0len = offsetof( struct ofp_group_stats, bucket_stats ) + sizeof( struct ofp_bucket_counter );
  grpsts_1len = offsetof( struct ofp_group_stats, bucket_stats ) + sizeof( struct ofp_bucket_counter );
  grpsts[ 0 ] = xcalloc( 1, grpsts_0len );
  grpsts[ 1 ] = xcalloc( 1, grpsts_1len );

  grpsts[ 0 ]->length = ( uint16_t ) grpsts_0len;
  grpsts[ 0 ]->group_id = 1;
  grpsts[ 0 ]->ref_count = 2;
  grpsts[ 0 ]->packet_count = 3;
  grpsts[ 0 ]->byte_count = 4;
  grpsts[ 0 ]->duration_sec = 5;
  grpsts[ 0 ]->duration_nsec = 6;
  bktcnt = ( struct ofp_bucket_counter * ) grpsts[ 0 ]->bucket_stats;
  bktcnt->packet_count = 7;
  bktcnt->byte_count = 8;

  grpsts[ 1 ]->length = ( uint16_t ) grpsts_1len;
  grpsts[ 1 ]->group_id = 11;
  grpsts[ 1 ]->ref_count = 12;
  grpsts[ 1 ]->packet_count = 13;
  grpsts[ 1 ]->byte_count = 14;
  grpsts[ 1 ]->duration_sec = 15;
  grpsts[ 1 ]->duration_nsec = 16;
  bktcnt = ( struct ofp_bucket_counter * ) grpsts[ 1 ]->bucket_stats;
  bktcnt->packet_count = 17;
  bktcnt->byte_count = 18;

  create_list( &list );
  append_to_tail( &list, grpsts[ 0 ] );
  append_to_tail( &list, grpsts[ 1 ] );

  expected_message = create_group_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, list );

  assert_int_equal( 0, validate_multipart_reply( expected_message ) );

  xfree( grpsts[ 0 ] );
  xfree( grpsts[ 1 ] );
  delete_list( list );
  free_buffer( expected_message );
}


static void
test_validate_multipart_reply_with_OFPMP_GROUP_DESC_message() {
  uint16_t grpdsc_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_group_desc_stats *dsc1, *dsc2;

  create_bucket_testdata();

  grpdsc_len[0] = ( uint16_t ) ( offsetof( struct ofp_group_desc_stats, buckets ) + bucket_testdata_len[0] );
  dsc1 = xcalloc( 1, grpdsc_len[0] );
  dsc1->length = grpdsc_len[0];
  dsc1->type = OFPGT_SELECT;
  dsc1->group_id = 0x11223344;
  memcpy( dsc1->buckets, bucket_testdata[0], bucket_testdata_len[0] );

  grpdsc_len[1] = ( uint16_t ) ( offsetof( struct ofp_group_desc_stats, buckets ) + bucket_testdata_len[1] );
  dsc2 = xcalloc( 1, grpdsc_len[1] );
  dsc2->length = grpdsc_len[1];
  dsc2->type = OFPGT_INDIRECT;
  dsc2->group_id = 0x55667788;
  memcpy( dsc2->buckets, bucket_testdata[1], bucket_testdata_len[1] );

  create_list( &expected_list );
  append_to_tail( &expected_list, dsc1 );
  append_to_tail( &expected_list, dsc2 );

  buffer = create_group_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  delete_bucket_testdata();
  xfree( dsc1 );
  xfree( dsc2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_GROUP_FEATURES_message() {
  buffer *buffer;
  struct ofp_group_features *grpftr;

  uint16_t grpftr_len = sizeof( struct ofp_group_features );
  grpftr = xcalloc( 1, grpftr_len );
  grpftr->types = OFPGT_SELECT;
  grpftr->capabilities = OFPGFC_CHAINING;
  grpftr->max_groups[0] = 1;
  grpftr->max_groups[1] = 2;
  grpftr->max_groups[2] = 3;
  grpftr->max_groups[3] = 4;
  grpftr->actions[0] = 5;
  grpftr->actions[1] = 6;
  grpftr->actions[2] = 7;
  grpftr->actions[3] = 8;

  buffer = create_group_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, grpftr->types,
    grpftr->capabilities, grpftr->max_groups, grpftr->actions );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  xfree( grpftr );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_METER_message() {
  uint16_t mtrsts_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_meter_stats *mtr1, *mtr2;
  struct ofp_meter_band_stats *mtrbnd;

  mtrsts_len[0] = ( uint16_t ) ( offsetof( struct ofp_meter_stats, band_stats ) + sizeof( struct ofp_meter_band_stats ) );
  mtr1 = xcalloc( 1, mtrsts_len[0] );
  mtr1->meter_id = 0xaabbccdd;
  mtr1->len = mtrsts_len[0];
  mtr1->flow_count = 1;
  mtr1->packet_in_count = 2;
  mtr1->byte_in_count = 3;
  mtr1->duration_sec = 4;
  mtr1->duration_nsec = 5;
  mtrbnd = mtr1->band_stats;
  mtrbnd->packet_band_count = 0x11223344;
  mtrbnd->byte_band_count = 0x55667788;

  mtrsts_len[1] = ( uint16_t ) ( offsetof( struct ofp_meter_stats, band_stats ) + sizeof( struct ofp_meter_band_stats ) );
  mtr2 = xcalloc( 1, mtrsts_len[1] );
  mtr2->meter_id = 0x12345566;
  mtr2->len = mtrsts_len[1];
  mtr2->flow_count = 1;
  mtr2->packet_in_count = 2;
  mtr2->byte_in_count = 3;
  mtr2->duration_sec = 4;
  mtr2->duration_nsec = 5;
  mtrbnd = mtr2->band_stats;
  mtrbnd->packet_band_count = 0x11223344;
  mtrbnd->byte_band_count = 0x55667788;

  create_list( &expected_list );
  append_to_tail( &expected_list, mtr1 );
  append_to_tail( &expected_list, mtr2 );

  buffer = create_meter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  xfree( mtr1 );
  xfree( mtr2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_METER_CONFIG_message() {
  uint16_t mtrcfg_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_meter_config *mtr1, *mtr2;
  struct ofp_meter_band_drop *mtrbnd;

  mtrcfg_len[0] = ( uint16_t ) ( offsetof( struct ofp_meter_config, bands ) + sizeof( struct ofp_meter_band_drop ) );
  mtr1 = xcalloc( 1, mtrcfg_len[0] );
  mtr1->length = mtrcfg_len[0];
  mtr1->flags = OFPMC_MODIFY;
  mtr1->meter_id = 1;
  mtrbnd = ( struct ofp_meter_band_drop * ) mtr1->bands;
  mtrbnd->type = OFPMBT_DROP;
  mtrbnd->len = sizeof( struct ofp_meter_band_drop );
  mtrbnd->rate = 0x11223344;
  mtrbnd->burst_size = 0x55667788;

  mtrcfg_len[1] = ( uint16_t ) ( offsetof( struct ofp_meter_config, bands ) + sizeof( struct ofp_meter_band_drop ) );
  mtr2 = xcalloc( 1, mtrcfg_len[1] );
  mtr2->length = mtrcfg_len[1];
  mtr2->flags = OFPMC_DELETE;
  mtr2->meter_id = 1;
  mtrbnd = ( struct ofp_meter_band_drop * ) mtr2->bands;
  mtrbnd->type = OFPMBT_DROP;
  mtrbnd->len = sizeof( struct ofp_meter_band_drop );
  mtrbnd->rate = 0x12345555;
  mtrbnd->burst_size = 0x56789999;

  create_list( &expected_list );
  append_to_tail( &expected_list, mtr1 );
  append_to_tail( &expected_list, mtr2 );

  buffer = create_meter_config_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  xfree( mtr1 );
  xfree( mtr2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_METER_FEATURES_message() {
  buffer *buffer;
  struct ofp_meter_features *mtrftr;

  uint16_t mtrftr_len = sizeof( struct ofp_meter_features );
  mtrftr = xcalloc( 1, mtrftr_len );
  mtrftr->max_meter = 0x12345678;
  mtrftr->band_types = OFPMBT_DSCP_REMARK;
  mtrftr->capabilities = OFPMF_STATS;
  mtrftr->max_bands = 1;
  mtrftr->max_color = 2;

  buffer = create_meter_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, mtrftr->max_meter,
    mtrftr->band_types, mtrftr->capabilities, mtrftr->max_bands, mtrftr->max_color );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  xfree( mtrftr );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_TABLE_FEATURES_message() {
  uint16_t tblftr_len[2];
  buffer *buffer;
  list_element *expected_list;
  struct ofp_table_features *ftr1, *ftr2;
  struct ofp_table_feature_prop_next_tables *nxttbl;

  uint16_t prop_len = ( uint16_t ) ( sizeof( struct ofp_table_feature_prop_next_tables ) + sizeof( uint8_t ) * 2 );
  uint16_t prop_pad_len = ( uint16_t ) ( prop_len + PADLEN_TO_64( prop_len ) );

  tblftr_len[0] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
  ftr1 = xcalloc( 1, tblftr_len[0] );
  ftr1->length = tblftr_len[0];
  ftr1->table_id = 1;
  memcpy( ftr1->name, "table 1", sizeof( ftr1->name ) );
  ftr1->metadata_match = 0x1234567890123456;
  ftr1->metadata_write = 0x6543210987654321;
  ftr1->config = 11011;
  ftr1->max_entries = 10;
  nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr1 + sizeof( struct ofp_table_features ) );
  nxttbl->type = OFPTFPT_NEXT_TABLES;
  nxttbl->length = prop_len;
  nxttbl->next_table_ids[0] = 0x1A;
  nxttbl->next_table_ids[1] = 0x1B;

  tblftr_len[1] = ( uint16_t ) ( sizeof( struct ofp_table_features ) + prop_pad_len );
  ftr2 = xcalloc( 1, tblftr_len[1] );
  ftr2->length = tblftr_len[1];
  ftr2->table_id = 2;
  memcpy( ftr2->name, "table 2", sizeof( ftr2->name ) );
  ftr2->metadata_match = 0x1122334455667788;
  ftr2->metadata_write = 0x99AABBCCDDEEFF00;
  ftr2->config = 22022;
  ftr2->max_entries = 20;
  nxttbl = ( struct ofp_table_feature_prop_next_tables * ) ( ( char * ) ftr2 + sizeof( struct ofp_table_features ) );
  nxttbl->type = OFPTFPT_NEXT_TABLES_MISS;
  nxttbl->length = prop_len;
  nxttbl->next_table_ids[0] = 0x1A;
  nxttbl->next_table_ids[1] = 0x1B;

  create_list( &expected_list );
  append_to_tail( &expected_list, ftr1 );
  append_to_tail( &expected_list, ftr2 );

  buffer = create_table_features_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_list );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  xfree( ftr1 );
  xfree( ftr2 );
  delete_list( expected_list );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_PORT_DESC_message() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *list;
  buffer *buffer;
  struct ofp_port *port1, *port2;

  create_port_desc_testdata();

  port1 = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );
  memcpy( port1, port_desc_testdata[0], port_desc_testdata_len[0] );
  port2 = ( struct ofp_port * ) xcalloc( 1, sizeof( struct ofp_port ) );
  memcpy( port2, port_desc_testdata[1], port_desc_testdata_len[1] );

  create_list( &list );
  append_to_tail( &list, port1 );
  append_to_tail( &list, port2 );

  buffer = create_port_desc_multipart_reply( MY_TRANSACTION_ID, flags, list );

  assert_int_equal( 0, validate_multipart_reply( buffer ) );

  delete_port_desc_testdata();
  xfree( port1 );
  xfree( port2 );
  delete_list( list );
  free_buffer( buffer );
}


static void
test_validate_multipart_reply_with_OFPMP_EXPERIMENTER_message() {
  buffer *experimenter_body = alloc_buffer_with_length( 128 );
  append_back_buffer( experimenter_body, 128 );
  memset( experimenter_body->data, 0xa1, experimenter_body->length );
  buffer *experimenter_stats_reply = create_experimenter_multipart_reply( MY_TRANSACTION_ID, 0, EXPERIMENTER_ID, EXPERIMENTER_TYPE, experimenter_body );

  assert_int_equal( validate_multipart_reply( experimenter_stats_reply ), 0 );

  free_buffer( experimenter_body );
  free_buffer( experimenter_stats_reply );
}


static void
test_validate_multipart_reply_fails_if_message_is_NULL() {
  expect_assert_failure( validate_multipart_reply( NULL ) );
}


static void
test_validate_multipart_reply_fails_with_unsupported_multipart_type() {
  buffer *broken_stats_reply = create_experimenter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );
  struct ofp_multipart_reply *stats_reply = ( struct ofp_multipart_reply * ) broken_stats_reply->data;
  const uint16_t unsupported_stats_type = ( uint16_t ) -2;
  stats_reply->type = htons( unsupported_stats_type );

  assert_int_equal( validate_multipart_reply( broken_stats_reply ), ERROR_UNSUPPORTED_STATS_TYPE );

  free_buffer( broken_stats_reply );
}


/********************************************************************************
 * validate_queue_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_queue_multipart_request() {
  buffer *port_stats_request = create_queue_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, OFPP_ANY, OFPQ_ALL );

  assert_int_equal( validate_queue_multipart_request( port_stats_request ), 0 );

  free_buffer( port_stats_request );
}


static void
test_validate_queue_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_queue_multipart_request( NULL ) );
}


static void
test_validate_queue_multipart_request_fails_if_message_is_not_queue_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_queue_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_queue_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_queue_multipart_reply() {
  uint16_t flags = OFPMPF_REPLY_MORE;
  list_element *list;
  uint16_t stats_len;
  struct ofp_queue_stats *stats[ 2 ];
  buffer *expected_message;
  int ret_val;

  stats_len = sizeof( struct ofp_queue_stats );

  stats[ 0 ] = xcalloc( 1, stats_len );
  stats[ 1 ] = xcalloc( 1, stats_len );

  stats[ 0 ]->port_no = 1;
  stats[ 0 ]->queue_id = 2;
  stats[ 0 ]->tx_bytes = 100000;
  stats[ 0 ]->tx_packets = 60000;
  stats[ 0 ]->tx_errors = 80;
  stats[ 0 ]->duration_sec = 112233;
  stats[ 0 ]->duration_nsec = 445566;

  memcpy( stats[ 1 ], stats[ 0 ], stats_len );
  stats[ 1 ]->queue_id = 3;

  create_list( &list );
  append_to_tail( &list, stats[ 0 ] );
  append_to_tail( &list, stats[ 1 ] );

  expected_message = create_queue_multipart_reply( MY_TRANSACTION_ID, flags, list );

  ret_val = validate_queue_multipart_reply( expected_message );
  assert_int_equal( ret_val, 0 );

  xfree( stats[ 0 ] );
  xfree( stats[ 1 ] );
  delete_list( list );
  free_buffer( expected_message );
}


/********************************************************************************
 * validate_experimenter_multipart_request() tests.
 ********************************************************************************/

static void
test_validate_experimenter_multipart_request() {
  buffer *experimenter_stats_request = create_experimenter_multipart_request( MY_TRANSACTION_ID, NO_FLAGS, EXPERIMENTER_ID, EXPERIMENTER_TYPE, NULL );

  assert_int_equal( validate_experimenter_multipart_request( experimenter_stats_request ), 0 );

  free_buffer( experimenter_stats_request );
}


static void
test_validate_experimenter_multipart_request_fails_if_message_is_NULL() {
  expect_assert_failure( validate_experimenter_multipart_request( NULL ) );
}


static void
test_validate_experimenter_multipart_request_fails_if_message_is_not_experimenter_multipart_request() {
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_experimenter_multipart_request( echo_request ), ERROR_INVALID_TYPE );

  free_buffer( echo_request );
}


/********************************************************************************
 * validate_experimenter_multipart_reply() test.
 ********************************************************************************/

static void
test_validate_experimenter_multipart_reply() {
  uint32_t expected_experimenter = EXPERIMENTER_ID;
  uint32_t expected_exp_type = EXPERIMENTER_TYPE;
  buffer *expected_message, *body;
  struct ofp_multipart_reply;
  int ret_val;

  body = alloc_buffer_with_length( 128 );
  append_back_buffer( body, 128 );
  memset( body->data, 0xa1, body->length );

  expected_message = create_experimenter_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, expected_experimenter, expected_exp_type, body );

  ret_val = validate_experimenter_multipart_reply( expected_message );
  assert_int_equal( ret_val, 0 );

  free_buffer( body );
  free_buffer( expected_message );
}


/********************************************************************************
 * validate_barrier_reply() test.
 ********************************************************************************/

static void
test_validate_barrier_reply() {
  buffer *expected_message;
  int ret_val;
  expected_message = create_barrier_reply( MY_TRANSACTION_ID );

  ret_val = validate_barrier_reply( expected_message );
  assert_int_equal( ret_val, 0 );
  free_buffer( expected_message );
}


/********************************************************************************
 * validate_queue_get_config_reply() test.
 ********************************************************************************/

static void
test_validate_queue_get_config_reply() {
  size_t queue_len;
  uint32_t port = 1;
  list_element *list;
  buffer *expected_message;
  struct ofp_packet_queue *queue[ 2 ];
  struct ofp_queue_prop_min_rate *prop_header;
  int ret_val;

  queue_len = offsetof( struct ofp_packet_queue, properties ) + sizeof( struct ofp_queue_prop_min_rate );
  queue[ 0 ] = xcalloc( 1, queue_len );
  queue[ 1 ] = xcalloc( 1, queue_len );

  queue[ 0 ]->queue_id = 1;
  queue[ 0 ]->len = ( uint16_t ) queue_len;
  prop_header = ( struct ofp_queue_prop_min_rate * ) queue[ 0 ]->properties;
  prop_header->prop_header.property = OFPQT_MIN_RATE;
  prop_header->prop_header.len = sizeof( struct ofp_queue_prop_min_rate );
  prop_header->rate = 1234;

  queue[ 1 ]->queue_id = 2;
  queue[ 1 ]->len = ( uint16_t ) queue_len;
  prop_header = ( struct ofp_queue_prop_min_rate * ) queue[ 1 ]->properties;
  prop_header->prop_header.property = OFPQT_MIN_RATE;
  prop_header->prop_header.len = sizeof( struct ofp_queue_prop_min_rate );
  prop_header->rate = 5678;

  create_list( &list );
  append_to_tail( &list, queue[ 0 ] );
  append_to_tail( &list, queue[ 1 ] );

  expected_message = create_queue_get_config_reply( MY_TRANSACTION_ID, port, list );

  ret_val = validate_queue_get_config_reply( expected_message );
  assert_int_equal( ret_val, 0 );

  xfree( queue[ 0 ] );
  xfree( queue[ 1 ] );
  delete_list( list );
  free_buffer( expected_message );
}


/********************************************************************************
 * validate_role_request() test.
 ********************************************************************************/

static void
test_validate_role_request() {
  uint32_t role = OFPCR_ROLE_SLAVE;
  uint64_t generation_id = 0x1234567890123456;
  buffer *buffer;

  expect_assert_failure( validate_role_request( NULL ) );

  {
    buffer = create_role_request( MY_TRANSACTION_ID, role, generation_id );

    int ret_val = validate_role_request( buffer );
    assert_int_equal( ret_val, 0 );

    free_buffer( buffer );
  }

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_role_request( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_role_reply() test.
 ********************************************************************************/

static void
test_validate_role_reply() {
  uint32_t role = OFPCR_ROLE_SLAVE;
  uint64_t generation_id = 0x1234567890123456;
  buffer *buffer;

  expect_assert_failure( validate_role_reply( NULL ) );

  {
    buffer = create_role_reply( MY_TRANSACTION_ID, role, generation_id );

    int ret_val = validate_role_reply( buffer );
    assert_int_equal( ret_val, 0 );

    free_buffer( buffer );
  }

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_role_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_get_async_request() test.
 ********************************************************************************/

static void
test_validate_get_async_request() {
  buffer *buffer;

  expect_assert_failure( validate_get_async_request( NULL ) );

  {
    buffer = create_get_async_request( MY_TRANSACTION_ID );

    int ret_val = validate_get_async_request( buffer );
    assert_int_equal( ret_val, 0 );

    free_buffer( buffer );
  }

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_get_async_request( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_get_async_reply() test.
 ********************************************************************************/

static void
test_validate_get_async_reply() {
  uint32_t packet_in_mask[2] = { OFPR_ACTION, OFPR_INVALID_TTL };
  uint32_t port_status_mask[2] = { OFPPR_DELETE, OFPPR_MODIFY };
  uint32_t flow_removed_mask[2] = { OFPRR_DELETE, OFPRR_GROUP_DELETE };
  buffer *buffer;

  expect_assert_failure( validate_get_async_reply( NULL ) );

  {
    buffer = create_get_async_reply( MY_TRANSACTION_ID, packet_in_mask, port_status_mask, flow_removed_mask );

    int ret_val = validate_get_async_reply( buffer );
    assert_int_equal( ret_val, 0 );

    free_buffer( buffer );
  }

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_get_async_reply( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_set_async() test.
 ********************************************************************************/

static void
test_validate_set_async() {
  uint32_t packet_in_mask[2] = { OFPR_ACTION, OFPR_INVALID_TTL };
  uint32_t port_status_mask[2] = { OFPPR_DELETE, OFPPR_MODIFY };
  uint32_t flow_removed_mask[2] = { OFPRR_DELETE, OFPRR_GROUP_DELETE };
  buffer *buffer;

  expect_assert_failure( validate_set_async( NULL ) );

  {
    buffer = create_set_async( MY_TRANSACTION_ID, packet_in_mask, port_status_mask, flow_removed_mask );

    int ret_val = validate_set_async( buffer );
    assert_int_equal( ret_val, 0 );

    free_buffer( buffer );
  }

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_set_async( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_meter_mod() test.
 ********************************************************************************/

static void
test_validate_meter_mod() {
  size_t band_0len, band_1len;
  uint16_t command = OFPMC_DELETE;
  uint16_t flags = ( uint16_t ) ( OFPMF_KBPS | OFPMF_PKTPS | OFPMF_BURST | OFPMF_STATS );
  uint32_t meter_id = 0x18273645;
  list_element *list;
  buffer *buffer;
  struct ofp_meter_band_drop *band_drop_header;
  struct ofp_meter_band_dscp_remark *band_dscp_remark_header;

  expect_assert_failure( validate_meter_mod( NULL ) );

  {
    band_0len = sizeof( struct ofp_meter_band_drop );
    band_1len = sizeof( struct ofp_meter_band_dscp_remark );
    band_drop_header = xcalloc( 1, band_0len );
    band_dscp_remark_header = xcalloc( 1, band_1len );

    band_drop_header->type = OFPMBT_DROP;
    band_drop_header->len = ( uint16_t ) band_0len;
    band_drop_header->rate = 0x01020304;
    band_drop_header->burst_size = 0x05060708;

    band_dscp_remark_header->type = OFPMBT_DSCP_REMARK;
    band_dscp_remark_header->len = ( uint16_t ) band_1len;
    band_dscp_remark_header->rate = 0x11223344;
    band_dscp_remark_header->burst_size = 0x55667788;
    band_dscp_remark_header->prec_level = 0x12;

    create_list( &list );
    append_to_tail( &list, band_drop_header );
    append_to_tail( &list, band_dscp_remark_header );

    buffer = create_meter_mod( MY_TRANSACTION_ID, command, flags, meter_id, list );

    int ret_val = validate_meter_mod( buffer );
    assert_int_equal( ret_val, 0 );

    xfree( band_drop_header );
    xfree( band_dscp_remark_header );
    delete_list( list );
    free_buffer( buffer );
  }

  {
    buffer = create_echo_request( MY_TRANSACTION_ID, NULL );

    assert_int_equal( validate_meter_mod( buffer ), ERROR_INVALID_TYPE );

    free_buffer( buffer );
  }
}


/********************************************************************************
 * validate_action_output() tests.
 ********************************************************************************/

static void
test_validate_action_output() {
  uint32_t port = 1;

  openflow_actions *actions = create_actions();
  append_action_output( actions, port, MAX_LENGTH_OF_SEND_PACKET );
  struct ofp_action_output action_output;
  hton_action_output( &action_output, ( struct ofp_action_output * ) ( actions->list->data ) );

  assert_int_equal( validate_action_output( &action_output ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_output_fails_with_invalid_action_type() {
  openflow_actions *actions = create_actions();
  append_action_set_queue( actions, 100 );
  struct ofp_action_set_queue action_set_queue;
  hton_action_set_queue( &action_set_queue, ( struct ofp_action_set_queue * ) ( actions->list->data ) );

  assert_int_equal( validate_action_output( ( struct ofp_action_output * ) &action_set_queue ), ERROR_INVALID_ACTION_TYPE );

  delete_actions( actions );
}


static void
test_validate_action_output_fails_with_too_short_ofp_action_output() {
  uint32_t port = 1;

  openflow_actions *actions = create_actions();
  append_action_output( actions, port, MAX_LENGTH_OF_SEND_PACKET );
  uint16_t too_short_action_length = sizeof( struct ofp_action_output ) - 1;
  ( ( struct ofp_action_output * ) ( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_output too_short_action_output;
  hton_action_output( &too_short_action_output, ( struct ofp_action_output * ) ( actions->list->data ) );

  assert_int_equal( validate_action_output( &too_short_action_output ), ERROR_TOO_SHORT_ACTION_OUTPUT );

  delete_actions( actions );
}


static void
test_validate_action_output_fails_with_too_long_ofp_action_output() {
  uint32_t port = 1;

  openflow_actions *actions = create_actions();
  append_action_output( actions, port, MAX_LENGTH_OF_SEND_PACKET );
  uint16_t too_long_action_length = sizeof( struct ofp_action_output ) + 1;
  ( ( struct ofp_action_output * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_output too_long_action_output;
  hton_action_output( &too_long_action_output, ( struct ofp_action_output * ) ( actions->list->data ) );

  assert_int_equal( validate_action_output( &too_long_action_output ), ERROR_TOO_LONG_ACTION_OUTPUT );

  delete_actions( actions );
}


static void
test_validate_action_output_fails_with_invalid_port_no() {
  uint32_t port = 0;

  openflow_actions *actions = create_actions();
  append_action_output( actions, port, MAX_LENGTH_OF_SEND_PACKET );
  struct ofp_action_output action_output;
  hton_action_output( &action_output, ( struct ofp_action_output * ) ( actions->list->data ) );

  assert_int_equal( validate_action_output( &action_output ), ERROR_INVALID_PORT_NO );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_set_queue() tests.
 ********************************************************************************/

static void
test_validate_action_set_queue() {
  uint32_t queue_id = 10;

  openflow_actions *actions = create_actions();
  append_action_set_queue( actions, queue_id );
  struct ofp_action_set_queue action_set_queue;
  hton_action_set_queue( &action_set_queue, ( struct ofp_action_set_queue * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_queue( &action_set_queue ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_set_queue_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_queue( ( struct ofp_action_set_queue * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_set_queue_fails_with_too_short_ofp_action_set_queue() {
  uint32_t queue_id = 10;

  openflow_actions *actions = create_actions();
  append_action_set_queue( actions, queue_id );
  uint16_t too_short_action_length = sizeof( struct ofp_action_set_queue ) - 1;
  ( ( struct ofp_action_set_queue * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_set_queue too_short_action_set_queue;
  hton_action_set_queue( &too_short_action_set_queue, ( struct ofp_action_set_queue * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_queue( &too_short_action_set_queue ), ERROR_TOO_SHORT_ACTION_SET_QUEUE );

  delete_actions( actions );
}


static void
test_validate_action_set_queue_fails_with_too_long_ofp_action_set_queue() {
  uint32_t queue_id = 10;

  openflow_actions *actions = create_actions();
  append_action_set_queue( actions, queue_id );
  uint16_t too_long_action_length = sizeof( struct ofp_action_set_queue ) + 1;
  ( ( struct ofp_action_set_queue * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_set_queue too_long_action_set_queue;
  hton_action_set_queue( &too_long_action_set_queue, ( struct ofp_action_set_queue * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_queue( &too_long_action_set_queue ), ERROR_TOO_LONG_ACTION_SET_QUEUE );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_copy_ttl_out() tests.
 ********************************************************************************/

static void
test_validate_action_copy_ttl_out() {
  openflow_actions *actions = create_actions();
  append_action_copy_ttl_out( actions );
  struct ofp_action_header action_copy_ttl_out;
  hton_action_header( &action_copy_ttl_out, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_out( &action_copy_ttl_out ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_copy_ttl_out_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_out( ( struct ofp_action_header * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_copy_ttl_out_with_too_short_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_copy_ttl_out( actions );
  uint16_t too_short_action_length = sizeof( struct ofp_action_header ) - 1;
  ( ( struct ofp_action_header * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_header too_short_action_copy_ttl_out;
  hton_action_header( &too_short_action_copy_ttl_out, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_out( &too_short_action_copy_ttl_out ), ERROR_TOO_SHORT_ACTION_COPY_TTL_OUT );

  delete_actions( actions );
}


static void
test_validate_action_copy_ttl_out_with_too_long_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_copy_ttl_out( actions );
  uint16_t too_long_action_length = sizeof( struct ofp_action_header ) + 1;
  ( ( struct ofp_action_header * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_header too_long_action_copy_ttl_out;
  hton_action_header( &too_long_action_copy_ttl_out, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_out( &too_long_action_copy_ttl_out ), ERROR_TOO_LONG_ACTION_COPY_TTL_OUT );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_copy_ttl_in() tests.
 ********************************************************************************/

static void
test_validate_action_copy_ttl_in() {
  openflow_actions *actions = create_actions();
  append_action_copy_ttl_in( actions );
  struct ofp_action_header action_copy_ttl_in;
  hton_action_header( &action_copy_ttl_in, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_in( &action_copy_ttl_in ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_copy_ttl_in_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_in( ( struct ofp_action_header * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_copy_ttl_in_with_too_short_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_copy_ttl_in( actions );
  uint16_t too_short_action_length = sizeof( struct ofp_action_header ) - 1;
  ( ( struct ofp_action_header * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_header too_short_action_copy_ttl_in;
  hton_action_header( &too_short_action_copy_ttl_in, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_in( &too_short_action_copy_ttl_in ), ERROR_TOO_SHORT_ACTION_COPY_TTL_IN );

  delete_actions( actions );
}


static void
test_validate_action_copy_ttl_in_with_too_long_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_copy_ttl_in( actions );
  uint16_t too_long_action_length = sizeof( struct ofp_action_header ) + 1;
  ( ( struct ofp_action_header * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_header too_long_action_copy_ttl_in;
  hton_action_header( &too_long_action_copy_ttl_in, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_copy_ttl_in( &too_long_action_copy_ttl_in ), ERROR_TOO_LONG_ACTION_COPY_TTL_IN );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_set_mpls_ttl() tests.
 ********************************************************************************/

static void
test_validate_action_set_mpls_ttl() {
  uint8_t mpls_ttl = 10;

  openflow_actions *actions = create_actions();
  append_action_set_mpls_ttl( actions, mpls_ttl );
  struct ofp_action_mpls_ttl action_set_mpls_ttl;
  hton_action_mpls_ttl( &action_set_mpls_ttl, ( struct ofp_action_mpls_ttl * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_mpls_ttl( &action_set_mpls_ttl ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_set_mpls_ttl_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_mpls_ttl( ( struct ofp_action_mpls_ttl * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_set_mpls_ttl_with_too_short_ofp_action_mpls_ttl() {
  uint8_t mpls_ttl = 10;

  openflow_actions *actions = create_actions();
  append_action_set_mpls_ttl( actions, mpls_ttl );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_mpls_ttl too_short_action_set_mpls_ttl;
  hton_action_mpls_ttl( &too_short_action_set_mpls_ttl, ( struct ofp_action_mpls_ttl * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_mpls_ttl( &too_short_action_set_mpls_ttl ), ERROR_TOO_SHORT_ACTION_SET_MPLS_TTL );

  delete_actions( actions );
}


static void
test_validate_action_set_mpls_ttl_with_too_long_ofp_action_mpls_ttl() {
  uint8_t mpls_ttl = 10;

  openflow_actions *actions = create_actions();
  append_action_set_mpls_ttl( actions, mpls_ttl );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_mpls_ttl too_long_action_set_mpls_ttl;
  hton_action_mpls_ttl( &too_long_action_set_mpls_ttl, ( struct ofp_action_mpls_ttl * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_mpls_ttl( &too_long_action_set_mpls_ttl ), ERROR_TOO_LONG_ACTION_SET_MPLS_TTL );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_dec_mpls_ttl() tests.
 ********************************************************************************/

static void
test_validate_action_dec_mpls_ttl() {
  openflow_actions *actions = create_actions();
  append_action_dec_mpls_ttl( actions );
  struct ofp_action_header action_dec_mpls_ttl;
  hton_action_header( &action_dec_mpls_ttl, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_mpls_ttl( &action_dec_mpls_ttl ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_dec_mpls_ttl_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_mpls_ttl( ( struct ofp_action_header * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_dec_mpls_ttl_with_too_short_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_dec_mpls_ttl( actions );
  uint16_t too_short_action_length = sizeof( struct ofp_action_header ) - 1;
  ( ( struct ofp_action_header * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_header too_short_action_dec_mpls_ttl;
  hton_action_header( &too_short_action_dec_mpls_ttl, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_mpls_ttl( &too_short_action_dec_mpls_ttl ), ERROR_TOO_SHORT_ACTION_DEC_MPLS_TTL );

  delete_actions( actions );
}


static void
test_validate_action_dec_mpls_ttl_with_too_long_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_dec_mpls_ttl( actions );
  uint16_t too_long_action_length = sizeof( struct ofp_action_header ) + 1;
  ( ( struct ofp_action_header * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_header too_long_action_dec_mpls_ttl;
  hton_action_header( &too_long_action_dec_mpls_ttl, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_mpls_ttl( &too_long_action_dec_mpls_ttl ), ERROR_TOO_LONG_ACTION_DEC_MPLS_TTL );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_push_vlan() tests.
 ********************************************************************************/

static void
test_validate_action_push_vlan() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_vlan( actions, ethertype );
  struct ofp_action_push action_push_vlan;
  hton_action_push( &action_push_vlan, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_vlan( &action_push_vlan ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_push_vlan_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_vlan( ( struct ofp_action_push * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_push_vlan_with_too_short_ofp_action_push() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_vlan( actions, ethertype );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_push too_short_action_push_vlan;
  hton_action_push( &too_short_action_push_vlan, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_vlan( &too_short_action_push_vlan ), ERROR_TOO_SHORT_ACTION_PUSH_VLAN );

  delete_actions( actions );
}


static void
test_validate_action_push_vlan_with_too_long_ofp_action_push() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_vlan( actions, ethertype );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_push too_long_action_push_vlan;
  hton_action_push( &too_long_action_push_vlan, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_vlan( &too_long_action_push_vlan ), ERROR_TOO_LONG_ACTION_PUSH_VLAN );

  delete_actions( actions );
}



/********************************************************************************
 * validate_action_pop_vlan() tests.
 ********************************************************************************/

static void
test_validate_action_pop_vlan() {
  openflow_actions *actions = create_actions();
  append_action_pop_vlan( actions );
  struct ofp_action_header action_pop_vlan;
  hton_action_header( &action_pop_vlan, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_vlan( &action_pop_vlan ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_pop_vlan_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_vlan( ( struct ofp_action_header * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_pop_vlan_with_too_short_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_pop_vlan( actions );
  uint16_t too_short_action_length = sizeof( struct ofp_action_header ) - 1;
  ( ( struct ofp_action_header * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_header too_short_action_pop_vlan;
  hton_action_header( &too_short_action_pop_vlan, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_vlan( &too_short_action_pop_vlan ), ERROR_TOO_SHORT_ACTION_POP_VLAN );

  delete_actions( actions );
}


static void
test_validate_action_pop_vlan_with_too_long_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_pop_vlan( actions );
  uint16_t too_long_action_length = sizeof( struct ofp_action_header ) + 1;
  ( ( struct ofp_action_header * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_header too_long_action_pop_vlan;
  hton_action_header( &too_long_action_pop_vlan, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_vlan( &too_long_action_pop_vlan ), ERROR_TOO_LONG_ACTION_POP_VLAN );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_push_mpls() tests.
 ********************************************************************************/

static void
test_validate_action_push_mpls() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_mpls( actions, ethertype );
  struct ofp_action_push action_push_mpls;
  hton_action_push( &action_push_mpls, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_mpls( &action_push_mpls ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_push_mpls_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_mpls( ( struct ofp_action_push * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_push_mpls_with_too_short_ofp_action_push() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_mpls( actions, ethertype );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_push too_short_action_push_mpls;
  hton_action_push( &too_short_action_push_mpls, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_mpls( &too_short_action_push_mpls ), ERROR_TOO_SHORT_ACTION_PUSH_MPLS );

  delete_actions( actions );
}


static void
test_validate_action_push_mpls_with_too_long_ofp_action_push() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_mpls( actions, ethertype );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_push too_long_action_push_mpls;
  hton_action_push( &too_long_action_push_mpls, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_mpls( &too_long_action_push_mpls ), ERROR_TOO_LONG_ACTION_PUSH_MPLS );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_pop_mpls() tests.
 ********************************************************************************/

static void
test_validate_action_pop_mpls() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_pop_mpls( actions, ethertype );
  struct ofp_action_pop_mpls action_pop_mpls;
  hton_action_pop_mpls( &action_pop_mpls, ( struct ofp_action_pop_mpls * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_mpls( &action_pop_mpls ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_pop_mpls_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_mpls( ( struct ofp_action_pop_mpls * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_pop_mpls_with_too_short_ofp_action_pop_mpls() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_pop_mpls( actions, ethertype );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_pop_mpls too_short_action_pop_mpls;
  hton_action_pop_mpls( &too_short_action_pop_mpls, ( struct ofp_action_pop_mpls * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_mpls( &too_short_action_pop_mpls ), ERROR_TOO_SHORT_ACTION_POP_MPLS );

  delete_actions( actions );
}


static void
test_validate_action_pop_mpls_with_too_long_ofp_action_pop_mpls() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_pop_mpls( actions, ethertype );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_pop_mpls too_long_action_pop_mpls;
  hton_action_pop_mpls( &too_long_action_pop_mpls, ( struct ofp_action_pop_mpls * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_mpls( &too_long_action_pop_mpls ), ERROR_TOO_LONG_ACTION_POP_MPLS );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_group() tests.
 ********************************************************************************/

static void
test_validate_action_group() {
  uint32_t group_id = 10;

  openflow_actions *actions = create_actions();
  append_action_group( actions, group_id );
  struct ofp_action_group action_group;
  hton_action_group( &action_group, ( struct ofp_action_group * ) ( actions->list->data ) );

  assert_int_equal( validate_action_group( &action_group ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_group_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_group( ( struct ofp_action_group * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_group_with_too_short_ofp_action_group() {
  uint32_t group_id = 10;

  openflow_actions *actions = create_actions();
  append_action_group( actions, group_id );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_group too_short_action_group;
  hton_action_group( &too_short_action_group, ( struct ofp_action_group * ) ( actions->list->data ) );

  assert_int_equal( validate_action_group( &too_short_action_group ), ERROR_TOO_SHORT_ACTION_GROUP );

  delete_actions( actions );
}


static void
test_validate_action_group_with_too_long_ofp_action_group() {
  uint32_t group_id = 10;

  openflow_actions *actions = create_actions();
  append_action_group( actions, group_id );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_group too_long_action_group;
  hton_action_group( &too_long_action_group, ( struct ofp_action_group * ) ( actions->list->data ) );

  assert_int_equal( validate_action_group( &too_long_action_group ), ERROR_TOO_LONG_ACTION_GROUP );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_set_nw_ttl() tests.
 ********************************************************************************/

static void
test_validate_action_set_nw_ttl() {
  uint8_t nw_ttl = 10;

  openflow_actions *actions = create_actions();
  append_action_set_nw_ttl( actions, nw_ttl );
  struct ofp_action_nw_ttl action_set_nw_ttl;
  hton_action_nw_ttl( &action_set_nw_ttl, ( struct ofp_action_nw_ttl * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_nw_ttl( &action_set_nw_ttl ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_set_nw_ttl_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_nw_ttl( ( struct ofp_action_nw_ttl * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_set_nw_ttl_with_too_short_ofp_action_nw_ttl() {
  uint8_t nw_ttl = 10;

  openflow_actions *actions = create_actions();
  append_action_set_nw_ttl( actions, nw_ttl );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_nw_ttl too_short_action_set_nw_ttl;
  hton_action_nw_ttl( &too_short_action_set_nw_ttl, ( struct ofp_action_nw_ttl * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_nw_ttl( &too_short_action_set_nw_ttl ), ERROR_TOO_SHORT_ACTION_SET_NW_TTL );

  delete_actions( actions );
}


static void
test_validate_action_set_nw_ttl_with_too_long_ofp_action_nw_ttl() {
  uint8_t nw_ttl = 10;

  openflow_actions *actions = create_actions();
  append_action_set_nw_ttl( actions, nw_ttl );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_nw_ttl too_long_action_set_nw_ttl;
  hton_action_nw_ttl( &too_long_action_set_nw_ttl, ( struct ofp_action_nw_ttl * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_nw_ttl( &too_long_action_set_nw_ttl ), ERROR_TOO_LONG_ACTION_SET_NW_TTL );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_dec_nw_ttl() tests.
 ********************************************************************************/

static void
test_validate_action_dec_nw_ttl() {
  openflow_actions *actions = create_actions();
  append_action_dec_nw_ttl( actions );
  struct ofp_action_header action_dec_nw_ttl;
  hton_action_header( &action_dec_nw_ttl, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_nw_ttl( &action_dec_nw_ttl ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_dec_nw_ttl_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_nw_ttl( ( struct ofp_action_header * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_dec_nw_ttl_with_too_short_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_dec_nw_ttl( actions );
  uint16_t too_short_action_length = sizeof( struct ofp_action_header ) - 1;
  ( ( struct ofp_action_header * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_header too_short_action_dec_nw_ttl;
  hton_action_header( &too_short_action_dec_nw_ttl, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_nw_ttl( &too_short_action_dec_nw_ttl ), ERROR_TOO_SHORT_ACTION_DEC_NW_TTL );

  delete_actions( actions );
}


static void
test_validate_action_dec_nw_ttl_with_too_long_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_dec_nw_ttl( actions );
  uint16_t too_long_action_length = sizeof( struct ofp_action_header ) + 1;
  ( ( struct ofp_action_header * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_header too_long_action_dec_nw_ttl;
  hton_action_header( &too_long_action_dec_nw_ttl, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_dec_nw_ttl( &too_long_action_dec_nw_ttl ), ERROR_TOO_LONG_ACTION_DEC_NW_TTL );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_set_field() tests.
 ********************************************************************************/

static void
test_validate_action_set_field() {
  openflow_actions *actions = create_actions();
  append_action_set_field_eth_type( actions, 0x0800 );
  uint16_t act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + sizeof( oxm_match_header ) + OXM_LENGTH( OXM_OF_ETH_TYPE ) );
  uint16_t act_pad_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );
  struct ofp_action_set_field *action_set_field = xcalloc( 1, act_pad_len );
  hton_action_set_field( action_set_field, ( struct ofp_action_set_field * ) ( actions->list->data ) );

  assert_int_equal( validate_action_set_field( action_set_field ), 0 );

  xfree( action_set_field );
  delete_actions( actions );
}


static void
test_validate_action_set_field_fails_with_invalid_action_type() {
  openflow_actions *actions = create_actions();
  append_action_set_field_eth_type( actions, 0x0800 );
  uint16_t act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + sizeof( oxm_match_header ) + OXM_LENGTH( OXM_OF_ETH_TYPE ) );
  uint16_t act_pad_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );
  struct ofp_action_set_field *action_set_field = xcalloc( 1, act_pad_len );
  hton_action_set_field( action_set_field, ( struct ofp_action_set_field * ) ( actions->list->data ) );
  action_set_field->type = ( uint16_t ) htons( OFPAT_EXPERIMENTER );

  assert_int_equal( validate_action_set_field( action_set_field ), ERROR_INVALID_ACTION_TYPE );

  xfree( action_set_field );
  delete_actions( actions );}


static void
test_validate_action_set_field_with_too_short_ofp_action_set_field() {
  openflow_actions *actions = create_actions();
  append_action_set_field_eth_type( actions, 0x0800 );
  uint16_t act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + sizeof( oxm_match_header ) + OXM_LENGTH( OXM_OF_ETH_TYPE ) );
  uint16_t act_pad_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );
  struct ofp_action_set_field *action_set_field = xcalloc( 1, act_pad_len );
  hton_action_set_field( action_set_field, ( struct ofp_action_set_field * ) ( actions->list->data ) );
  action_set_field->len = ( uint16_t ) htons( ( uint16_t ) ( act_pad_len - 1 ) );

  assert_int_equal( validate_action_set_field( action_set_field ), ERROR_TOO_LONG_ACTION_SET_FIELD );

  xfree( action_set_field );
  delete_actions( actions );
}


static void
test_validate_action_set_field_with_too_long_ofp_action_set_field() {
  openflow_actions *actions = create_actions();
  append_action_set_field_eth_type( actions, 0x0800 );
  uint16_t act_len = ( uint16_t ) ( offsetof( struct ofp_action_set_field, field ) + sizeof( oxm_match_header ) + OXM_LENGTH( OXM_OF_ETH_TYPE ) );
  uint16_t act_pad_len = ( uint16_t ) ( act_len + PADLEN_TO_64( act_len ) );
  struct ofp_action_set_field *action_set_field = xcalloc( 1, act_pad_len );
  hton_action_set_field( action_set_field, ( struct ofp_action_set_field * ) ( actions->list->data ) );
  action_set_field->len = ( uint16_t ) htons( ( uint16_t ) ( act_pad_len - 1 ) );

  assert_int_equal( validate_action_set_field( action_set_field ), ERROR_TOO_LONG_ACTION_SET_FIELD );

  xfree( action_set_field );
  delete_actions( actions );
}


/********************************************************************************
 * validate_action_push_pbb() tests.
 ********************************************************************************/

static void
test_validate_action_push_pbb() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_pbb( actions, ethertype );
  struct ofp_action_push action_push_pbb;
  hton_action_push( &action_push_pbb, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_pbb( &action_push_pbb ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_push_pbb_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_pbb( ( struct ofp_action_push * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_push_pbb_with_too_short_ofp_action_push() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_pbb( actions, ethertype );
  uint16_t too_short_action_length = sizeof( struct ofp_action_push ) - 1;
  ( ( struct ofp_action_push * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_push too_short_action_push_pbb;
  hton_action_push( &too_short_action_push_pbb, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_pbb( &too_short_action_push_pbb ), ERROR_TOO_SHORT_ACTION_PUSH_PBB );

  delete_actions( actions );
}


static void
test_validate_action_push_pbb_with_too_long_ofp_action_push() {
  uint16_t ethertype = 10;

  openflow_actions *actions = create_actions();
  append_action_push_pbb( actions, ethertype );
  uint16_t too_long_action_length = sizeof( struct ofp_action_push ) + 1;
  ( ( struct ofp_action_push * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_push too_long_action_push_pbb;
  hton_action_push( &too_long_action_push_pbb, ( struct ofp_action_push * ) ( actions->list->data ) );

  assert_int_equal( validate_action_push_pbb( &too_long_action_push_pbb ), ERROR_TOO_LONG_ACTION_PUSH_PBB );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_pop_pbb() tests.
 ********************************************************************************/

static void
test_validate_action_pop_pbb() {
  openflow_actions *actions = create_actions();
  append_action_pop_pbb( actions );
  struct ofp_action_header action_pop_pbb;
  hton_action_header( &action_pop_pbb, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_pbb( &action_pop_pbb ), 0 );

  delete_actions( actions );
}


static void
test_validate_action_pop_pbb_fails_with_invalid_action_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_pbb( ( struct ofp_action_header * ) &action_experimenter ), ERROR_INVALID_ACTION_TYPE );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_pop_pbb_with_too_short_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_pop_pbb( actions );
  uint16_t too_short_action_length = sizeof( struct ofp_action_header ) - 1;
  ( ( struct ofp_action_header * )( actions->list->data ) )->len = too_short_action_length;
  struct ofp_action_header too_short_action_pop_pbb;
  hton_action_header( &too_short_action_pop_pbb, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_pbb( &too_short_action_pop_pbb ), ERROR_TOO_SHORT_ACTION_POP_PBB );

  delete_actions( actions );
}


static void
test_validate_action_pop_pbb_with_too_long_ofp_action_header() {
  openflow_actions *actions = create_actions();
  append_action_pop_pbb( actions );
  uint16_t too_long_action_length = sizeof( struct ofp_action_header ) + 1;
  ( ( struct ofp_action_header * ) ( actions->list->data ) )->len = too_long_action_length;
  struct ofp_action_header too_long_action_pop_pbb;
  hton_action_header( &too_long_action_pop_pbb, ( struct ofp_action_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_pop_pbb( &too_long_action_pop_pbb ), ERROR_TOO_LONG_ACTION_POP_PBB );

  delete_actions( actions );
}


/********************************************************************************
 * validate_action_experimenter() tests.
 ********************************************************************************/

static void
test_validate_action_experimenter() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_action_experimenter_header *action_experimenter = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( action_experimenter, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_experimenter( action_experimenter ), 0 );

  free_buffer( body );
  delete_actions( actions );
}


static void
test_validate_action_experimenter_fails_with_invalid_action_type() {
  uint32_t queue_id = 10;

  openflow_actions *actions = create_actions();
  append_action_set_queue( actions, queue_id );
  struct ofp_action_set_queue action_set_queue;
  hton_action_set_queue( &action_set_queue, ( struct ofp_action_set_queue * ) ( actions->list->data ) );

  assert_int_equal( validate_action_experimenter( ( struct ofp_action_experimenter_header * ) &action_set_queue ), ERROR_INVALID_ACTION_TYPE );

  delete_actions( actions );
}


static void
test_validate_action_experimenter_fails_with_too_short_ofp_action_experimenter_header() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_actions *actions = create_actions();
  append_action_experimenter( actions, EXPERIMENTER_ID, body );
  uint16_t too_short_action_length = sizeof( struct ofp_action_experimenter_header ) - 1;
  ( ( struct ofp_action_experimenter_header * )( actions->list->data ) )->len = too_short_action_length;
  char buf[128] = {};
  struct ofp_action_experimenter_header *too_short_action_experimenter_header = ( struct ofp_action_experimenter_header * ) buf;
  hton_action_experimenter( too_short_action_experimenter_header, ( struct ofp_action_experimenter_header * ) ( actions->list->data ) );

  assert_int_equal( validate_action_experimenter( too_short_action_experimenter_header ), ERROR_TOO_SHORT_ACTION_EXPERIMENTER );

  free_buffer( body );
  delete_actions( ( openflow_actions * ) actions );
}


/********************************************************************************
 * validate_instructions_goto_table() tests.
 ********************************************************************************/

static void
test_validate_instructions_goto_table() {
  uint8_t table_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_goto_table( instructions, table_id );
  struct ofp_instruction_goto_table instruction_goto_table;
  hton_instruction_goto_table( &instruction_goto_table, ( struct ofp_instruction_goto_table * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_goto_table( &instruction_goto_table ), 0 );

  delete_instructions( instructions );
}


static void
test_validate_instructions_goto_table_fails_with_invalid_instruction_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_goto_table( ( struct ofp_instruction_goto_table * ) instruction_experimenter ), ERROR_INVALID_INSTRUCTION_TYPE );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_goto_table_with_too_short_ofp_instruction_goto_table() {
  uint8_t table_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_goto_table( instructions, table_id );
  uint16_t too_short_instruction_length = sizeof( struct ofp_instruction_goto_table ) - 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_short_instruction_length;
  struct ofp_instruction_goto_table too_short_instruction_goto_table;
  hton_instruction_goto_table( &too_short_instruction_goto_table, ( struct ofp_instruction_goto_table * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_goto_table( &too_short_instruction_goto_table ), ERROR_TOO_SHORT_INSTRUCTION_GOTO_TABLE );

  delete_instructions( instructions );
}


static void
test_validate_instructions_goto_table_with_too_long_ofp_instruction_goto_table() {
  uint8_t table_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_goto_table( instructions, table_id );
  uint16_t too_long_instruction_length = sizeof( struct ofp_instruction_goto_table ) + 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_long_instruction_length;
  struct ofp_instruction_goto_table too_long_instruction_goto_table;
  hton_instruction_goto_table( &too_long_instruction_goto_table, ( struct ofp_instruction_goto_table * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_goto_table( &too_long_instruction_goto_table ), ERROR_TOO_LONG_INSTRUCTION_GOTO_TABLE );

  delete_instructions( instructions );
}


/********************************************************************************
 * validate_instructions_write_metadata() tests.
 ********************************************************************************/

static void
test_validate_instructions_write_metadata() {
  uint64_t metadata = 10;
  uint64_t metadata_mask = 20;

  openflow_instructions *instructions = create_instructions();
  append_instructions_write_metadata( instructions, metadata, metadata_mask );
  struct ofp_instruction_write_metadata instruction_write_metadata;
  hton_instruction_write_metadata( &instruction_write_metadata, ( struct ofp_instruction_write_metadata * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_write_metadata( &instruction_write_metadata ), 0 );

  delete_instructions( instructions );
}


static void
test_validate_instructions_write_metadata_fails_with_invalid_instruction_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_write_metadata( ( struct ofp_instruction_write_metadata * ) instruction_experimenter ), ERROR_INVALID_INSTRUCTION_TYPE );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_write_metadata_with_too_short_ofp_instruction_write_metadata() {
  uint64_t metadata = 10;
  uint64_t metadata_mask = 20;

  openflow_instructions *instructions = create_instructions();
  append_instructions_write_metadata( instructions, metadata, metadata_mask );
  uint16_t too_short_instruction_length = sizeof( struct ofp_instruction_write_metadata ) - 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_short_instruction_length;
  struct ofp_instruction_write_metadata too_short_instruction_write_metadata;
  hton_instruction_write_metadata( &too_short_instruction_write_metadata, ( struct ofp_instruction_write_metadata * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_write_metadata( &too_short_instruction_write_metadata ), ERROR_TOO_SHORT_INSTRUCTION_WRITE_METADATA );

  delete_instructions( instructions );
}


static void
test_validate_instructions_write_metadata_with_too_long_ofp_instruction_write_metadata() {
  uint64_t metadata = 10;
  uint64_t metadata_mask = 20;

  openflow_instructions *instructions = create_instructions();
  append_instructions_write_metadata( instructions, metadata, metadata_mask );
  uint16_t too_long_instruction_length = sizeof( struct ofp_instruction_write_metadata ) + 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_long_instruction_length;
  struct ofp_instruction_write_metadata too_long_instruction_write_metadata;
  hton_instruction_write_metadata( &too_long_instruction_write_metadata, ( struct ofp_instruction_write_metadata * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_write_metadata( &too_long_instruction_write_metadata ), ERROR_TOO_LONG_INSTRUCTION_WRITE_METADATA );

  delete_instructions( instructions );
}


/********************************************************************************
 * validate_instructions_write_actions() tests.
 ********************************************************************************/

static void
test_validate_instructions_write_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  uint16_t instruction_len;
  openflow_instructions *instructions = NULL;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  instructions = create_instructions();

  append_instructions_write_actions( instructions, actions );

  instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + action_testdata_len[0] + action_testdata_len[1] );
  struct ofp_instruction_actions *instruction_actions = xcalloc( 1, instruction_len );
  hton_instruction_actions( instruction_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_write_actions( instruction_actions ), 0 );


  xfree( instruction_actions );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


static void
test_validate_instructions_write_actions_fails_with_invalid_instruction_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_write_actions( ( struct ofp_instruction_actions * ) instruction_experimenter ), ERROR_INVALID_INSTRUCTION_TYPE );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_write_actions_with_too_short_ofp_instruction_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  uint16_t instruction_len;
  openflow_instructions *instructions = NULL;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  instructions = create_instructions();

  append_instructions_write_actions( instructions, actions );

  instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + action_testdata_len[0] + action_testdata_len[1] );
  struct ofp_instruction_actions *instruction_actions = xcalloc( 1, instruction_len );
  hton_instruction_actions( instruction_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );
  instruction_actions->len = htons( ( uint16_t ) ( instruction_len - 1 ) );

  assert_int_equal( validate_instructions_write_actions( instruction_actions ), ERROR_TOO_LONG_INSTRUCTION_WRITE_ACTIONS );

  xfree( instruction_actions );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


static void
test_validate_instructions_write_actions_with_too_long_ofp_instruction_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  uint16_t instruction_len;
  openflow_instructions *instructions = NULL;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  instructions = create_instructions();

  append_instructions_write_actions( instructions, actions );

  instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + action_testdata_len[0] + action_testdata_len[1] );
  struct ofp_instruction_actions *instruction_actions = xcalloc( 1, instruction_len );
  hton_instruction_actions( instruction_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );
  instruction_actions->len = htons( ( uint16_t ) ( instruction_len + 1 ) );

  assert_int_equal( validate_instructions_write_actions( instruction_actions ), ERROR_TOO_LONG_INSTRUCTION_WRITE_ACTIONS );

  xfree( instruction_actions );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


/********************************************************************************
 * validate_instructions_apply_actions() tests.
 ********************************************************************************/

static void
test_validate_instructions_apply_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  uint16_t instruction_len;
  openflow_instructions *instructions = NULL;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  instructions = create_instructions();

  append_instructions_apply_actions( instructions, actions );

  instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + action_testdata_len[0] + action_testdata_len[1] );
  struct ofp_instruction_actions *instruction_actions = xcalloc( 1, instruction_len );
  hton_instruction_actions( instruction_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_apply_actions( instruction_actions ), 0 );


  xfree( instruction_actions );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


static void
test_validate_instructions_apply_actions_fails_with_invalid_instruction_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_apply_actions( ( struct ofp_instruction_actions * ) instruction_experimenter ), ERROR_INVALID_INSTRUCTION_TYPE );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_apply_actions_with_too_short_ofp_instruction_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  uint16_t instruction_len;
  openflow_instructions *instructions = NULL;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  instructions = create_instructions();

  append_instructions_apply_actions( instructions, actions );

  instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + action_testdata_len[0] + action_testdata_len[1] );
  struct ofp_instruction_actions *instruction_actions = xcalloc( 1, instruction_len );
  hton_instruction_actions( instruction_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );
  instruction_actions->len = htons( ( uint16_t ) ( instruction_len - 1 ) );

  assert_int_equal( validate_instructions_apply_actions( instruction_actions ), ERROR_TOO_LONG_INSTRUCTION_APPLY_ACTIONS );

  xfree( instruction_actions );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


static void
test_validate_instructions_apply_actions_with_too_long_ofp_instruction_actions() {
  openflow_actions *actions;
  struct ofp_action_header *act1, *act2;
  uint16_t instruction_len;
  openflow_instructions *instructions = NULL;

  {
    create_action_testdata();

    act1 = xcalloc( 1, action_testdata_len[0] );
    memcpy( act1, action_testdata[0], action_testdata_len[0] );
    act2 = xcalloc( 1, action_testdata_len[1] );
    memcpy( act2, action_testdata[1], action_testdata_len[1] );

    actions = create_actions();
    actions->n_actions = 2;
    append_to_tail( &actions->list, act1 );
    append_to_tail( &actions->list, act2 );
  }

  instructions = create_instructions();

  append_instructions_apply_actions( instructions, actions );

  instruction_len = ( uint16_t ) ( offsetof( struct ofp_instruction_actions, actions ) + action_testdata_len[0] + action_testdata_len[1] );
  struct ofp_instruction_actions *instruction_actions = xcalloc( 1, instruction_len );
  hton_instruction_actions( instruction_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );
  instruction_actions->len = htons( ( uint16_t ) ( instruction_len + 1 ) );

  assert_int_equal( validate_instructions_apply_actions( instruction_actions ), ERROR_TOO_LONG_INSTRUCTION_APPLY_ACTIONS );

  xfree( instruction_actions );
  delete_actions( actions );
  delete_instructions( instructions );
  delete_action_testdata();
}


/********************************************************************************
 * validate_instructions_clear_actions() tests.
 ********************************************************************************/

static void
test_validate_instructions_clear_actions() {
  openflow_instructions *instructions = create_instructions();
  append_instructions_clear_actions( instructions );
  struct ofp_instruction_actions instruction_clear_actions;
  hton_instruction_actions( &instruction_clear_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_clear_actions( &instruction_clear_actions ), 0 );

  delete_instructions( instructions );
}


static void
test_validate_instructions_clear_actions_fails_with_invalid_instruction_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_clear_actions( ( struct ofp_instruction_actions * ) instruction_experimenter ), ERROR_INVALID_INSTRUCTION_TYPE );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_clear_actions_with_too_short_ofp_instruction_actions() {
  openflow_instructions *instructions = create_instructions();
  append_instructions_clear_actions( instructions );
  uint16_t too_short_instruction_length = sizeof( struct ofp_instruction_actions ) - 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_short_instruction_length;
  struct ofp_instruction_actions too_short_instruction_clear_actions;
  hton_instruction_actions( &too_short_instruction_clear_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_clear_actions( &too_short_instruction_clear_actions ), ERROR_TOO_SHORT_INSTRUCTION_CLEAR_ACTIONS );

  delete_instructions( instructions );
}


static void
test_validate_instructions_clear_actions_with_too_long_ofp_instruction_actions() {
  openflow_instructions *instructions = create_instructions();
  append_instructions_clear_actions( instructions );
  uint16_t too_long_instruction_length = sizeof( struct ofp_instruction_actions ) + 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_long_instruction_length;
  struct ofp_instruction_actions too_long_instruction_clear_actions;
  hton_instruction_actions( &too_long_instruction_clear_actions, ( struct ofp_instruction_actions * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_clear_actions( &too_long_instruction_clear_actions ), ERROR_TOO_LONG_INSTRUCTION_CLEAR_ACTIONS );

  delete_instructions( instructions );
}


/********************************************************************************
 * validate_instructions_meter() tests.
 ********************************************************************************/

static void
test_validate_instructions_meter() {
  uint32_t meter_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_meter( instructions, meter_id );
  struct ofp_instruction_meter instruction_meter;
  hton_instruction_meter( &instruction_meter, ( struct ofp_instruction_meter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_meter( &instruction_meter ), 0 );

  delete_instructions( instructions );
}


static void
test_validate_instructions_meter_fails_with_invalid_instruction_type() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_meter( ( struct ofp_instruction_meter * ) instruction_experimenter ), ERROR_INVALID_INSTRUCTION_TYPE );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_meter_with_too_short_ofp_instruction_meter() {
  uint32_t meter_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_meter( instructions, meter_id );
  uint16_t too_short_instruction_length = sizeof( struct ofp_instruction_meter ) - 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_short_instruction_length;
  struct ofp_instruction_meter too_short_instruction_meter;
  hton_instruction_meter( &too_short_instruction_meter, ( struct ofp_instruction_meter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_meter( &too_short_instruction_meter ), ERROR_TOO_SHORT_INSTRUCTION_METER );

  delete_instructions( instructions );
}


static void
test_validate_instructions_meter_with_too_long_ofp_instruction_meter() {
  uint32_t meter_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_meter( instructions, meter_id );
  uint16_t too_long_instruction_length = sizeof( struct ofp_instruction_meter ) + 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_long_instruction_length;
  struct ofp_instruction_meter too_long_instruction_meter;
  hton_instruction_meter( &too_long_instruction_meter, ( struct ofp_instruction_meter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_meter( &too_long_instruction_meter ), ERROR_TOO_LONG_INSTRUCTION_METER );

  delete_instructions( instructions );
}


/********************************************************************************
 * validate_instructions_experimenter() tests.
 ********************************************************************************/

static void
test_validate_instructions_experimenter() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  char buf[128] = {};
  struct ofp_instruction_experimenter *instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_experimenter( instruction_experimenter ), 0 );

  free_buffer( body );
  delete_instructions( instructions );
}


static void
test_validate_instructions_experimenter_fails_with_invalid_instruction_type() {
  uint32_t meter_id = 10;

  openflow_instructions *instructions = create_instructions();
  append_instructions_meter( instructions, meter_id );
  struct ofp_instruction_meter instruction_meter;
  hton_instruction_meter( &instruction_meter, ( struct ofp_instruction_meter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_experimenter( ( struct ofp_instruction_experimenter * ) &instruction_meter ), ERROR_INVALID_INSTRUCTION_TYPE );

  delete_instructions( instructions );
}


static void
test_validate_instructions_experimenter_with_too_short_ofp_instruction() {
  buffer *body = create_dummy_data( SHORT_DATA_LENGTH );
  openflow_instructions *instructions = create_instructions();
  append_instructions_experimenter( instructions, EXPERIMENTER_ID, body );
  uint16_t too_short_instruction_length = sizeof( struct ofp_instruction_experimenter ) - 1;
  ( ( struct ofp_instruction * )( instructions->list->data ) )->len = too_short_instruction_length;
  char buf[128] = {};
  struct ofp_instruction_experimenter *too_short_instruction_experimenter = ( struct ofp_instruction_experimenter * ) buf;
  hton_instruction_experimenter( too_short_instruction_experimenter, ( struct ofp_instruction_experimenter * ) ( instructions->list->data ) );

  assert_int_equal( validate_instructions_experimenter( too_short_instruction_experimenter ), ERROR_TOO_SHORT_INSTRUCTION_EXPERIMENTER );

  free_buffer( body );
  delete_instructions( instructions );
}


/********************************************************************************
 * validate_openflow_message() tests.
 ********************************************************************************/

static void
test_validate_openflow_message_succeeds_with_valid_OFPT_HELLO_message() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );

  assert_int_equal( validate_openflow_message( hello ), 0 );

  free_buffer( hello );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_ERROR_message() {
  buffer *dummy_data = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *error = create_error( MY_TRANSACTION_ID, OFPET_HELLO_FAILED, OFPHFC_INCOMPATIBLE, dummy_data );

  assert_int_equal( validate_openflow_message( error ), 0 );

  free_buffer( dummy_data );
  free_buffer( error );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_ECHO_REQUEST_message() {
  buffer *dummy_data = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *echo_request = create_echo_request( MY_TRANSACTION_ID, dummy_data );

  assert_int_equal( validate_openflow_message( echo_request ), 0 );

  free_buffer( dummy_data );
  free_buffer( echo_request );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_ECHO_REPLY_message() {
  buffer *dummy_data = create_dummy_data( SHORT_DATA_LENGTH );
  buffer *echo_reply = create_echo_reply( MY_TRANSACTION_ID, dummy_data );

  assert_int_equal( validate_openflow_message( echo_reply ), 0 );

  free_buffer( dummy_data );
  free_buffer( echo_reply );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_EXPERIMENTER_message() {
  buffer *dummy_data = create_dummy_data( 32 );
  buffer *experimenter = create_experimenter( MY_TRANSACTION_ID, EXPERIMENTER_ID, EXPERIMENTER_TYPE, dummy_data );

  assert_int_equal( validate_openflow_message( experimenter ), 0 );

  free_buffer( dummy_data );
  free_buffer( experimenter );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_FEATURES_REQUEST_message() {
  buffer *features_request = create_features_request( MY_TRANSACTION_ID );

  assert_int_equal( validate_openflow_message( features_request ), 0 );

  free_buffer( features_request );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_FEATURES_REPLY_message() {
  uint64_t datapath_id = 0x12345600;
  uint32_t n_buffers = 128;
  uint8_t n_tables = 1;
  uint8_t auxiliary_id = 0x89;
  uint32_t capabilities;
  buffer *expected_message = NULL;

  capabilities = ( OFPC_FLOW_STATS | OFPC_TABLE_STATS | OFPC_PORT_STATS | OFPC_GROUP_STATS | OFPC_IP_REASM | OFPC_QUEUE_STATS | OFPC_PORT_BLOCKED );

  expected_message = create_features_reply( MY_TRANSACTION_ID, datapath_id, n_buffers, n_tables, auxiliary_id, capabilities );

  assert_int_equal( validate_openflow_message( expected_message ), 0 );

  free_buffer( expected_message );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_GET_CONFIG_REQUEST_message() {
  buffer *get_config_request = create_get_config_request( MY_TRANSACTION_ID );

  assert_int_equal( validate_openflow_message( get_config_request ), 0 );

  free_buffer( get_config_request );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_GET_CONFIG_REPLY_message() {
  buffer *get_config_reply = create_get_config_reply( MY_TRANSACTION_ID, OFPC_FRAG_NORMAL, OFP_DEFAULT_MISS_SEND_LEN );

  assert_int_equal( validate_openflow_message( get_config_reply ), 0 );

  free_buffer( get_config_reply );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_SET_CONFIG_message() {
  buffer *set_config = create_set_config( MY_TRANSACTION_ID, OFPC_FRAG_NORMAL, OFP_DEFAULT_MISS_SEND_LEN );

  assert_int_equal( validate_openflow_message( set_config ), 0 );

  free_buffer( set_config );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_PACKET_IN_message() {
  uint16_t total_len;
  uint8_t reason = OFPR_INVALID_TTL;
  uint8_t table_id = 0x12;
  uint64_t cookie = 0x1122334455667788;
  buffer *expected_data = NULL;
  buffer *expected_message = NULL;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  expect_assert_failure( validate_packet_in( expected_message ) );

  create_oxm_match_testdata();

  oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
  memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
  oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
  memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

  match = create_oxm_matches();
  match->n_matches = 2;
  append_to_tail( &match->list, oxm1 );
  append_to_tail( &match->list, oxm2 );

  expected_data = create_dummy_data( LONG_DATA_LENGTH );
  total_len = ( uint16_t ) expected_data->length;
  expected_message = create_packet_in( MY_TRANSACTION_ID, BUFFER_ID, total_len, reason, table_id, cookie, match, expected_data );

  assert_int_equal( validate_openflow_message( expected_message ), 0 );

  delete_oxm_matches( match );
  delete_oxm_match_testdata();
  free_buffer( expected_data );
  free_buffer( expected_message );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_FLOW_REMOVED_message() {
  uint64_t cookie = 0x0102030405060708ULL;
  uint8_t reason = OFPRR_IDLE_TIMEOUT;
  uint8_t table_id = 0x12;
  uint32_t duration_sec = 180;
  uint32_t duration_nsec = 10000;
  uint16_t idle_timeout = 60;
  uint16_t hard_timeout = 900;
  uint64_t packet_count = 1000;
  uint64_t byte_count = 100000;
  buffer *expected_message = NULL;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  expect_assert_failure( validate_flow_removed( expected_message ) );

  create_oxm_match_testdata();

  oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
  memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
  oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
  memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

  match = create_oxm_matches();
  match->n_matches = 2;
  append_to_tail( &match->list, oxm1 );
  append_to_tail( &match->list, oxm2 );

  expected_message = create_flow_removed( MY_TRANSACTION_ID, cookie, PRIORITY, reason, table_id, duration_sec,
                                          duration_nsec, idle_timeout, hard_timeout, packet_count, byte_count, match );

  assert_int_equal( validate_openflow_message( expected_message ), 0 );

  delete_oxm_matches( match );
  delete_oxm_match_testdata();
  free_buffer( expected_message );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_PORT_STATUS_message() {
  uint8_t reason = OFPPR_ADD;
  struct ofp_port desc;
  buffer *expected_message = NULL;

  expect_assert_failure( validate_port_status( expected_message ) );

  desc.port_no = 1;
  memcpy( desc.hw_addr, HW_ADDR, sizeof( desc.hw_addr ) );
  memset( desc.name, '\0', OFP_MAX_PORT_NAME_LEN );
  strcpy( desc.name, "Navy" );
  desc.config = OFPPC_PORT_DOWN;
  desc.state = OFPPS_LINK_DOWN;
  desc.curr = ( OFPPF_1GB_FD | OFPPF_COPPER | OFPPF_PAUSE );
  desc.advertised = PORT_FEATURES;
  desc.supported = PORT_FEATURES;
  desc.peer = PORT_FEATURES;
  desc.curr_speed = 10000;
  desc.max_speed = 1000000;
  expected_message = create_port_status( MY_TRANSACTION_ID, reason, desc );

  assert_int_equal( validate_openflow_message( expected_message ), 0 );

  free_buffer( expected_message );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_PACKET_OUT_message() {
  openflow_actions *actions = create_actions();
  append_action_output( actions, 1, 128 );
  buffer *data = create_dummy_data( LONG_DATA_LENGTH );
  buffer *packet_out = create_packet_out( MY_TRANSACTION_ID, UINT32_MAX, 1, actions, data );

  assert_int_equal( validate_openflow_message( packet_out ), 0 );

  free_buffer( data );
  free_buffer( packet_out );
  delete_actions( actions );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_FLOW_MOD_message() {
  uint64_t cookie = 10;
  uint64_t cookie_mask = 20;
  uint8_t table_id = 0x12;
  uint16_t hard_timeout = 10;
  uint16_t idle_timeout = 5;
  uint32_t out_port = 1;
  uint32_t out_group = 2;

  oxm_matches *match;
  oxm_match_header *oxm1, *oxm2;

  openflow_instructions *instructions;
  struct ofp_instruction *inst1, *inst2;

  // ofp_match
  {
    create_oxm_match_testdata();

    oxm1 = xcalloc( 1, oxm_match_testdata_len[0] );
    memcpy( oxm1, oxm_match_testdata[0], oxm_match_testdata_len[0] );
    oxm2 = xcalloc( 1, oxm_match_testdata_len[1] );
    memcpy( oxm2, oxm_match_testdata[1], oxm_match_testdata_len[1] );

    match = create_oxm_matches();
    match->n_matches = 2;
    append_to_tail( &match->list, oxm1 );
    append_to_tail( &match->list, oxm2 );
  }

  // ofp_instruction
  {
    create_instruction_testdata();

    inst1 = xcalloc( 1, instruction_testdata_len[0] );
    memcpy( inst1, instruction_testdata[0], instruction_testdata_len[0] );
    inst2 = xcalloc( 1, instruction_testdata_len[1] );
    memcpy( inst2, instruction_testdata[1], instruction_testdata_len[1] );

    instructions = create_instructions();
    instructions->n_instructions = 2;
    append_to_tail( &instructions->list, inst1 );
    append_to_tail( &instructions->list, inst2 );
  }

  buffer *flow_mod = create_flow_mod( MY_TRANSACTION_ID, cookie, cookie_mask, table_id, OFPFC_ADD, idle_timeout, hard_timeout, PRIORITY,
                                      BUFFER_ID, out_port, out_group, OFPFF_CHECK_OVERLAP | OFPFF_SEND_FLOW_REM, match, instructions );

  assert_int_equal( validate_openflow_message( flow_mod ), 0 );

  free_buffer( flow_mod );
  delete_oxm_matches( match );
  delete_instructions( instructions );
  delete_oxm_match_testdata();
  delete_instruction_testdata();
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_GROUP_MOD_message() {
  uint16_t command = OFPGC_ADD;
  uint8_t type = OFPGT_SELECT;
  uint32_t group_id = 0x10023004;
  openflow_buckets *buckets;
  struct ofp_bucket *bkt1, *bkt2;

  create_bucket_testdata();

  bkt1 = xcalloc( 1, bucket_testdata_len[0] );
  memcpy( bkt1, bucket_testdata[0], bucket_testdata_len[0] );
  bkt2 = xcalloc( 1, bucket_testdata_len[1] );
  memcpy( bkt2, bucket_testdata[1], bucket_testdata_len[1] );

  buckets = create_buckets();
  append_to_tail( &buckets->list, bkt1 );
  append_to_tail( &buckets->list, bkt2 );
  buckets->n_buckets = 2;

  buffer *group_mod = create_group_mod( MY_TRANSACTION_ID, command, type, group_id, buckets );

  assert_int_equal( validate_openflow_message( group_mod ), 0 );

  free_buffer( group_mod );
  delete_buckets( buckets );
  delete_bucket_testdata();
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_PORT_MOD_message() {
  uint32_t port_no = 1;
  uint32_t mask = 0;
  uint32_t advertise = 1;
  buffer *port_mod = create_port_mod( MY_TRANSACTION_ID, port_no, HW_ADDR, OFPPC_PORT_DOWN, mask, advertise );

  assert_int_equal( validate_openflow_message( port_mod ), 0 );

  free_buffer( port_mod );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_TABLE_MOD_message() {
  uint8_t table_id = 0x12;
  uint32_t config = 0x12345678;

  buffer *table_mod = create_table_mod( MY_TRANSACTION_ID, table_id, config );

  assert_int_equal( validate_openflow_message( table_mod ), 0 );

  free_buffer( table_mod );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_MULTIPART_REQUEST_message() {
  buffer *stats_desc_request = create_desc_multipart_request( MY_TRANSACTION_ID, 0 );

  assert_int_equal( validate_openflow_message( stats_desc_request ), 0 );

  free_buffer( stats_desc_request );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_MULTIPART_REPLY_message() {
  const char mfr_desc[ DESC_STR_LEN ] = "NEC Corporation";
  const char hw_desc[ DESC_STR_LEN ] = "OpenFlow Switch Hardware";
  const char sw_desc[ DESC_STR_LEN ] = "OpenFlow Switch Software";
  const char serial_num[ SERIAL_NUM_LEN ] = "1234";
  const char dp_desc[ DESC_STR_LEN ] = "Datapath 0";

  buffer *stats_desc_reply = create_desc_multipart_reply( MY_TRANSACTION_ID, NO_FLAGS, mfr_desc, hw_desc, sw_desc, serial_num, dp_desc );

  assert_int_equal( validate_openflow_message( stats_desc_reply ), 0 );

  free_buffer( stats_desc_reply );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_BARRIER_REQUEST_message() {
  buffer *barrier_request = create_barrier_request( MY_TRANSACTION_ID );

  assert_int_equal( validate_openflow_message( barrier_request ), 0 );

  free_buffer( barrier_request );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_BARRIER_REPLY_message() {
  buffer *barrier_reply = create_barrier_reply( MY_TRANSACTION_ID );

  assert_int_equal( validate_openflow_message( barrier_reply ), 0 );

  free_buffer( barrier_reply );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_QUEUE_GET_CONFIG_REQUEST_message() {
  uint16_t port = 1;

  buffer *queue_get_config_request = create_queue_get_config_request( MY_TRANSACTION_ID, port );

  assert_int_equal( validate_openflow_message( queue_get_config_request ), 0 );

  free_buffer( queue_get_config_request );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_QUEUE_GET_CONFIG_REPLY_message() {
  size_t queue_len;
  uint32_t port = 1;
  list_element *list;
  buffer *expected_message;
  struct ofp_packet_queue *queue[ 2 ];
  struct ofp_queue_prop_min_rate *prop_header;

  queue_len = offsetof( struct ofp_packet_queue, properties ) + sizeof( struct ofp_queue_prop_min_rate );
  queue[ 0 ] = xcalloc( 1, queue_len );
  queue[ 1 ] = xcalloc( 1, queue_len );

  queue[ 0 ]->queue_id = 1;
  queue[ 0 ]->len = ( uint16_t ) queue_len;
  prop_header = ( struct ofp_queue_prop_min_rate * ) queue[ 0 ]->properties;
  prop_header->prop_header.property = OFPQT_MIN_RATE;
  prop_header->prop_header.len = sizeof( struct ofp_queue_prop_min_rate );
  prop_header->rate = 1234;

  queue[ 1 ]->queue_id = 2;
  queue[ 1 ]->len = ( uint16_t ) queue_len;
  prop_header = ( struct ofp_queue_prop_min_rate * ) queue[ 1 ]->properties;
  prop_header->prop_header.property = OFPQT_MIN_RATE;
  prop_header->prop_header.len = sizeof( struct ofp_queue_prop_min_rate );
  prop_header->rate = 5678;

  create_list( &list );
  append_to_tail( &list, queue[ 0 ] );
  append_to_tail( &list, queue[ 1 ] );

  expected_message = create_queue_get_config_reply( MY_TRANSACTION_ID, port, list );

  assert_int_equal( validate_openflow_message( expected_message ), 0 );

  xfree( queue[ 0 ] );
  xfree( queue[ 1 ] );
  delete_list( list );
  free_buffer( expected_message );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_ROLE_REQUEST_message() {
  uint32_t role = OFPCR_ROLE_SLAVE;
  uint64_t generation_id = 0x1234567890123456;
  buffer *buffer;

  expect_assert_failure( validate_role_request( NULL ) );

  buffer = create_role_request( MY_TRANSACTION_ID, role, generation_id );

  assert_int_equal( validate_openflow_message( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_ROLE_REPLY_message() {
  uint32_t role = OFPCR_ROLE_SLAVE;
  uint64_t generation_id = 0x1234567890123456;
  buffer *buffer;

  expect_assert_failure( validate_role_reply( NULL ) );

  buffer = create_role_reply( MY_TRANSACTION_ID, role, generation_id );

  assert_int_equal( validate_openflow_message( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_GET_ASYNC_REQUEST_message() {
  buffer *buffer;

  expect_assert_failure( validate_get_async_request( NULL ) );

  buffer = create_get_async_request( MY_TRANSACTION_ID );

  assert_int_equal( validate_openflow_message( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_GET_ASYNC_REPLY_message() {
  uint32_t packet_in_mask[2] = { OFPR_ACTION, OFPR_INVALID_TTL };
  uint32_t port_status_mask[2] = { OFPPR_DELETE, OFPPR_MODIFY };
  uint32_t flow_removed_mask[2] = { OFPRR_DELETE, OFPRR_GROUP_DELETE };
  buffer *buffer;

  expect_assert_failure( validate_get_async_reply( NULL ) );

  buffer = create_get_async_reply( MY_TRANSACTION_ID, packet_in_mask, port_status_mask, flow_removed_mask );

  assert_int_equal( validate_openflow_message( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_SET_ASYNC_message() {
  uint32_t packet_in_mask[2] = { OFPR_ACTION, OFPR_INVALID_TTL };
  uint32_t port_status_mask[2] = { OFPPR_DELETE, OFPPR_MODIFY };
  uint32_t flow_removed_mask[2] = { OFPRR_DELETE, OFPRR_GROUP_DELETE };
  buffer *buffer;

  expect_assert_failure( validate_set_async( NULL ) );

  buffer = create_set_async( MY_TRANSACTION_ID, packet_in_mask, port_status_mask, flow_removed_mask );

  assert_int_equal( validate_openflow_message( buffer ), 0 );

  free_buffer( buffer );
}


static void
test_validate_openflow_message_succeeds_with_valid_OFPT_METER_MOD_message() {
  size_t band_0len, band_1len;
  uint16_t command = OFPMC_DELETE;
  uint16_t flags = ( uint16_t ) ( OFPMF_KBPS | OFPMF_PKTPS | OFPMF_BURST | OFPMF_STATS );
  uint32_t meter_id = 0x18273645;
  list_element *list;
  buffer *buffer;
  struct ofp_meter_band_drop *band_drop_header;
  struct ofp_meter_band_dscp_remark *band_dscp_remark_header;

  expect_assert_failure( validate_meter_mod( NULL ) );

  band_0len = sizeof( struct ofp_meter_band_drop );
  band_1len = sizeof( struct ofp_meter_band_dscp_remark );
  band_drop_header = xcalloc( 1, band_0len );
  band_dscp_remark_header = xcalloc( 1, band_1len );

  band_drop_header->type = OFPMBT_DROP;
  band_drop_header->len = ( uint16_t ) band_0len;
  band_drop_header->rate = 0x01020304;
  band_drop_header->burst_size = 0x05060708;

  band_dscp_remark_header->type = OFPMBT_DSCP_REMARK;
  band_dscp_remark_header->len = ( uint16_t ) band_1len;
  band_dscp_remark_header->rate = 0x11223344;
  band_dscp_remark_header->burst_size = 0x55667788;
  band_dscp_remark_header->prec_level = 0x12;

  create_list( &list );
  append_to_tail( &list, band_drop_header );
  append_to_tail( &list, band_dscp_remark_header );

  buffer = create_meter_mod( MY_TRANSACTION_ID, command, flags, meter_id, list );

  assert_int_equal( validate_openflow_message( buffer ), 0 );

  xfree( band_drop_header );
  xfree( band_dscp_remark_header );
  delete_list( list );
  free_buffer( buffer );
}


static void
test_validate_openflow_message_fails_with_undefined_type_message() {
  uint8_t dummy_type = UINT8_MAX;

  buffer *undefined_type = create_dummy_data( sizeof( struct ofp_multipart_request ) );
  struct ofp_multipart_request *stats_request = ( struct ofp_multipart_request * ) undefined_type->data;
  stats_request->header.type = dummy_type;

  assert_int_equal( validate_openflow_message( undefined_type ), ERROR_UNDEFINED_TYPE );

  free_buffer( undefined_type );
}


static void
test_validate_openflow_message_fails_if_message_is_NULL() {
  expect_assert_failure( validate_openflow_message( NULL ) );
}


static void
test_validate_openflow_message_fails_if_data_is_NULL() {
  buffer *buf = alloc_buffer( );

  expect_assert_failure( validate_openflow_message( buf ) );

  free_buffer( buf );
}


/********************************************************************************
 * valid_openflow_message() tests.
 ********************************************************************************/

static void
test_valid_openflow_message() {
  buffer *hello = create_hello( MY_TRANSACTION_ID, NULL );

  assert_int_equal( valid_openflow_message( hello ), true );

  free_buffer( hello );
}


static void
test_valid_openflow_message_fails_with_undefined_type_message() {
  uint8_t dummy_type = UINT8_MAX;

  buffer *undefined_type = create_dummy_data( sizeof( struct ofp_multipart_request ) );
  struct ofp_multipart_request *stats_request = ( struct ofp_multipart_request * ) undefined_type->data;
  stats_request->header.type = dummy_type;

  assert_int_equal( valid_openflow_message( undefined_type ), false );

  free_buffer( undefined_type );
}


/********************************************************************************
 * get_error_type_and_code() tests.
 ********************************************************************************/

static void
test_get_error_type_and_code_succeeds_with_OFPT_ECHO_REQUEST_and_ERROR_UNSUPPORTED_VERSION() {
  uint16_t error_type = 0;
  uint16_t error_code = 0;

  assert_int_equal( get_error_type_and_code( OFPT_ECHO_REQUEST, ERROR_UNSUPPORTED_VERSION, &error_type, &error_code ), true );

  assert_int_equal( error_type, OFPET_BAD_REQUEST );
  assert_int_equal( error_code, OFPBRC_BAD_VERSION );
}


static void
test_get_error_type_and_code_succeeds_with_invalid_type_and_ERROR_UNSUPPORTED_VERSION() {
  uint16_t error_type = 0;
  uint16_t error_code = 0;
  uint8_t dummy_type = 56;

  assert_int_equal( get_error_type_and_code( dummy_type, ERROR_UNSUPPORTED_VERSION, &error_type, &error_code ), true );

  assert_int_equal( error_type, OFPET_BAD_REQUEST );
  assert_int_equal( error_code, OFPBRC_BAD_TYPE );
}


static void
test_get_error_type_and_code_fails_with_OFPT_ECHO_REQUEST_and_ERROR_TOO_SHORT_ACTION_OUTPUT() {
  uint16_t error_type = 0;
  uint16_t error_code = 0;

  assert_int_equal( get_error_type_and_code( OFPT_ECHO_REQUEST, ERROR_TOO_SHORT_ACTION_OUTPUT, &error_type, &error_code ), false );
}


/********************************************************************************
 * set_match_from_packet() tests.
 ********************************************************************************/

const char macda[] = {
    ( char ) 0xff, ( char ) 0xff, ( char ) 0xff, ( char ) 0xff, ( char ) 0xff, ( char ) 0xff
};
const char macsa[] = {
    ( char ) 0x00, ( char ) 0xd0, ( char ) 0x09, ( char ) 0x20, ( char ) 0x09, ( char ) 0xF7
};
const char snap_data[] = {
    ( char ) 0xaa, ( char ) 0xaa, ( char ) 0x03, ( char ) 0x00, ( char ) 0x00, ( char ) 0x00, ( char ) 0x08, ( char ) 0x00
};

const struct in6_addr v6sa = {{{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18
}}};
const struct in6_addr v6da = {{{
    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38
}}};

const uint16_t src_port = 1024;
const uint16_t dst_port = 2048;
const size_t ipv4_length = sizeof( ether_header_t ) + sizeof( ipv4_header_t );
const size_t ipv6_length = sizeof( ether_header_t ) + sizeof( ipv6_header_t );

const uint64_t all_wildcards = ( uint64_t )
  ( WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID ) +
    WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR ) );

static buffer *
setup_ether_packet( size_t length, uint16_t type ) {
  size_t l2_length = sizeof( ether_header_t );
  if ( type == ETH_ETHTYPE_TPID ) {
    length += sizeof( vlantag_header_t );
    l2_length += sizeof( vlantag_header_t );
  }

  /* Create the packet for test. */
  buffer *buf = alloc_buffer_with_length( length );
  append_back_buffer( buf, length );

  ether_header_t *ether = buf->data;
  ether->type = htons( type );
  memcpy( ( char * ) ether->macda, macda, ETH_ADDRLEN );
  memcpy( ( char * ) ether->macsa, macsa, ETH_ADDRLEN );

  vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );
  if ( type == ETH_ETHTYPE_TPID ) {
    vtag->tci = htons( 20483 ); // prio(3bit):010,cfi(1bit):1,vid(12bit):000000000011
  }

  /* Create the pakcet_info data for verification. */
  if ( buf->user_data == NULL ) {
    calloc_packet_info( buf );
  }
  packet_info *packet_info0 = buf->user_data;
  memcpy( packet_info0->eth_macda, macda, ETH_ADDRLEN );
  memcpy( packet_info0->eth_macsa, macsa, ETH_ADDRLEN );
  packet_info0->eth_type = type;
  packet_info0->vlan_tci = 20483;
  packet_info0->vlan_tpid = type;
  packet_info0->vlan_prio = 2;
  packet_info0->vlan_cfi = 1;
  packet_info0->vlan_vid = 3;
  packet_info0->format |= ETH_DIX;

  packet_info0->l2_header = buf->data;
  if ( type == ETH_ETHTYPE_TPID ) {
    packet_info0->l3_header = ( void * ) ( vtag + 1 );
    packet_info0->format |= ETH_8021Q;
  } 
  else { 
    packet_info0->l3_header = ( void * ) ( ether + 1 );
  }

  return buf;
}


static buffer *
setup_ipv4_packet( size_t length, uint16_t type ) {
  buffer *buf = setup_ether_packet( length, type );
  packet_info *packet_info0 = buf->user_data;

  /* Fill arp values into the test packet. */
  if ( type == ETH_ETHTYPE_TPID ) {
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );
    vtag->type = htons( ETH_ETHTYPE_IPV4 );
  }

  ipv4_header_t *ipv4 = packet_info0->l3_header;
  ipv4->version = IPVERSION;
  ipv4->ihl = sizeof( ipv4_header_t ) / 4;
  ipv4->tos = 0;
  ipv4->tot_len = htons( sizeof( ipv4_header_t ) );
  ipv4->ttl = 0;
  ipv4->csum = 0;
  ipv4->saddr = htonl( 0xC0A80067 );
  ipv4->daddr = htonl( 0xC0A80036 );
  ipv4->frag_off = htons( 0 );
  packet_info0->l4_header = ( void * ) ( ipv4 + 1 );

  switch ( type ) {
  case IPPROTO_ICMP:
    ipv4->protocol = ( uint8_t ) IPPROTO_ICMP;    
    icmp_header_t *icmpv4 = packet_info0->l4_header;
    icmpv4->type = ICMP_TYPE_UNREACH;
    icmpv4->code = ICMP_CODE_PORTUNREACH;
    break;

  case IPPROTO_UDP:
    ipv4->protocol = ( uint8_t ) IPPROTO_UDP;
    udp_header_t *udp = packet_info0->l4_header;
    udp->src_port = ntohs( src_port );
    udp->dst_port = ntohs( dst_port );
    break;
 
  case IPPROTO_TCP:
    ipv4->protocol = ( uint8_t ) IPPROTO_TCP;
    tcp_header_t *tcp = packet_info0->l4_header;
    tcp->src_port = ntohs( src_port );
    tcp->dst_port = ntohs( dst_port );
    break;

  case IPPROTO_SCTP:
    ipv4->protocol = ( uint8_t ) IPPROTO_SCTP;
    sctp_header_t *sctp = packet_info0->l4_header;
    sctp->src_port = ntohs( src_port );
    sctp->dst_port = ntohs( dst_port );
    break;

  default:
    break;
  }

  /* Fill ipv4/icmp/udp values into the packet_info data for verification. */
  packet_info0->eth_type = ETH_ETHTYPE_IPV4;
  packet_info0->ipv4_version = IPVERSION;
  packet_info0->ipv4_ihl = sizeof( ipv4_header_t ) / 4;
  packet_info0->ipv4_tos = 0;
  packet_info0->ipv4_tot_len = sizeof( ipv4_header_t );
  packet_info0->ipv4_ttl = 0;
  packet_info0->ipv4_checksum = 0;
  packet_info0->ipv4_saddr = 0xC0A80067;
  packet_info0->ipv4_daddr = 0xC0A80036;
  packet_info0->ipv4_frag_off = 0;
  packet_info0->ipv4_protocol = ( uint8_t ) type;
  packet_info0->format |= NW_IPV4;

  switch ( type ) {
  case IPPROTO_ICMP:
    packet_info0->icmpv4_type = ICMP_TYPE_UNREACH;
    packet_info0->icmpv4_code = ICMP_CODE_PORTUNREACH;
    packet_info0->format |= NW_ICMPV4;
    break;

  case IPPROTO_UDP:
    packet_info0->udp_src_port = src_port;
    packet_info0->udp_dst_port = dst_port;
    packet_info0->format |= TP_UDP;
    break;

  case IPPROTO_TCP:
    packet_info0->tcp_src_port = src_port;
    packet_info0->tcp_dst_port = dst_port;
    packet_info0->format |= TP_TCP;
    break;

  case IPPROTO_SCTP:
    packet_info0->sctp_src_port = src_port;
    packet_info0->sctp_dst_port = dst_port;
    packet_info0->format |= TP_SCTP;
    break;

  default:
    break;
  }
  
  return buf;
}


static buffer *
setup_ipv6_packet( size_t length, uint16_t type ) {
  buffer *buf = setup_ether_packet( length, type );
  packet_info *packet_info0 = buf->user_data;

  /* Fill ipv6 values into the test packet. */
  if ( type == ETH_ETHTYPE_TPID ) {
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );
    vtag->type = htons( ETH_ETHTYPE_IPV6 );
  }

  ipv6_header_t *ipv6 = packet_info0->l3_header;
  ipv6->hdrctl = htonl( 0x61312345 );
  ipv6->plen = 0x200; // dummy;
  ipv6->hoplimit = 0;
  memcpy( ipv6->saddr, v6sa.s6_addr, sizeof( ipv6->saddr ) );
  memcpy( ipv6->daddr, v6da.s6_addr, sizeof( ipv6->daddr ) );
  packet_info0->l4_header = ( void * ) ( ipv6 + 1 );

  switch ( type ) {
  case IPPROTO_ICMPV6:
    ipv6->nexthdr = ( uint8_t ) IPPROTO_ICMPV6;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6->type = 1;
    icmpv6->code = 2;
    break;

  case IPPROTO_UDP:
    ipv6->nexthdr = ( uint8_t ) IPPROTO_UDP;
    udp_header_t *udp = packet_info0->l4_header;
    udp->src_port = ntohs( src_port );
    udp->dst_port = ntohs( dst_port );
    break;
 
  case IPPROTO_TCP:
    ipv6->nexthdr = ( uint8_t ) IPPROTO_TCP;
    tcp_header_t *tcp = packet_info0->l4_header;
    tcp->src_port = ntohs( src_port );
    tcp->dst_port = ntohs( dst_port );
    break;

  case IPPROTO_SCTP:
    ipv6->nexthdr = ( uint8_t ) IPPROTO_SCTP;
    sctp_header_t *sctp = packet_info0->l4_header;
    sctp->src_port = ntohs( src_port );
    sctp->dst_port = ntohs( dst_port );
    break;

  default:
    break;
  }

  /* Fill values into the packet_info data for verification. */
  packet_info0->eth_type = ETH_ETHTYPE_IPV6;
  packet_info0->ipv6_version = 0x06;
  packet_info0->ipv6_tc = 0x13;
  packet_info0->ipv6_flowlabel = 0x12345;
  packet_info0->ipv6_plen = 0x200; // dummy
  packet_info0->ipv6_hoplimit = 0;
  memcpy( packet_info0->ipv6_saddr.s6_addr, v6sa.s6_addr, sizeof( struct in6_addr ) );
  memcpy( packet_info0->ipv6_daddr.s6_addr, v6da.s6_addr, sizeof( struct in6_addr ) );
  packet_info0->ipv6_nexthdr = type;
  packet_info0->ipv6_protocol = ( uint8_t ) type;;
  packet_info0->format |= NW_IPV6;

  packet_info0->ipv6_exthdr = ( OFPIEH_NONEXT | OFPIEH_ESP | OFPIEH_AUTH | OFPIEH_DEST | OFPIEH_FRAG | OFPIEH_ROUTER | OFPIEH_HOP );

  switch ( type ) {
  case IPPROTO_ICMPV6:
    packet_info0->icmpv6_type = 1;
    packet_info0->icmpv6_code = 2;
    packet_info0->format |= NW_ICMPV6;
    break;

  case IPPROTO_UDP:
    packet_info0->udp_src_port = src_port;
    packet_info0->udp_dst_port = dst_port;
    packet_info0->format |= TP_UDP;
    break;

  case IPPROTO_TCP:
    packet_info0->tcp_src_port = src_port;
    packet_info0->tcp_dst_port = dst_port;
    packet_info0->format |= TP_TCP;
    break;

  case IPPROTO_SCTP:
    packet_info0->sctp_src_port = src_port;
    packet_info0->sctp_dst_port = dst_port;
    packet_info0->format |= TP_SCTP;
    break;

  default:
    break;
  }
  
  return buf;
}


static buffer *
setup_ipv6_nd_packet( size_t length, uint16_t type, uint8_t icmpv6_type ) {
  buffer *buf = setup_ether_packet( length, type );
  packet_info *packet_info0 = buf->user_data;

  /* Fill ipv6 values into the test packet. */
  if ( type == ETH_ETHTYPE_TPID ) {
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );
    vtag->type = htons( ETH_ETHTYPE_IPV6 );
  }

  ipv6_header_t *ipv6 = packet_info0->l3_header;
  ipv6->hdrctl = htonl( 0x61312345 );
  ipv6->plen = 0x200; // dummy;
  ipv6->hoplimit = 0;
  memcpy( ipv6->saddr, v6sa.s6_addr, sizeof( ipv6->saddr ) );
  memcpy( ipv6->daddr, v6da.s6_addr, sizeof( ipv6->daddr ) );
  packet_info0->l4_header = ( void * ) ( ipv6 + 1 );

  ipv6->nexthdr = ( uint8_t ) IPPROTO_ICMPV6;
  icmpv6_header_t *icmpv6 = packet_info0->l4_header;
  icmpv6->type = icmpv6_type;
  icmpv6->code = 0;
  icmpv6data_ndp_t *ndp = ( icmpv6data_ndp_t * ) icmpv6->data;
  memcpy( ndp->nd_target, v6sa.s6_addr, sizeof( ndp->nd_target ) );
  if ( icmpv6_type == 135 ) {
    ndp->ll_type = 1;
    ndp->length = 1;
    memcpy( ndp->ll_addr, macsa, sizeof( ndp->ll_addr ) );
  } else if ( icmpv6_type == 136 ) {
    ndp->ll_type = 2;
    ndp->length = 1;
    memcpy( ndp->ll_addr, macsa, sizeof( ndp->ll_addr ) );
  }

  /* Fill values into the packet_info data for verification. */
  packet_info0->eth_type = ETH_ETHTYPE_IPV6;
  packet_info0->ipv6_version = 0x06;
  packet_info0->ipv6_tc = 0x13;
  packet_info0->ipv6_flowlabel = 0x12345;
  packet_info0->ipv6_plen = 0x200; // dummy
  packet_info0->ipv6_hoplimit = 0;
  memcpy( packet_info0->ipv6_saddr.s6_addr, v6sa.s6_addr, sizeof( struct in6_addr ) );
  memcpy( packet_info0->ipv6_daddr.s6_addr, v6da.s6_addr, sizeof( struct in6_addr ) );
  packet_info0->ipv6_nexthdr = type;
  packet_info0->ipv6_protocol = ( uint8_t ) type;;
  packet_info0->format |= NW_IPV6;

  packet_info0->ipv6_exthdr = ( OFPIEH_NONEXT | OFPIEH_ESP | OFPIEH_AUTH | OFPIEH_DEST | OFPIEH_FRAG | OFPIEH_ROUTER | OFPIEH_HOP );

  packet_info0->icmpv6_type = icmpv6_type;
  packet_info0->icmpv6_code = 0;
  memcpy( packet_info0->icmpv6_nd_target.s6_addr, v6sa.s6_addr, sizeof( packet_info0->icmpv6_nd_target.s6_addr ) );
  if ( icmpv6_type == 135 ) {
    packet_info0->icmpv6_nd_ll_type = 1;
    packet_info0->icmpv6_nd_ll_length = 1;
    memcpy( packet_info0->icmpv6_nd_sll, macsa, sizeof( packet_info0->icmpv6_nd_sll ) );
  } else if ( icmpv6_type == 136 ) {
    packet_info0->icmpv6_nd_ll_type = 2;
    packet_info0->icmpv6_nd_ll_length = 1;
    memcpy( packet_info0->icmpv6_nd_tll, macsa, sizeof( packet_info0->icmpv6_nd_tll ) );
  }
  packet_info0->format |= NW_ICMPV6;

  return buf;
}


static buffer *
setup_arp_packet( uint16_t type ) {
  buffer *buf = setup_ether_packet( sizeof( ether_header_t ) + sizeof( arp_header_t ), type );
  packet_info *packet_info0 = buf->user_data;
  
  /* Fill arp values into the test packet. */
  if ( type == ETH_ETHTYPE_TPID ) {
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );
    vtag->type = htons( ETH_ETHTYPE_ARP );
  }
  arp_header_t *arp = packet_info0->l3_header;
  arp->ar_hrd = htons( ARPHRD_ETHER );
  arp->ar_pro = htons( ETH_ETHTYPE_IPV4 );
  arp->ar_hln = ETH_ADDRLEN;
  arp->ar_pln = IPV4_ADDRLEN;
  arp->ar_op = htons( ARPOP_REPLY );
  arp->sha[ 0 ] = 0x00;
  arp->sha[ 1 ] = 0x01;
  arp->sha[ 2 ] = 0x02;
  arp->sha[ 3 ] = 0x03;
  arp->sha[ 4 ] = 0x04;
  arp->sha[ 5 ] = 0x05;
  arp->sip = htonl( 0x01020304 );
  arp->tha[ 0 ] = 0x06;
  arp->tha[ 1 ] = 0x07;
  arp->tha[ 2 ] = 0x08;
  arp->tha[ 3 ] = 0x09;
  arp->tha[ 4 ] = 0x0a;
  arp->tha[ 5 ] = 0x0b;
  arp->tip = htonl( 0x05060708 );

  /* Fill arp values into the packet_info data for verification. */
  packet_info0->eth_type = ETH_ETHTYPE_ARP;
  packet_info0->arp_ar_hrd = ARPHRD_ETHER;
  packet_info0->arp_ar_pro = ETH_ETHTYPE_IPV4;
  packet_info0->arp_ar_hln = ETH_ADDRLEN;
  packet_info0->arp_ar_pln = IPV4_ADDRLEN;
  packet_info0->arp_ar_op = ARPOP_REPLY;
  packet_info0->arp_sha[ 0 ] = 0x00;
  packet_info0->arp_sha[ 1 ] = 0x01;
  packet_info0->arp_sha[ 2 ] = 0x02;
  packet_info0->arp_sha[ 3 ] = 0x03;
  packet_info0->arp_sha[ 4 ] = 0x04;
  packet_info0->arp_sha[ 5 ] = 0x05;
  packet_info0->arp_spa = 0x01020304;
  packet_info0->arp_tha[ 0 ] = 0x06;
  packet_info0->arp_tha[ 1 ] = 0x07;
  packet_info0->arp_tha[ 2 ] = 0x08;
  packet_info0->arp_tha[ 3 ] = 0x09;
  packet_info0->arp_tha[ 4 ] = 0x0a;
  packet_info0->arp_tha[ 5 ] = 0x0b;
  packet_info0->arp_tpa = 0x05060708;
  packet_info0->format |= NW_ARP;

  return buf;
}


static buffer *
setup_mpls_packet( uint16_t type, uint16_t mpls_type ) {
  buffer *buf = setup_ether_packet( sizeof( ether_header_t ) + sizeof( mpls_header_t ), type );
  packet_info *packet_info0 = buf->user_data;
  
  /* Fill mpls values into the test packet. */
  if ( type == ETH_ETHTYPE_TPID ) {
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );
    vtag->type = htons( mpls_type );
  }
  mpls_header_t *mpls = packet_info0->l3_header;
  mpls->label = htonl( 0x12345b67 ); /* Label:0x12345, TC:0x5, BoS:0x1, TTL:0x67 */

  /* Fill mpls values into the packet_info data for verification. */
  packet_info0->eth_type = mpls_type;
  packet_info0->mpls_label = 0x12345b67;
  packet_info0->format |= ( MPLS | ETH_DIX );

  return buf;
}


static buffer *
setup_snap_packet( uint16_t type ) {
  buffer *buf = setup_ether_packet( sizeof( ether_header_t ) + sizeof( snap_header_t ), type );
  packet_info *packet_info0 = buf->user_data;

  size_t length = sizeof( ether_header_t ) + sizeof( snap_header_t );
  ether_header_t *ether = packet_info0->l2_header;
  if ( type == ETH_ETHTYPE_TPID ) {
    length += sizeof( vlantag_header_t );
    vlantag_header_t *vtag = ( void * ) ( ether + 1 );
    vtag->type = htons( ( uint16_t ) length );
  }  
  else {
    ether->type = htons( ( uint16_t ) length );
  }

  snap_header_t *snap = ( snap_header_t * ) packet_info0->l3_header;
  memcpy( ( char * ) snap, snap_data, sizeof( snap_header_t ) );

  return buf;
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_TPID );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_zero() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_ARP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    arp_header_t *arp = packet_info0->l3_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_arp_op( expected, ntohs( arp->ar_op ) );
    append_oxm_match_arp_spa( expected, ntohl( arp->sip ), mask.mask_arp_spa );
    append_oxm_match_arp_tpa( expected, ntohl( arp->tip ), mask.mask_arp_tpa );
    append_oxm_match_arp_sha( expected, arp->sha, mask.mask_arp_sha );
    append_oxm_match_arp_tha( expected, arp->tha, mask.mask_arp_tha );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_ALL() {
  buffer *buf = setup_arp_packet( ETH_ETHTYPE_TPID );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a udp data into the test packet */
  ipv4_header_t *ipv4 = packet->l3_header;
  ipv4->protocol = IPPROTO_UDP;
  udp_header_t *udp = packet->l4_header;
  udp->src_port = ntohs( src_port );
  udp->dst_port = ntohs( dst_port );

  /* Add the udp data into the packet_info data for verification. */
  packet->ipv4_protocol = IPPROTO_UDP;
  packet->udp_src_port = src_port;
  packet->udp_dst_port = dst_port;
  packet->format |= TP_UDP;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, ipv4->protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a tcp data into the test packet */
  ipv4_header_t *ipv4 = packet->l3_header;
  ipv4->protocol = IPPROTO_TCP;
  tcp_header_t *tcp = packet->l4_header;
  tcp->src_port = ntohs( src_port );
  tcp->dst_port = ntohs( dst_port );

  /* Add the tcp data into the packet_info data for verification. */
  packet->ipv4_protocol = IPPROTO_TCP;
  packet->tcp_src_port = src_port;
  packet->tcp_dst_port = dst_port;
  packet->format |= TP_TCP;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a sctp data into the test packet */
  ipv4_header_t *ipv4 = packet->l3_header;
  ipv4->protocol = IPPROTO_SCTP;
  sctp_header_t *sctp = packet->l4_header;
  sctp->src_port = ntohs( src_port );
  sctp->dst_port = ntohs( dst_port );

  /* Add the sctp data into the packet_info data for verification. */
  packet->ipv4_protocol = IPPROTO_SCTP;
  packet->sctp_src_port = src_port;
  packet->sctp_dst_port = dst_port;
  packet->format |= TP_SCTP;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet_info0 = buf->user_data;

  /* Add a icmp data into the test packet. */
  ipv4_header_t *ipv4 = packet_info0->l3_header;
  ipv4->protocol = IPPROTO_ICMP;
  icmp_header_t *icmpv4 = packet_info0->l4_header;    
  icmpv4->type = ICMP_TYPE_UNREACH;
  icmpv4->code = ICMP_CODE_PORTUNREACH;
  /* Add the icmp data into the packet_info data for verification. */
  packet_info0->ipv4_protocol = IPPROTO_ICMP;
  packet_info0->icmpv4_type = ICMP_TYPE_UNREACH;
  packet_info0->icmpv4_code = ICMP_CODE_PORTUNREACH;
  packet_info0->format |= NW_ICMPV4;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv4_header_t *ipv4 = packet_info0->l3_header;
    icmp_header_t *icmp = packet_info0->l4_header;

    uint8_t ip_dscp = ( uint8_t ) ( ipv4->tos >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv4->tos & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv4_protocol );
    append_oxm_match_ipv4_src( expected, ntohl( ipv4->saddr ), mask.mask_ipv4_src );
    append_oxm_match_ipv4_dst( expected, ntohl( ipv4->daddr ), mask.mask_ipv4_dst );
    append_oxm_match_icmpv4_type( expected, icmp->type );
    append_oxm_match_icmpv4_code( expected, icmp->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv4_packet( ipv4_length + sizeof( icmp_header_t ), IPPROTO_ICMP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a udp data into the test packet */
  ipv6_header_t *ipv6 = packet->l3_header;
  ipv6->nexthdr = IPPROTO_UDP;
  udp_header_t *udp = packet->l4_header;
  udp->src_port = ntohs( src_port );
  udp->dst_port = ntohs( dst_port );

  /* Add the udp data into the packet_info data for verification. */
  packet->ipv6_nexthdr = IPPROTO_UDP;
  packet->ipv6_protocol = IPPROTO_UDP;
  packet->udp_src_port = src_port;
  packet->udp_dst_port = dst_port;
  packet->format |= TP_UDP;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    udp_header_t *udp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_udp_src( expected, ntohs( udp->src_port ) );
    append_oxm_match_udp_dst( expected, ntohs( udp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( udp_header_t ), IPPROTO_UDP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a tcp data into the test packet */
  ipv6_header_t *ipv6 = packet->l3_header;
  ipv6->nexthdr = IPPROTO_TCP;
  tcp_header_t *tcp = packet->l4_header;
  tcp->src_port = ntohs( src_port );
  tcp->dst_port = ntohs( dst_port );

  /* Add the tcp data into the packet_info data for verification. */
  packet->ipv6_nexthdr = IPPROTO_TCP;
  packet->ipv6_protocol = IPPROTO_TCP;
  packet->tcp_src_port = src_port;
  packet->tcp_dst_port = dst_port;
  packet->format |= TP_TCP;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    tcp_header_t *tcp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_tcp_src( expected, ntohs( tcp->src_port ) );
    append_oxm_match_tcp_dst( expected, ntohs( tcp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( tcp_header_t ), IPPROTO_TCP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a sctp data into the test packet */
  ipv6_header_t *ipv6 = packet->l3_header;
  ipv6->nexthdr = IPPROTO_SCTP;
  sctp_header_t *sctp = packet->l4_header;
  sctp->src_port = ntohs( src_port );
  sctp->dst_port = ntohs( dst_port );

  /* Add the sctp data into the packet_info data for verification. */
  packet->ipv6_nexthdr = IPPROTO_SCTP;
  packet->ipv6_protocol = IPPROTO_SCTP;
  packet->sctp_src_port = src_port;
  packet->sctp_dst_port = dst_port;
  packet->format |= TP_SCTP;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    sctp_header_t *sctp = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_sctp_src( expected, ntohs( sctp->src_port ) );
    append_oxm_match_sctp_dst( expected, ntohs( sctp->dst_port ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( sctp_header_t ), IPPROTO_SCTP );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), ETH_ETHTYPE_TPID );
  packet_info *packet = buf->user_data;

  /* Add a icmpv6 data into the test packet */
  ipv6_header_t *ipv6 = packet->l3_header;
  ipv6->nexthdr = IPPROTO_ICMPV6;
  icmpv6_header_t *icmpv6 = packet->l4_header;
  icmpv6->type = 1;
  icmpv6->code = 2;

  /* Add the icmpv6 data into the packet_info data for verification. */
  packet->ipv6_nexthdr = IPPROTO_ICMPV6;
  packet->ipv6_protocol = IPPROTO_ICMPV6;
  packet->icmpv6_type = 1;
  packet->icmpv6_code = 2;
  packet->format |= NW_ICMPV6;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv6_packet( ipv6_length + sizeof( icmpv6_header_t ), IPPROTO_ICMPV6 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), ETH_ETHTYPE_TPID, 135 );
  packet_info *packet = buf->user_data;

  /* Add a icmpv6 nd data into the test packet */
  ipv6_header_t *ipv6 = packet->l3_header;
  ipv6->nexthdr = IPPROTO_ICMPV6;
  icmpv6_header_t *icmpv6 = packet->l4_header;
  icmpv6->type = 135;
  icmpv6->code = 0;
  icmpv6data_ndp_t *ndp = ( icmpv6data_ndp_t * ) icmpv6->data;
  memcpy( ndp->nd_target, v6sa.s6_addr, sizeof( ndp->nd_target ) );
  memcpy( ndp->ll_addr, macsa, sizeof( ndp->ll_addr ) );

  /* Add the icmpv6 nd data into the packet_info data for verification. */
  packet->ipv6_nexthdr = IPPROTO_ICMPV6;
  packet->ipv6_protocol = IPPROTO_ICMPV6;
  packet->icmpv6_type = 135;
  packet->icmpv6_code = 0;
  memcpy( packet->icmpv6_nd_target.s6_addr, v6sa.s6_addr, sizeof( packet->icmpv6_nd_target.s6_addr ) );
  memcpy( packet->icmpv6_nd_sll, macsa, sizeof( packet->icmpv6_nd_sll ) );
  packet->format |= NW_ICMPV6;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_sll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 135 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_tag_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), ETH_ETHTYPE_TPID, 136 );
  packet_info *packet = buf->user_data;

  /* Add a icmpv6 nd data into the test packet */
  ipv6_header_t *ipv6 = packet->l3_header;
  ipv6->nexthdr = IPPROTO_ICMPV6;
  icmpv6_header_t *icmpv6 = packet->l4_header;
  icmpv6->type = 136;
  icmpv6->code = 0;
  icmpv6data_ndp_t *ndp = ( icmpv6data_ndp_t * ) icmpv6->data;
  memcpy( ndp->nd_target, v6sa.s6_addr, sizeof( ndp->nd_target ) );
  memcpy( ndp->ll_addr, macsa, sizeof( ndp->ll_addr ) );

  /* Add the icmpv6 nd data into the packet_info data for verification. */
  packet->ipv6_nexthdr = IPPROTO_ICMPV6;
  packet->ipv6_protocol = IPPROTO_ICMPV6;
  packet->icmpv6_type = 136;
  packet->icmpv6_code = 0;
  memcpy( packet->icmpv6_nd_target.s6_addr, v6sa.s6_addr, sizeof( packet->icmpv6_nd_target.s6_addr ) );
  memcpy( packet->icmpv6_nd_sll, macsa, sizeof( packet->icmpv6_nd_sll ) );
  packet->format |= NW_ICMPV6;

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_zero() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_ipv6_exthdr( expected, packet_info0->ipv6_exthdr, mask.mask_ipv6_exthdr );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    ipv6_header_t *ipv6 = packet_info0->l3_header;
    icmpv6_header_t *icmpv6 = packet_info0->l4_header;
    icmpv6data_ndp_t *nd = ( icmpv6data_ndp_t * ) icmpv6->data;

    uint16_t ipv6_tc = ( uint16_t ) ( ntohl( ipv6->hdrctl ) >> 20 & 0xff );
    uint8_t ip_dscp = ( uint8_t ) ( ipv6_tc >> 2 & 0x3f );
    uint8_t ip_ecn = ( uint8_t ) ( ipv6_tc & 0x3 );
    uint32_t ipv6_flabel = ( uint32_t ) ( ntohl( ipv6->hdrctl ) & 0xfffff );
    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_ip_dscp( expected, ip_dscp );
    append_oxm_match_ip_ecn( expected, ip_ecn );
    append_oxm_match_ip_proto( expected, packet_info0->ipv6_protocol );
    append_oxm_match_ipv6_src( expected, *( ( struct in6_addr * ) ipv6->saddr ), mask.mask_ipv6_src );
    append_oxm_match_ipv6_dst( expected, *( ( struct in6_addr * ) ipv6->daddr ), mask.mask_ipv6_dst );
    append_oxm_match_ipv6_flabel( expected, ipv6_flabel, mask.mask_flabel );
    append_oxm_match_icmpv6_type( expected, icmpv6->type );
    append_oxm_match_icmpv6_code( expected, icmpv6->code );
    append_oxm_match_ipv6_nd_target( expected, *( ( struct in6_addr * ) nd->nd_target ) );
    append_oxm_match_ipv6_nd_tll( expected, nd->ll_addr );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_ALL() {
  buffer *buf = setup_ipv6_nd_packet( ipv6_length + sizeof( icmpv6_header_t ) + sizeof( icmpv6data_ndp_t ), IPPROTO_ICMPV6, 136 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_tag_and_wildcards_is_zero() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_TPID, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_zero() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_ALL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_UNI );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_tag_and_wildcards_is_zero() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_TPID, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_zero() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IN_PORT() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IN_PHY_PORT() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IN_PHY_PORT );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_METADATA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_METADATA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ETH_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ETH_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ETH_TYPE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ETH_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_VLAN_VID() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_VID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_VLAN_PCP() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_VLAN_PCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IP_DSCP() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_DSCP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IP_ECN() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_ECN );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IP_PROTO() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IP_PROTO );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV4_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV4_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV4_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_TCP_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_TCP_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TCP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_UDP_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_UDP_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_UDP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_SCTP_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_SCTP_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_SCTP_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV4_TYPE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV4_CODE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV4_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_OP() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_OP );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_SPA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_TPA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_TPA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_SHA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_SHA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_THA() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ARP_THA );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_SRC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_SRC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_DST() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_DST );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_FLABEL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_FLABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV6_TYPE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_TYPE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV6_CODE() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_ICMPV6_CODE );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_ND_TARGET() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TARGET );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_ND_SLL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_SLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_ND_TLL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_ND_TLL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_MPLS_LABEL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_LABEL );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_MPLS_TC() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_TC );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_MPLS_BOS() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_MPLS_BOS );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_PBB_ISID() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_PBB_ISID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_TUNNEL_ID() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_TUNNEL_ID );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_EXTHDR() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = WILDCARD_OFB_BIT( OFPXMT_OFB_IPV6_EXTHDR );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    mpls_header_t *mpls = packet_info0->l3_header;

    uint16_t vlan_vid = 0;
    uint32_t label = ( uint32_t ) ( ntohl( mpls->label ) >> 12 & 0xfffff );
    uint8_t tc = ( uint8_t ) ( ntohl( mpls->label ) >> 9 & 0x7 );
    uint8_t bos = ( uint8_t ) ( ntohl( mpls->label ) >> 8 & 0x1 );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
    append_oxm_match_mpls_label( expected, label );
    append_oxm_match_mpls_tc( expected, tc );
    append_oxm_match_mpls_bos( expected, bos );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_ALL() {
  buffer *buf = setup_mpls_packet( ETH_ETHTYPE_MPLS_UNI, ETH_ETHTYPE_MPLS_MLT );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );
  mask.wildcards = all_wildcards;

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_snap_tag_and_wildcards_is_zero() {
  buffer *buf = setup_snap_packet( ETH_ETHTYPE_TPID );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_netbios_tag_and_wildcards_is_zero() {
  buffer *buf = setup_snap_packet( ETH_ETHTYPE_TPID );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );

    snap_header_t *snap = ( snap_header_t * ) ( vtag + 1 );
    snap->llc[ 0 ] = 0xF0;
    snap->llc[ 1 ] = 0xF0;

    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_not_llc_tag_and_wildcards_is_zero() {
  buffer *buf = setup_snap_packet( ETH_ETHTYPE_TPID );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    vlantag_header_t *vtag = ( vlantag_header_t * ) ( ether + 1 );

    snap_header_t *snap = ( snap_header_t * ) ( vtag + 1 );
    snap->llc[ 0 ] = 0xFF;
    snap->llc[ 1 ] = 0xFF;

    uint16_t vlan_vid = ( uint16_t ) ( OFPVID_PRESENT | packet_info0->vlan_vid );

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_vlan_pcp( expected, packet_info0->vlan_prio );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_snap_and_wildcards_is_zero() {
  buffer *buf = setup_snap_packet( 0 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_netbios_and_wildcards_is_zero() {
  buffer *buf = setup_snap_packet( 0 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    snap_header_t *snap = ( snap_header_t * ) ( ether + 1 );
    snap->llc[ 0 ] = 0xF0;
    snap->llc[ 1 ] = 0xF0;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_not_llc_and_wildcards_is_zero() {
  buffer *buf = setup_snap_packet( 1 );

  uint16_t expected_in_port = 1;
  oxm_matches *match = create_oxm_matches();
  mask_fields mask;
  oxm_matches *expected = create_oxm_matches();

  memset( &mask, 0, sizeof( mask ) );

  // expected match data
  {
    packet_info *packet_info0 = buf->user_data;
    ether_header_t *ether = packet_info0->l2_header;
    snap_header_t *snap = ( snap_header_t * ) ( ether + 1 );
    snap->llc[ 0 ] = 0x00;
    snap->llc[ 1 ] = 0x00;

    uint16_t vlan_vid = 0;

    append_oxm_match_in_port( expected, expected_in_port );
    append_oxm_match_eth_src( expected, ether->macsa, mask.mask_eth_src );
    append_oxm_match_eth_dst( expected, ether->macda, mask.mask_eth_dst );
    append_oxm_match_vlan_vid( expected, vlan_vid, mask.mask_vlan_vid );
    append_oxm_match_eth_type( expected, packet_info0->eth_type );
  }

  set_match_from_packet( match, expected_in_port, &mask, buf );

  assert_int_equal( match->n_matches, expected->n_matches );

  list_element *x_elem = match->list;
  list_element *y_elem = expected->list;
  while ( x_elem != NULL ) {
    oxm_match_header *x = x_elem->data;
    oxm_match_header *y = y_elem->data;
    uint16_t len = ( uint16_t ) ( sizeof( oxm_match_header ) + OXM_LENGTH( *x ) );
    assert_memory_equal( x, y, len );
    x_elem = x_elem->next;
    y_elem = y_elem->next;
  }

  delete_oxm_matches( expected );
  delete_oxm_matches( match );
  free_buffer( buf );
}


static void
test_set_match_from_packet_fails_if_packet_data_is_NULL() {
  oxm_matches *match = create_oxm_matches();
  expect_assert_failure( set_match_from_packet( match, 1, 0, NULL ) );
  delete_oxm_matches( match );
}


static void
test_set_match_from_packet_fails_if_packet_is_not_parsed_yet() {
  oxm_matches *match = create_oxm_matches();
  buffer *buf = alloc_buffer( );

  expect_assert_failure( set_match_from_packet( match, 1, 0, buf ) );

  delete_oxm_matches( match );
  free_buffer( buf );
}


/********************************************************************************
 * Run tests.
 ********************************************************************************/

int
main() {
  const UnitTest tests[] = {
    unit_test( test_init_openflow_message ),

    unit_test_setup_teardown( test_get_transaction_id, init, teardown ),
    unit_test_setup_teardown( test_get_transaction_id_if_id_overflows, init, teardown ),
    unit_test_setup_teardown( test_get_cookie, init, teardown ),
    unit_test_setup_teardown( test_get_cookie_if_cookie_overflows, init, teardown ),

    unit_test_setup_teardown( test_create_hello, init, teardown ),
    unit_test_setup_teardown( test_validate_hello, init, teardown ),
    unit_test_setup_teardown( test_validate_hello_fails_with_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_hello_fails_with_non_hello_message, init, teardown ),

    unit_test_setup_teardown( test_create_error, init, teardown ),
    unit_test_setup_teardown( test_create_error_without_data, init, teardown ),
    unit_test_setup_teardown( test_create_error_experimenter, init, teardown ),
    unit_test_setup_teardown( test_create_error_experimenter_without_data, init, teardown ),

    unit_test_setup_teardown( test_create_echo_request, init, teardown ),
    unit_test_setup_teardown( test_create_echo_request_without_data, init, teardown ),
    unit_test_setup_teardown( test_validate_echo_request, init, teardown ),
    unit_test_setup_teardown( test_validate_echo_request_fails_with_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_echo_request_fails_with_non_echo_request_message, init, teardown ),

    unit_test_setup_teardown( test_create_echo_reply, init, teardown ),
    unit_test_setup_teardown( test_create_echo_reply_without_data, init, teardown ),
    unit_test_setup_teardown( test_validate_echo_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_echo_reply_fails_with_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_echo_reply_fails_with_non_echo_reply_message, init, teardown ),

    unit_test_setup_teardown( test_create_experimenter, init, teardown ),
    unit_test_setup_teardown( test_create_experimenter_without_data, init, teardown ),
    unit_test_setup_teardown( test_create_features_request, init, teardown ),
    unit_test_setup_teardown( test_create_features_reply, init, teardown ),
    unit_test_setup_teardown( test_create_get_config_request, init, teardown ),
    unit_test_setup_teardown( test_create_get_config_reply, init, teardown ),
    unit_test_setup_teardown( test_create_set_config, init, teardown ),
    unit_test_setup_teardown( test_create_packet_in, init, teardown ),
    unit_test_setup_teardown( test_create_flow_removed, init, teardown ),
    unit_test_setup_teardown( test_create_port_status, init, teardown ),
    unit_test_setup_teardown( test_create_group_mod, init, teardown ),
    unit_test_setup_teardown( test_create_port_mod, init, teardown ),
    unit_test_setup_teardown( test_create_table_mod, init, teardown ),
    unit_test_setup_teardown( test_create_and_delete_actions, init, teardown ),

    unit_test_setup_teardown( test_append_action_output, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_queue, init, teardown ),
    unit_test_setup_teardown( test_append_action_copy_ttl_out, init, teardown ),
    unit_test_setup_teardown( test_append_action_copy_ttl_in, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_mpls_ttl, init, teardown ),
    unit_test_setup_teardown( test_append_action_dec_mpls_ttl, init, teardown ),
    unit_test_setup_teardown( test_append_action_push_vlan, init, teardown ),
    unit_test_setup_teardown( test_append_action_pop_vlan, init, teardown ),
    unit_test_setup_teardown( test_append_action_push_mpls, init, teardown ),
    unit_test_setup_teardown( test_append_action_pop_mpls, init, teardown ),
    unit_test_setup_teardown( test_append_action_group, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_nw_ttl, init, teardown ),
    unit_test_setup_teardown( test_append_action_dec_nw_ttl, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_in_port, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_in_phy_port, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_metadata, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_eth_dst, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_eth_src, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_eth_type, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_vlan_vid, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_vlan_pcp, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ip_dscp, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ip_ecn, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ip_proto, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv4_src, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv4_dst, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_tcp_src, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_tcp_dst, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_udp_src, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_udp_dst, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_sctp_src, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_sctp_dst, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_icmpv4_type, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_icmpv4_code, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_arp_op, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_arp_spa, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_arp_tpa, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_arp_sha, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_arp_tha, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_src, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_dst, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_flabel, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_icmpv6_type, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_icmpv6_code, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_nd_target, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_nd_sll, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_nd_tll, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_mpls_label, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_mpls_tc, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_mpls_bos, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_pbb_isid, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_tunnel_id, init, teardown ),
    unit_test_setup_teardown( test_append_action_set_field_ipv6_exthdr, init, teardown ),
    unit_test_setup_teardown( test_append_action_push_pbb, init, teardown ),
    unit_test_setup_teardown( test_append_action_pop_pbb, init, teardown ),
    unit_test_setup_teardown( test_append_action_experimenter, init, teardown ),
    unit_test_setup_teardown( test_append_action_experimenter_without_data, init, teardown ),

    unit_test_setup_teardown( test_create_and_delete_instructions, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_goto_table, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_write_metadata, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_write_actions, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_apply_actions, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_clear_actions, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_meter, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_experimenter, init, teardown ),
    unit_test_setup_teardown( test_append_instructions_experimenter_without_data, init, teardown ),

    unit_test_setup_teardown( test_create_packet_out, init, teardown ),
    unit_test_setup_teardown( test_create_packet_out_without_actions, init, teardown ),
    unit_test_setup_teardown( test_create_flow_mod, init, teardown ),
    unit_test_setup_teardown( test_create_flow_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_flow_multipart_reply, init, teardown ),

    unit_test_setup_teardown( test_validate_aggregate_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_aggregate_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_aggregate_multipart_request_fails_if_message_is_not_aggregate_multipart_request, init, teardown ),

    unit_test_setup_teardown( test_create_aggregate_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_aggregate_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_port_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_port_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_queue_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_queue_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_desc_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_table_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_table_multipart_reply, init, teardown ),

    unit_test_setup_teardown( test_create_group_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_group_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_group_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_group_desc_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_group_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_group_features_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_meter_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_meter_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_meter_config_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_meter_config_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_meter_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_meter_features_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_table_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_table_features_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_port_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_port_desc_multipart_reply, init, teardown ),

    unit_test_setup_teardown( test_create_barrier_request, init, teardown ),
    unit_test_setup_teardown( test_create_barrier_reply, init, teardown ),
    unit_test_setup_teardown( test_create_queue_get_config_request, init, teardown ),
    unit_test_setup_teardown( test_create_queue_get_config_reply, init, teardown ),
    unit_test_setup_teardown( test_create_experimenter_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_create_experimenter_multipart_request_without_data, init, teardown ),
    unit_test_setup_teardown( test_create_experimenter_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_create_role_request, init, teardown ),
    unit_test_setup_teardown( test_create_role_reply, init, teardown ),
    unit_test_setup_teardown( test_create_get_async_request, init, teardown ),
    unit_test_setup_teardown( test_create_get_async_reply, init, teardown ),
    unit_test_setup_teardown( test_create_set_async, init, teardown ),
    unit_test_setup_teardown( test_create_meter_mod, init, teardown ),

    unit_test_setup_teardown( test_validate_error, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter_without_data, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter_fails_if_message_is_not_experimenter_header, init, teardown ),

    unit_test_setup_teardown( test_validate_features_request, init, teardown ),
    unit_test_setup_teardown( test_validate_features_request_fails_with_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_features_request_fails_with_non_features_request_message, init, teardown ),
    unit_test_setup_teardown( test_validate_features_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_get_config_request, init, teardown ),
    unit_test_setup_teardown( test_validate_get_config_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_get_config_request_fails_if_message_is_not_get_config_request, init, teardown ),
    unit_test_setup_teardown( test_validate_get_config_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_set_config, init, teardown ),
    unit_test_setup_teardown( test_validate_set_config_fails_with_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_set_config_fails_with_non_set_config_message, init, teardown ),
    unit_test_setup_teardown( test_validate_packet_in, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_removed, init, teardown ),
    unit_test_setup_teardown( test_validate_port_status, init, teardown ),
    unit_test_setup_teardown( test_validate_packet_out, init, teardown ),
    unit_test_setup_teardown( test_validate_packet_out_without_data, init, teardown ),
    unit_test_setup_teardown( test_validate_packet_out_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_packet_out_fails_if_message_is_not_packet_out, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_mod, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_mod_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_mod_fails_if_message_is_not_flow_mod, init, teardown ),

    unit_test_setup_teardown( test_validate_group_mod, init, teardown ),
    unit_test_setup_teardown( test_validate_group_mod_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_group_mod_fails_if_message_is_not_group_mod, init, teardown ),

    unit_test_setup_teardown( test_validate_port_mod, init, teardown ),
    unit_test_setup_teardown( test_validate_port_mod_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_port_mod_fails_if_message_is_not_port_mod, init, teardown ),

    unit_test_setup_teardown( test_validate_table_mod, init, teardown ),
    unit_test_setup_teardown( test_validate_table_mod_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_table_mod_fails_if_message_is_not_group_mod, init, teardown ),

    unit_test_setup_teardown( test_validate_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_desc_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_desc_multipart_request_fails_if_message_is_not_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_desc_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_multipart_request_fails_if_message_is_not_flow_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_flow_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_aggregate_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_table_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_table_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_table_multipart_request_fails_if_message_is_not_table_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_table_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_port_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_port_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_port_multipart_request_fails_if_message_is_not_port_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_port_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_queue_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_queue_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_queue_multipart_request_fails_if_message_is_not_queue_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_queue_multipart_reply, init, teardown ),

    unit_test_setup_teardown( test_validate_group_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_group_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_group_multipart_request_fails_if_message_is_not_group_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_group_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_group_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_group_desc_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_group_desc_multipart_request_fails_if_message_is_not_group_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_group_desc_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_group_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_group_features_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_group_features_multipart_request_fails_if_message_is_not_group_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_group_features_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_multipart_request_fails_if_message_is_not_meter_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_config_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_config_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_config_multipart_request_fails_if_message_is_not_meter_config_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_config_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_features_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_features_multipart_request_fails_if_message_is_not_meter_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_features_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_table_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_table_features_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_table_features_multipart_request_fails_if_message_is_not_table_features_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_table_features_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_port_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_port_desc_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_port_desc_multipart_request_fails_if_message_is_not_port_desc_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_port_desc_multipart_reply, init, teardown ),

    unit_test_setup_teardown( test_validate_experimenter_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter_multipart_request_fails_if_message_is_not_experimenter_multipart_request, init, teardown ),
    unit_test_setup_teardown( test_validate_experimenter_multipart_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_DESC_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_FLOW_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_AGGREGATE_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_TABLE_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_PORT_STATS_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_QUEUE_message, init, teardown ),

    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_GROUP_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_GROUP_DESC_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_GROUP_FEATURES_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_METER_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_METER_CONFIG_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_METER_FEATURES_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_TABLE_FEATURES_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_PORT_DESC_message, init, teardown ),

    unit_test_setup_teardown( test_validate_multipart_request_sucseed_with_OFPMP_EXPERIMENTER_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_request_fails_with_unsupported_multipart_type, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_DESC_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_FLOW_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_AGGREGATE_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_TABLE_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_PORT_STATS_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_QUEUE_message, init, teardown ),

    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_GROUP_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_GROUP_DESC_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_GROUP_FEATURES_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_METER_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_METER_CONFIG_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_METER_FEATURES_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_TABLE_FEATURES_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_PORT_DESC_message, init, teardown ),

    unit_test_setup_teardown( test_validate_multipart_reply_with_OFPMP_EXPERIMENTER_message, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_multipart_reply_fails_with_unsupported_multipart_type, init, teardown ),
    unit_test_setup_teardown( test_validate_barrier_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_queue_get_config_reply, init, teardown ),

    unit_test_setup_teardown( test_validate_role_request, init, teardown ),
    unit_test_setup_teardown( test_validate_role_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_get_async_request, init, teardown ),
    unit_test_setup_teardown( test_validate_get_async_reply, init, teardown ),
    unit_test_setup_teardown( test_validate_set_async, init, teardown ),
    unit_test_setup_teardown( test_validate_meter_mod, init, teardown ),

    unit_test_setup_teardown( test_validate_action_output, init, teardown ),
    unit_test_setup_teardown( test_validate_action_output_fails_with_invalid_action_type, init, teardown ),
    unit_test_setup_teardown( test_validate_action_output_fails_with_too_short_ofp_action_output, init, teardown ),
    unit_test_setup_teardown( test_validate_action_output_fails_with_too_long_ofp_action_output, init, teardown ),
    unit_test_setup_teardown( test_validate_action_output_fails_with_invalid_port_no, init, teardown ),

    unit_test_setup_teardown( test_validate_action_copy_ttl_out , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_out_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_out_with_too_short_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_out_with_too_long_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_in , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_in_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_in_with_too_short_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_copy_ttl_in_with_too_long_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_mpls_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_mpls_ttl_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_mpls_ttl_with_too_short_ofp_action_mpls_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_mpls_ttl_with_too_long_ofp_action_mpls_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_mpls_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_mpls_ttl_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_mpls_ttl_with_too_short_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_mpls_ttl_with_too_long_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_vlan , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_vlan_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_vlan_with_too_short_ofp_action_push , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_vlan_with_too_long_ofp_action_push , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_vlan , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_vlan_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_vlan_with_too_short_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_vlan_with_too_long_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_mpls , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_mpls_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_mpls_with_too_short_ofp_action_push , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_mpls_with_too_long_ofp_action_push , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_mpls , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_mpls_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_mpls_with_too_short_ofp_action_pop_mpls , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_mpls_with_too_long_ofp_action_pop_mpls , init, teardown ),
    unit_test_setup_teardown( test_validate_action_group , init, teardown ),
    unit_test_setup_teardown( test_validate_action_group_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_group_with_too_short_ofp_action_group , init, teardown ),
    unit_test_setup_teardown( test_validate_action_group_with_too_long_ofp_action_group , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_nw_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_nw_ttl_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_nw_ttl_with_too_short_ofp_action_nw_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_nw_ttl_with_too_long_ofp_action_nw_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_nw_ttl , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_nw_ttl_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_nw_ttl_with_too_short_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_dec_nw_ttl_with_too_long_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_field , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_field_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_field_with_too_short_ofp_action_set_field , init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_field_with_too_long_ofp_action_set_field , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_pbb , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_pbb_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_pbb_with_too_short_ofp_action_push , init, teardown ),
    unit_test_setup_teardown( test_validate_action_push_pbb_with_too_long_ofp_action_push , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_pbb , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_pbb_fails_with_invalid_action_type , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_pbb_with_too_short_ofp_action_header , init, teardown ),
    unit_test_setup_teardown( test_validate_action_pop_pbb_with_too_long_ofp_action_header , init, teardown ),

    unit_test_setup_teardown( test_validate_action_set_queue, init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_queue_fails_with_invalid_action_type, init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_queue_fails_with_too_short_ofp_action_set_queue, init, teardown ),
    unit_test_setup_teardown( test_validate_action_set_queue_fails_with_too_long_ofp_action_set_queue, init, teardown ),
    unit_test_setup_teardown( test_validate_action_experimenter, init, teardown ),
    unit_test_setup_teardown( test_validate_action_experimenter_fails_with_invalid_action_type, init, teardown ),
    unit_test_setup_teardown( test_validate_action_experimenter_fails_with_too_short_ofp_action_experimenter_header, init, teardown ),

    unit_test_setup_teardown( test_validate_instructions_goto_table , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_goto_table_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_goto_table_with_too_short_ofp_instruction_goto_table , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_goto_table_with_too_long_ofp_instruction_goto_table , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_metadata , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_metadata_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_metadata_with_too_short_ofp_instruction_write_metadata , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_metadata_with_too_long_ofp_instruction_write_metadata , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_actions_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_actions_with_too_short_ofp_instruction_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_write_actions_with_too_long_ofp_instruction_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_apply_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_apply_actions_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_apply_actions_with_too_short_ofp_instruction_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_apply_actions_with_too_long_ofp_instruction_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_clear_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_clear_actions_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_clear_actions_with_too_short_ofp_instruction_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_clear_actions_with_too_long_ofp_instruction_actions , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_meter , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_meter_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_meter_with_too_short_ofp_instruction_meter , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_meter_with_too_long_ofp_instruction_meter , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_experimenter , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_experimenter_fails_with_invalid_instruction_type , init, teardown ),
    unit_test_setup_teardown( test_validate_instructions_experimenter_with_too_short_ofp_instruction , init, teardown ),

    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_HELLO_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_ERROR_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_ECHO_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_ECHO_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_EXPERIMENTER_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_FEATURES_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_FEATURES_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_GET_CONFIG_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_GET_CONFIG_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_SET_CONFIG_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_PACKET_IN_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_FLOW_REMOVED_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_PORT_STATUS_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_PACKET_OUT_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_FLOW_MOD_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_GROUP_MOD_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_PORT_MOD_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_TABLE_MOD_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_MULTIPART_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_MULTIPART_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_BARRIER_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_BARRIER_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_QUEUE_GET_CONFIG_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_QUEUE_GET_CONFIG_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_ROLE_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_ROLE_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_GET_ASYNC_REQUEST_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_GET_ASYNC_REPLY_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_SET_ASYNC_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_succeeds_with_valid_OFPT_METER_MOD_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_fails_with_undefined_type_message, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_fails_if_message_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_validate_openflow_message_fails_if_data_is_NULL, init, teardown ),

    unit_test_setup_teardown( test_valid_openflow_message, init, teardown ),
    unit_test_setup_teardown( test_valid_openflow_message_fails_with_undefined_type_message, init, teardown ),

    unit_test_setup_teardown( test_get_error_type_and_code_succeeds_with_OFPT_ECHO_REQUEST_and_ERROR_UNSUPPORTED_VERSION, init, teardown ),
    unit_test_setup_teardown( test_get_error_type_and_code_succeeds_with_invalid_type_and_ERROR_UNSUPPORTED_VERSION, init, teardown ),
    unit_test_setup_teardown( test_get_error_type_and_code_fails_with_OFPT_ECHO_REQUEST_and_ERROR_TOO_SHORT_ACTION_OUTPUT, init, teardown ),

    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_arp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_udp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_tcp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_sctp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv4_icmp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_udp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_tcp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_sctp_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_solicitation_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ipv6_icmpv6_neighbor_advertisement_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_uni_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IN_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IN_PHY_PORT, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_METADATA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ETH_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ETH_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ETH_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_VLAN_VID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_VLAN_PCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IP_DSCP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IP_ECN, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IP_PROTO, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV4_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV4_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_TCP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_TCP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_UDP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_UDP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_SCTP_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_SCTP_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV4_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV4_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_OP, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_SPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_TPA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_SHA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ARP_THA, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_SRC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_DST, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_FLABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV6_TYPE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_ICMPV6_CODE, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_ND_TARGET, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_ND_SLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_ND_TLL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_MPLS_LABEL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_MPLS_TC, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_MPLS_BOS, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_PBB_ISID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_TUNNEL_ID, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_OFB_IPV6_EXTHDR, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_mpls_mlt_and_wildcards_is_ALL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_snap_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_snap_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_netbios_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_netbios_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_not_llc_tag_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_succeeds_if_datatype_is_ieee8023_not_llc_and_wildcards_is_zero, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_fails_if_packet_data_is_NULL, init, teardown ),
    unit_test_setup_teardown( test_set_match_from_packet_fails_if_packet_is_not_parsed_yet, init, teardown ),
  };
  setup_leak_detector();
  return run_tests( tests );
}


/*
 * Local variables:
 * c-basic-offset: 2
 * indent-tabs-mode: nil
 * End:
 */
